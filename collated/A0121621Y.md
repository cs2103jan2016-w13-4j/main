# A0121621Y
###### src\main\java\dummy\Dummy.java
``` java
package dummy;

/**
 * Dummy class is used in DummyTest to validate the functionality of the test utility
 *
 * @author Kai Yuan
 */
public class Dummy {

    /**
     * @return true, always.
     */
    public boolean isPresent() {
        return true;
    }

}
```
###### src\main\java\jfdi\common\utilities\JfdiLogger.java
``` java
package jfdi.common.utilities;

import java.io.File;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import com.google.common.io.Files;

import jfdi.storage.Constants;

public class JfdiLogger {

    public static Logger logger = null;

    public static Logger getLogger() {
        try {
            if (logger == null) {
                logger = Logger.getLogger("JfdiLogger");
                FileHandler fileHandler;

                // Ensure that the logging directory is created
                String loggingFilePath = Constants.PATH_LOG_FILE.toString();
                Files.createParentDirs(new File(loggingFilePath));

                // Configure the logging path
                fileHandler = new FileHandler(loggingFilePath);
                logger.addHandler(fileHandler);

                // Configure the log formatter
                SimpleFormatter formatter = new SimpleFormatter();
                fileHandler.setFormatter(formatter);

                logger.setLevel(Level.ALL);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return logger;
    }
}
```
###### src\main\java\jfdi\storage\apis\AliasAttributes.java
``` java
package jfdi.storage.apis;

import jfdi.storage.entities.Alias;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

/**
 * This is the data transfer class of the Alias entity.
 *
 * @author Thng Kai Yuan
 *
 */
public class AliasAttributes {

    // The regex for checking if a given word is a valid command
    private static String commandRegex = null;

    private String alias;
    private String command;

    /**
     * Constructs an AliasAttributes from an Alias.
     *
     * @param alias
     *            the alias to construct from
     */
    public AliasAttributes(Alias alias) {
        assert alias != null;
        this.alias = alias.getAlias();
        this.command = alias.getCommand();
    }

    /**
     * Constructs an AliasAttributes from an alias and command string.
     *
     * @param alias
     *            the alias for this command
     * @param command
     *            the command that is to be aliased
     */
    public AliasAttributes(String alias, String command) {
        assert alias != null && command != null;
        this.alias = alias;
        this.command = command;
    }

    /**
     * Sets the regex used for checking if a given word is a valid command.
     *
     * @param regex
     *            the regex that checks if a given word is a command command
     */
    public static void setCommandRegex(String regex) {
        assert regex != null;
        commandRegex = regex;
    }

    /**
     * @return the alias
     */
    public String getAlias() {
        return alias;
    }

    /**
     * @return the command that is aliased
     */
    public String getCommand() {
        return command;
    }

    /**
     * This method creates a new alias in the database with the given
     * attributes.
     *
     * @throws InvalidAliasParametersException
     *             if the aliasAttributes contains an invalid attribute
     * @throws DuplicateAliasException
     *             if the alias already exists in the database
     */
    public void save() throws InvalidAliasParametersException, DuplicateAliasException {
        validateAttributes();
        AliasDb.getInstance().create(this);
    }

    /**
     * Converts the current AliasAttributes to an Alias entity.
     *
     * @return the corresponding Alias
     */
    public Alias toEntity() {
        return new Alias(alias, command);
    }

    /**
     * This method checks if the current alias is valid.
     *
     * @return a boolean indicating if the current alias is valid
     */
    public boolean isValid() {
        if (alias == null || command == null || isValidCommand(alias) || !isValidCommand(command)) {
            return false;
        }

        return true;
    }

    /**
     * Validates the existing AliasAttributes.
     *
     * @throws InvalidAliasParametersException
     *             if any of the parameters are invalid
     */
    private void validateAttributes() throws InvalidAliasParametersException {
        if (!isValid()) {
            throw new InvalidAliasParametersException(this);
        }
    }

    /**
     * This method checks if a given string matches the command regex (i.e. if a
     * string is a command word).
     *
     * @param input
     *            the string to be checked
     * @return boolean indicating if the input is a command word
     */
    private boolean isValidCommand(String input) {
        assert commandRegex != null;
        return input.matches(commandRegex);
    }

}
```
###### src\main\java\jfdi\storage\apis\AliasDb.java
``` java
package jfdi.storage.apis;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

import jfdi.storage.Constants;
import jfdi.storage.FileManager;
import jfdi.storage.IDatabase;
import jfdi.storage.entities.Alias;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.FilePathPair;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.serializer.Serializer;

/**
 * This class manages the collection of Aliases persisted in the program
 * storage.
 *
 * @author Thng Kai Yuan
 *
 */
public class AliasDb implements IDatabase {

    // Singleton instance of AliasDb
    private static AliasDb instance = null;

    // The list of existing and deleted aliases
    private ArrayList<Alias> aliasList = new ArrayList<Alias>();
    private ArrayList<Alias> deletedAliasList = new ArrayList<Alias>();

    // The filepath to the data file
    private Path filePath = null;

    /**
     * This private constructor prevents more instances of AliasDb from being
     * created.
     */
    private AliasDb() {}

    /**
     * This method returns the singleton instance of AliasDb.
     *
     * @return the singleton instance of AliasDb
     */
    public static AliasDb getInstance() {
        if (instance == null) {
            instance = new AliasDb();
        }
        return instance;
    }

    /**
     * This method creates a new alias if the given aliasAttributes is not a
     * duplicate of an existing alias in the database.
     *
     * @param aliasAttributes
     *            the mapping of alias to command that is to be created
     * @throws DuplicateAliasException
     *             if the given alias already exists in the database
     */
    public void create(AliasAttributes aliasAttributes) throws DuplicateAliasException {
        assert aliasAttributes != null;
        if (isDuplicate(aliasAttributes)) {
            throw new DuplicateAliasException(aliasAttributes);
        }
        aliasList.add(aliasAttributes.toEntity());
        persist();
    }

    /**
     * This method returns all the aliases (in the form of their attributes)
     * currently stored in the program's internal state.
     *
     * @return a Collection of AliasAttributes
     */
    public Collection<AliasAttributes> getAll() {
        ArrayList<AliasAttributes> aliasAttributes = new ArrayList<AliasAttributes>();
        for (Alias alias : aliasList) {
            aliasAttributes.add(new AliasAttributes(alias));
        }
        return aliasAttributes;
    }

    /**
     * This method returns the command corresponding to an alias currently
     * stored in the program
     *
     * @param alias
     *            the alias whose command we want to retrieve
     * @return the command if the given alias exists in the program's storage
     * @throws InvalidAliasException
     *             if the alias does not exist in the database
     */
    public String getCommandFromAlias(String alias) throws InvalidAliasException {
        assert alias != null;
        for (Alias aliasRecord : aliasList) {
            if (aliasRecord.getAlias().equals(alias)) {
                return aliasRecord.getCommand();
            }
        }

        throw new InvalidAliasException(alias);
    }

    /**
     * This method checks if a given alias exists in the database.
     *
     * @param alias
     *            the alias to be checked
     * @return boolean indicating if the alias exists in the database
     */
    public boolean hasAlias(String alias) {
        assert alias != null;
        return aliasList.stream().anyMatch(aliasRecord -> {
            return aliasRecord.getAlias().equals(alias);
        });
    }

    /**
     * This method soft-deletes an existing alias.
     *
     * @param alias
     *            the alias that we want to delete
     * @throws InvalidAliasException
     *             if the alias does not exist in the database
     */
    public void destroy(String alias) throws InvalidAliasException {
        assert alias != null;
        for (Alias aliasRecord : aliasList) {
            if (aliasRecord.getAlias().equals(alias)) {
                aliasList.remove(aliasRecord);
                deletedAliasList.add(aliasRecord);
                persist();
                return;
            }
        }
        throw new InvalidAliasException(alias);
    }

    /**
     * This method restores an alias that was soft-deleted earlier.
     *
     * @param alias
     *            the alias that we want to recover
     * @throws InvalidAliasException
     *             if the alias does not exist in the database
     */
    public void undestroy(String alias) throws InvalidAliasException {
        assert alias != null;
        Alias deletedAlias = null;

        // Start searching from the back to undestroy the latest matching alias
        // if does not already exist
        for (int i = deletedAliasList.size() - 1; i >= 0; i--) {
            deletedAlias = deletedAliasList.get(i);
            if (deletedAlias.getAlias().equals(alias)
                    && !isDuplicate(new AliasAttributes(deletedAlias))) {
                deletedAliasList.remove(i);
                aliasList.add(deletedAlias);
                persist();
                return;
            }
        }
        throw new InvalidAliasException(alias);
    }

    /**
     * This method checks if the given alias already exists in the program's
     * storage.
     *
     * @param alias
     *            the alias that we want to check
     * @return boolean indicating if the alias already exists
     */
    private boolean isDuplicate(AliasAttributes aliasAttributes) {
        assert aliasAttributes != null;
        String alias = aliasAttributes.getAlias();
        return aliasList.stream().anyMatch(aliasRecord -> {
            return aliasRecord.getAlias().equals(alias);
        });
    }

    /**
     * This method persists all existing aliases to the file system.
     */
    public void persist() {
        String json = Serializer.serialize(aliasList);
        FileManager.writeToFile(json, filePath);
    }

    /**
     * This method resets the program's internal storage of aliases. This method
     * should only be used by the public in tests.
     */
    public void reset() {
        aliasList = new ArrayList<Alias>();
        deletedAliasList = new ArrayList<Alias>();
    }

    /**
     * This method sets the filepath of the record using absoluteFolderPath to
     * store the record's data file.
     *
     * @param absoluteFolderPath
     *            the directory that should contain the data file
     */
    public void setFilePath(String absoluteFolderPath) {
        assert absoluteFolderPath != null;
        filePath = Paths.get(absoluteFolderPath, Constants.FILENAME_ALIAS);
    }

    /**
     * @return the path of the record as set using the setFilePath method
     */
    public Path getFilePath() {
        return filePath;
    }

    /**
     * This method loads the aliases currently stored in the file given by
     * filePath
     *
     * @return a FilePathPair if the existing file cannot be read and was
     *         renamed
     */
    public FilePathPair load() {
        if (!Files.exists(filePath)) {
            return null;
        }

        String persistedJsonData = FileManager.readFileToString(filePath);
        Alias[] aliasArray = Serializer.deserialize(persistedJsonData, Alias[].class);
        aliasArray = validateAliasArray(aliasArray);

        if (aliasArray != null) {
            aliasList = new ArrayList<Alias>(Arrays.asList(aliasArray));
            deletedAliasList = new ArrayList<Alias>();
            return null;
        } else {
            reset();
        }

        String movedTo = FileManager.backupAndRemove(filePath);
        return new FilePathPair(filePath.toString(), movedTo);
    }

    /**
     * This method validates an array of Aliases. If any of the Aliases are
     * invalid, null is returned. Otherwise, the original aliasArray is
     * returned.
     *
     * @param aliasArray
     *            the array of Alias that is to be validated
     * @return null if any of the aliases are invalid, otherwise the original
     *         aliasArray is returned
     */
    private Alias[] validateAliasArray(Alias[] aliasArray) {
        if (aliasArray == null) {
            return null;
        }

        for (Alias alias : aliasArray) {
            if (!(new AliasAttributes(alias).isValid())) {
                return null;
            }
        }

        return aliasArray;
    }

}
```
###### src\main\java\jfdi\storage\apis\IStorage.java
``` java
package jfdi.storage.apis;

import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * The Storage interface deals with all the file path operations within the
 * program.
 *
 * @author Thng Kai Yuan
 */
public interface IStorage {

    /**
     * This method initializes storage with data from the folder used in the
     * previous program run. If no existing data files are found, Storage is
     * initialized with no data. If an invalid data files are found at the given
     * location, the invalid files will be renamed and kept as a backup while a
     * new file will overwrite the existing invalid file.
     *
     * @throws FilesReplacedException
     *             if existing unrecognized data files are found and replaced
     *             (with backups made) in the given storageFolderPath
     * @throws InvalidFilePathException
     *             if the given path is invalid
     */
    void initialize() throws FilesReplacedException, InvalidFilePathException;

    /**
     * This method can only be executed after storage is initialized. It
     * attempts to load data from the given directory and if the existing data
     * is not readable, the files are replaced with blank data files. This new
     * storage path is then remembered and used during the next program run.
     *
     * @param newStorageFolderPath
     *            the path to the directory that contains the JFDI user data
     * @throws InvalidFilePathException
     *             if the given path is invalid
     * @throws FilesReplacedException
     *             if invalid files were replaced in the process
     */
    void use(String newStorageFolderPath) throws InvalidFilePathException, FilesReplacedException;

    /**
     * This method can only be executed after storage is initialized. It saves
     * and transfers existing data in the current storage folder path into the
     * new storage folder path. The old files are then deleted upon a successful
     * transfer. This new storage path is then stored as the storage path that
     * is to be used in the next program run.
     *
     * @param newStorageFolderPath
     *            the absolute path of the directory that data is to be
     *            transferred to
     * @throws InvalidFilePathException
     *             if the program does not have sufficient permissions to carry
     *             out file operations in newStorageFolderPath
     * @throws FilesReplacedException
     *             if existing files had to be replaced (with backups made) in
     *             the newStorageFolderPath
     */
    void changeDirectory(String newStorageFolderPath) throws InvalidFilePathException,
            FilesReplacedException;

    /**
     * This method returns the path of the current storage directory.
     *
     * @return the path of the current storage directory.
     */
    String getCurrentDirectory();

}
```
###### src\main\java\jfdi\storage\apis\MainStorage.java
``` java
package jfdi.storage.apis;

import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.Logger;

import jfdi.common.utilities.JfdiLogger;
import jfdi.storage.Constants;
import jfdi.storage.DatabaseManager;
import jfdi.storage.FileManager;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * This class deals with all the file path operations within the Storage
 * component.
 *
 * @author Thng Kai Yuan
 */
public class MainStorage implements IStorage {

    // The singleton instance of MainStorage
    private static MainStorage instance = null;

    // Boolean indicating if storage has been initialized
    private boolean isInitialized = false;

    // Path to the current storage directory
    private String currentDirectory = null;

    // Logger for events
    private Logger logger = null;

    /**
     * This private constructor prevents itself from being called by other
     * components. An instance of FileStorage should be initialized using the
     * getInstance method.
     */
    private MainStorage() {
        logger = JfdiLogger.getLogger();
    }

    /**
     * @return the singleton instance of MainStorage
     */
    public static MainStorage getInstance() {
        if (instance == null) {
            instance = new MainStorage();
        }
        return instance;
    }

    /**
     * This method sets the existing instance to null. It should only be used
     * for testing/debugging purposes only.
     */
    public void removeInstance() {
        instance = null;
    }

    @Override
    public void initialize() throws FilesReplacedException, InvalidFilePathException {
        String storageDirectory = getInitializationPath();
        String dataDirectory = getDataDirectory(storageDirectory);
        load(dataDirectory);
        isInitialized = true;
        setCurrentDirectory(storageDirectory);
    }

    @Override
    public void use(String newStorageFolderPath) throws InvalidFilePathException, FilesReplacedException {
        assert isInitialized;
        load(getDataDirectory(newStorageFolderPath));
        setPreferredDirectory(newStorageFolderPath);
        setCurrentDirectory(newStorageFolderPath);
    }

    @Override
    public void changeDirectory(String newStorageFolderPath) throws InvalidFilePathException, FilesReplacedException {
        assert isInitialized;
        String newDataDirectory = getDataDirectory(newStorageFolderPath);
        FileManager.prepareDirectory(newDataDirectory);
        FileManager.moveFilesToDirectory(newDataDirectory);
        DatabaseManager.setAllFilePaths(newDataDirectory);
        setPreferredDirectory(newStorageFolderPath);
        setCurrentDirectory(newStorageFolderPath);
    }

    @Override
    public String getCurrentDirectory() {
        assert isInitialized;
        return currentDirectory;
    }

    /**
     * @param currentDirectory the currentDirectory to set
     */
    private void setCurrentDirectory(String currentDirectory) {
        assert currentDirectory != null;
        Path absolutePath = Paths.get(currentDirectory).toAbsolutePath();
        this.currentDirectory = absolutePath.toString();
        logger.fine(String.format(Constants.MESSAGE_LOG_SET_DIRECTORY, absolutePath));
    }

    /**
     * This method loads any existing data from the given storageFolderPath. If
     * no existing data is found, Storage is initialized with no data. If an
     * invalid file is found at the given location, the invalid file will be
     * renamed and kept as a backup while a new file will overwrite the existing
     * invalid file.
     *
     * @param storageFolderPath
     *            the absolute path of the directory that data is to be loaded
     *            from and saved to
     * @throws InvalidFilePathException
     *             if the program does not have sufficient permissions to carry
     *             out file operations in storageFolderPath
     * @throws FilesReplacedException
     *             if existing unrecognized data files are found and replaced
     *             (with backups made) in the given storageFolderPath
     */
    public void load(String storageFolderPath) throws InvalidFilePathException, FilesReplacedException {
        assert storageFolderPath != null;
        FileManager.prepareDirectory(storageFolderPath);
        DatabaseManager.setAllFilePaths(storageFolderPath);
        DatabaseManager.resetAll();
        DatabaseManager.loadAllDatabases();
    }

    /**
     * This method returns the path to the data directory within the storage
     * directory.
     *
     * @param storageDirectory
     *            the folder which should store the user data
     * @return the path to the data directory within the storage directory
     */
    public String getDataDirectory(String storageDirectory) {
        assert storageDirectory != null;
        return Paths.get(storageDirectory, Constants.FILENAME_DATA_DIRECTORY).toString();
    }

    /**
     * This method returns the storage path that should be used for the initial
     * load. If a preferred directory is found, it is used. Otherwise, we use
     * the default directory.
     *
     * @return the directory that should be used for the initial load
     */
    private String getInitializationPath() {
        String initDirectory = getPreferredDirectory();
        if (initDirectory == null) {
            initDirectory = getDefaultDirectory();
        }
        return initDirectory;
    }

    /**
     * This method returns the default directory that stores the path of the
     * preferred storage directory.
     *
     * @return the default directory
     */
    private String getDefaultDirectory() {
        return Constants.PATH_DEFAULT_DIRECTORY;
    }

    /**
     * This method returns the preferred directory stored in the preference file
     * if the stored path is valid.
     *
     * @return the stored preference if it is valid
     */
    public String getPreferredDirectory() {
        if (!Files.exists(Constants.PATH_PREFERENCE_FILE)) {
            return null;
        }

        try {
            String preference = FileManager.readFileToString(Constants.PATH_PREFERENCE_FILE);
            return Paths.get(preference).toString();
        } catch (InvalidPathException e) {
            return null;
        }
    }

    /**
     * This method creates a preference file with the given preferredDirectory
     * as the content of this file.
     *
     * @param preferredDirectory
     *            the preferred storage directory
     */
    public void setPreferredDirectory(String preferredDirectory) {
        FileManager.writeToFile(preferredDirectory, Constants.PATH_PREFERENCE_FILE);
    }

}
```
###### src\main\java\jfdi\storage\apis\TaskAttributes.java
``` java
package jfdi.storage.apis;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Objects;

import jfdi.storage.Constants;
import jfdi.storage.entities.Task;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

/**
 * This is the data transfer class of the Task entity.
 *
 * @author Thng Kai Yuan
 *
 */
public class TaskAttributes {

    // Attributes of a Task
    private Integer id = null;
    private String description = null;
    private LocalDateTime startDateTime = null;
    private LocalDateTime endDateTime = null;
    private boolean isCompleted = false;

    public TaskAttributes() {}

    public TaskAttributes(Task task) {
        this.id = task.getId();
        this.description = task.getDescription();
        this.startDateTime = task.getStartDateTime();
        this.endDateTime = task.getEndDateTime();
        this.isCompleted = task.isCompleted();
    }

    public Integer getId() {
        return id;
    }

    /**
     * This method should only be used internally by the database/test.
     */
    public void setId(Integer id) {
        this.id = id;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public void setStartDateTime(LocalDateTime startDateTime) {
        this.startDateTime = startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public void setEndDateTime(LocalDateTime endDateTime) {
        this.endDateTime = endDateTime;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    public void setCompleted(boolean isCompleted) {
        this.isCompleted = isCompleted;
    }

    /**
     * This method saves the attributes object into a data store object in the
     * database. The attributes are first validated before the data store object
     * is either created or updated.
     *
     * @throws InvalidTaskParametersException
     *             if the attributes object contains an invalid attribute (e.g.
     *             missing description)
     * @throws NoAttributesChangedException
     *             if the save operation does not change the data store object
     *             in any way
     * @throws InvalidIdException
     *             if the ID stored in the attributes object is invalid (e.g.
     *             null or does not exist)
     * @throws DuplicateTaskException
     *             if a similar task already exists in the database
     */
    public void save() throws InvalidTaskParametersException, NoAttributesChangedException,
            InvalidIdException, DuplicateTaskException {
        validateAttributes();
        TaskDb.getInstance().createOrUpdate(this);
    }

    /**
     * Converts the current TaskAttributes to its corresponding Task entity.
     *
     * @return the corresponding Task entity
     */
    public Task toEntity() {
        return new Task(id, description, startDateTime, endDateTime);
    }

    /**
     * This method checks if the current Task is valid.
     *
     * @return a boolean indicating if the current task is valid
     */
    public boolean isValid() {
        try {
            validateAttributes();
            return true;
        } catch (InvalidTaskParametersException e) {
            return false;
        }
    }

    /**
     * This method validates the existing TaskAttributes.
     *
     * @throws InvalidTaskParametersException
     *             if the existing TaskAttributes contains invalid parameters
     */
    private void validateAttributes() throws InvalidTaskParametersException {
        ArrayList<String> errors = new ArrayList<String>();

        if (description == null) {
            errors.add(Constants.MESSAGE_MISSING_DESCRIPTION);
        }

        if (startDateTime != null && endDateTime != null && endDateTime.isBefore(startDateTime)) {
            errors.add(Constants.MESSAGE_INVALID_DATETIME);
        }

        if (errors.size() > 0) {
            throw new InvalidTaskParametersException(errors);
        }
    }

    /**
     * This method allows one to compare a TaskAttributes with a Task.
     *
     * @param task
     *            the Task to be compared with
     * @return a boolean indicating if the existing TaskAttributes has the same
     *         attributes as the Task compared
     */
    public boolean equalTo(Task task) {
        assert task != null;
        return Objects.equals(this.id, task.getId()) && similarTo(task);
    }

    /**
     * This method allows one to compare the properties of a TaskAttributes with a Task.
     *
     * @param task
     *            the Task to be compared with
     * @return a boolean indicating if the existing TaskAttributes has the same
     *         properties (excluding ID) as the Task compared
     */
    public boolean similarTo(Task task) {
        assert task != null;
        return Objects.equals(this.description, task.getDescription())
                && Objects.equals(this.startDateTime, task.getStartDateTime())
                && Objects.equals(this.endDateTime, task.getEndDateTime())
                && this.isCompleted == task.isCompleted();
    }

}
```
###### src\main\java\jfdi\storage\apis\TaskDb.java
``` java
package jfdi.storage.apis;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.TreeMap;
import java.util.logging.Logger;

import jfdi.common.utilities.JfdiLogger;
import jfdi.storage.Constants;
import jfdi.storage.FileManager;
import jfdi.storage.IDatabase;
import jfdi.storage.entities.Task;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.FilePathPair;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import jfdi.storage.serializer.Serializer;

/**
 * This class manages the entire collection of Tasks persisted in the program.
 *
 * @author Thng Kai Yuan
 *
 */
public class TaskDb implements IDatabase {

    // Singleton instance of TaskDb
    private static TaskDb instance = null;

    // All persisted Tasks
    private TreeMap<Integer, Task> taskList = null;

    // All deleted Tasks
    private TreeMap<Integer, Task> deletedTaskList = null;

    // The ID that will be assigned to the next new task
    private int nextId = 1;

    // The file path to the data file
    private Path filePath = null;

    // Logger for events
    private Logger logger = null;

    /**
     * This private constructor prevents more instances of TaskDb from being
     * created.
     */
    private TaskDb() {
        logger = JfdiLogger.getLogger();
        reset();
    }

    /**
     * This method returns the singleton instance of TaskDb.
     *
     * @return the singleton instance of TaskDb
     */
    public static TaskDb getInstance() {
        if (instance == null) {
            instance = new TaskDb();
        }
        return instance;
    }

    /**
     * This method persists the taskAttributes object either by creating the
     * relevant Task or updating the existing Task.
     *
     * @param taskAttributes
     *            the object containing the desired attributes of the task
     * @throws NoAttributesChangedException
     *             if the operation does not change any existing attributes
     * @throws InvalidIdException
     *             if the ID contained in the taskAttributes does not exist
     * @throws DuplicateTaskException
     *             if a task with the same attributes already exist
     */
    public void createOrUpdate(TaskAttributes taskAttributes) throws NoAttributesChangedException,
            InvalidIdException, DuplicateTaskException {
        assert taskAttributes != null;
        validateIsNotDuplicateTask(taskAttributes);
        Integer taskId = taskAttributes.getId();
        if (taskId != null) {
            update(taskAttributes);
        } else {
            create(taskAttributes);
        }
    }

    /**
     * This method validates that the given task attributes do not already exist
     * in the database. A TaskAttributes is not considered a duplicate if the
     * matching task is itself.
     *
     * @param taskAttributes
     *            the task attributes to be validated against existing tasks
     * @throws DuplicateTaskException
     *             if a task with similar attributes already exist in the
     *             database
     */
    private void validateIsNotDuplicateTask(TaskAttributes taskAttributes) throws DuplicateTaskException {
        if (taskList.values().stream()
                .anyMatch(task -> taskAttributes.similarTo(task) && !taskAttributes.equalTo(task))) {
            throw new DuplicateTaskException(taskAttributes);
        }
    }

    /**
     * This method creates a new Task from the given taskAttribute and persists
     * it to disk.
     *
     * @param taskAttributes
     *            the object containing the desired attributes of the task
     */
    private void create(TaskAttributes taskAttributes) {
        assert taskAttributes.getId() == null;
        Task task = taskAttributes.toEntity();
        task.setId(nextId++);
        taskAttributes.setId(task.getId());
        taskList.put(task.getId(), task);
        persist();
        logger.fine(String.format(Constants.MESSAGE_LOG_CREATE_TASK, task.getId()));
    }

    /**
     * This method updates an existing Task object from its attributes object
     * and persists the updated Task to disk.
     *
     * @param taskAttributes
     *            the attributes object of the task
     * @throws NoAttributesChangedException
     *             if the taskAttributes object does not change the
     *             corresponding task
     * @throws InvalidIdException
     *             if the ID in taskAttributes does not exist
     */
    private void update(TaskAttributes taskAttributes) throws NoAttributesChangedException,
            InvalidIdException {
        assert taskAttributes != null;
        Task task = getTaskById(taskAttributes.getId());
        assert task != null;
        validateAttributesHasChanged(taskAttributes, task);
        task.update(taskAttributes);
        persist();
        logger.fine(String.format(Constants.MESSAGE_LOG_UPDATE_TASK, task.getId()));
    }

    /**
     * This method validates that the given taskAttributes object has attributes
     * different from its corresponding Task in the database.
     *
     * @param taskAttributes
     *            the taskAttributes which have been changed
     * @param task
     *            the task that taskAttributes is to be compared with
     * @throws NoAttributesChangedException
     *             if no attributes have been changed
     */
    private void validateAttributesHasChanged(TaskAttributes taskAttributes, Task task)
            throws NoAttributesChangedException {
        assert taskAttributes != null && task != null;
        if (taskAttributes.equalTo(task)) {
            throw new NoAttributesChangedException();
        }
    }

    /**
     * This method returns all the tasks (as a collection of their attributes)
     * currently persisted to Storage.
     *
     * @return a Collection of TaskAttributes
     */
    public Collection<TaskAttributes> getAll() {
        assert taskList != null;
        ArrayList<TaskAttributes> taskAttributes = new ArrayList<TaskAttributes>();
        for (Task task : taskList.values()) {
            taskAttributes.add(new TaskAttributes(task));
        }
        return taskAttributes;
    }

    /**
     * This method returns the TaskAttribute object of the task specified by the
     * ID.
     *
     * @param id
     *            the auto-assigned ID of each persisted Task
     * @return a TaskAttribute if the Task exists in Storage, null otherwise
     * @throws InvalidIdException
     *             if the given id does not exist in the database
     */
    public TaskAttributes getById(Integer id) throws InvalidIdException {
        assert id != null;
        Task task = getTaskById(id);
        return new TaskAttributes(task);
    }

    /**
     * This method returns the Task specified by its id, or null if the id is
     * invalid or the Task does not exist.
     *
     * @param id
     *            the ID of the task to be found
     * @return the Task object if the id is valid and the Task exists
     * @throws InvalidIdException
     *             if the given id does not exist in the database
     */
    private Task getTaskById(Integer id) throws InvalidIdException {
        assert id != null;
        if (taskList.get(id) == null) {
            throw new InvalidIdException(id);
        }
        return taskList.get(id);
    }

    /**
     * This method checks if a task (given by its ID) exists in the database.
     *
     * @param id
     *            the ID of the task to be checked
     * @return boolean indicating if the task exists in the database
     */
    public boolean hasId(int id) {
        return taskList.containsKey(id);
    }

    /**
     * This method marks a task (given by its ID) as completed.
     *
     * @param id
     *            id of the task to be marked
     * @throws NoAttributesChangedException
     *             if no attributes have been changed
     * @throws InvalidIdException
     *             if the given id is invalid
     */
    public void markAsComplete(Integer id) throws NoAttributesChangedException, InvalidIdException {
        assert id != null;
        TaskAttributes taskAttributes = getById(id);
        taskAttributes.setCompleted(true);
        update(taskAttributes);
    }

    /**
     * This method marks a task (given by its ID) as incomplete.
     *
     * @param id
     *            id of the task to be marked
     * @throws NoAttributesChangedException
     *             if no attributes have been changed
     * @throws InvalidIdException
     *             if the given id is invalid
     */
    public void markAsIncomplete(Integer id) throws NoAttributesChangedException, InvalidIdException {
        assert id != null;
        TaskAttributes taskAttributes = getById(id);
        taskAttributes.setCompleted(false);
        update(taskAttributes);
    }

    /**
     * This method soft-deletes the task given by the ID.
     *
     * @param id
     *            the task to be deleted
     * @throws InvalidIdException
     *             if the given id does not exist in the database
     */
    public void destroy(Integer id) throws InvalidIdException {
        assert id != null;
        Task task = getTaskById(id);
        assert task != null;
        softDelete(id);
        persist();
        logger.fine(String.format(Constants.MESSAGE_LOG_DELETE_TASK, id));
    }

    /**
     * This method transfers a task from the task list to the deleted task list.
     *
     * @param id
     *            the ID of the task that is to be moved
     */
    private void softDelete(Integer id) {
        assert id != null;
        Task task = taskList.remove(id);
        deletedTaskList.put(task.getId(), task);
    }

    /**
     * This method recovers the task given by the ID.
     *
     * @param id
     *            the task to be recovered
     * @throws InvalidIdException
     *             if the specified ID does not exist in the deleted list
     * @throws DuplicateTaskException
     *             if a task with similar attributes already exists in the database
     */
    public void undestroy(Integer id) throws InvalidIdException, DuplicateTaskException {
        assert id != null;
        if (!deletedTaskList.containsKey(id)) {
            throw new InvalidIdException(id);
        }
        undelete(id);
        persist();
        logger.fine(String.format(Constants.MESSAGE_LOG_RECOVER_TASK, id));
    }

    /**
     * This method transfers a task from the deleted task list to the task list.
     *
     * @param id
     *            the ID of the task that is to be moved
     * @throws DuplicateTaskException
     *             if a task with similar attributes already exists in the database
     */
    private void undelete(Integer id) throws DuplicateTaskException {
        assert id != null;
        TaskAttributes taskAttributes = new TaskAttributes(deletedTaskList.get(id));
        validateIsNotDuplicateTask(taskAttributes);
        Task task = deletedTaskList.remove(id);
        taskList.put(task.getId(), task);
    }

    /**
     * This method persists all existing tasks to the file system.
     */
    public void persist() {
        String json = Serializer.serialize(taskList.values());
        FileManager.writeToFile(json, filePath);
    }

    /**
     * This method resets the program's internal storage of tasks. This method
     * should only be used by the public in tests.
     */
    public void reset() {
        taskList = new TreeMap<Integer, Task>();
        deletedTaskList = new TreeMap<Integer, Task>();
        nextId = 1;
    }

    /**
     * This method sets the filepath of the record using absoluteFolderPath to
     * store the record's data file.
     *
     * @param absoluteFolderPath
     *            the directory that should contain the data file
     */
    public void setFilePath(String absoluteFolderPath) {
        assert absoluteFolderPath != null;
        filePath = Paths.get(absoluteFolderPath, Constants.FILENAME_TASK);
    }

    /**
     * @return the path of the record as set using the setFilePath method
     */
    public Path getFilePath() {
        return filePath;
    }

    /**
     * This method loads/refreshes the record (taskList) based on data contained
     * within the data file of the record.
     *
     * @return FilePathPair if a file was replaced, null otherwise
     */
    public FilePathPair load() {
        if (!Files.exists(filePath)) {
            return null;
        }

        String persistedJsonData = FileManager.readFileToString(filePath);
        Task[] taskArray = Serializer.deserialize(persistedJsonData, Task[].class);
        taskArray = validateTaskArray(taskArray);

        if (taskArray == null) {
            String movedTo = FileManager.backupAndRemove(filePath);
            return new FilePathPair(filePath.toString(), movedTo);
        } else if (taskArray.length > 0) {
            populateTaskList(taskArray);
            nextId = taskList.lastKey() + 1;
        }
        return null;
    }

    /**
     * This method validates an entire array of tasks. If any of the tasks
     * within are invalid, null is returned. Otherwise, the original array is
     * returned.
     *
     * @param taskArray
     *            the array that is to be validated
     * @return taskArray if the entire array of tasks are valid, null otherwise
     */
    private Task[] validateTaskArray(Task[] taskArray) {
        if (taskArray == null) {
            return null;
        }

        for (Task task : taskArray) {
            if (!(new TaskAttributes(task).isValid())) {
                return null;
            }
        }
        return taskArray;
    }

    /**
     * This method populates the task list with tasks given in the taskArray.
     *
     * @param taskArray
     *            the array of tasks that we want to populate the program with
     */
    private void populateTaskList(Task[] taskArray) {
        assert taskArray != null;
        reset();
        for (Task task : taskArray) {
            task.setId(nextId++);
            taskList.put(task.getId(), task);
        }
    }

}
```
###### src\main\java\jfdi\storage\Constants.java
``` java
package jfdi.storage;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;

import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.TaskDb;

/**
 * This class file contains all the constants used within the Storage component.
 *
 * @author Thng Kai Yuan
 */
public class Constants {

    /**
     * General purpose constants
     */
    // Database filenames
    public static final String FILENAME_TASK = "tasks.txt";
    public static final String FILENAME_ALIAS = "aliases.txt";
    public static final String[] FILENAME_DATA_ARRAY = {Constants.FILENAME_TASK, Constants.FILENAME_ALIAS};

    // Last used directory filenames and paths
    public static final String FILENAME_DIRECTORY = "directory.txt";
    public static final String FILENAME_DATA_DIRECTORY = ".jfdi_user_data";
    public static final String PATH_DEFAULT_DIRECTORY = ".";
    public static final Path PATH_PREFERENCE_FILE = Paths.get(PATH_DEFAULT_DIRECTORY,
            FILENAME_DATA_DIRECTORY, FILENAME_DIRECTORY);

    // Logging filename and path
    public static final String FILENAME_LOG = "log.txt";
    public static final String FILENAME_LOG_DIRECTORY = ".jfdi_logs";
    public static final Path PATH_LOG_FILE = Paths.get(PATH_DEFAULT_DIRECTORY, FILENAME_LOG_DIRECTORY, FILENAME_LOG);

    // File extensions
    public static final String EXTENSION_BACKUP = ".bak";

    // Empty stuff
    public static final String EMPTY_STRING = "";
    public static final String EMPTY_LIST_STRING = "[]";

    // Error messages
    public static final String MESSAGE_INVALID_PATH = "The directory %s cannot be used to store the program data.";
    public static final String MESSAGE_MISSING_DESCRIPTION = "This task is missing a description.";
    public static final String MESSAGE_INVALID_DATETIME = "Start date and time cannot be after end date and time.";

    // Logging messages
    public static final String MESSAGE_LOG_SET_DIRECTORY = "Storage directory has been set to '%s'.";
    public static final String MESSAGE_LOG_CREATE_TASK = "A new task with ID %d was created.";
    public static final String MESSAGE_LOG_UPDATE_TASK = "Task #%d was updated.";
    public static final String MESSAGE_LOG_DELETE_TASK = "Task #%d was deleted.";
    public static final String MESSAGE_LOG_RECOVER_TASK = "Task #%d was recovered.";

    // Default charset
    public static final String CHARSET = "UTF-8";

    // All database instances
    public static final IDatabase[] DATABASES = {TaskDb.getInstance(), AliasDb.getInstance()};


    /**
     * Test-specific constants
     */
    // Files
    public static final String TEST_DIRECTORY_PREFIX = "CS2103-JFDI";
    public static final String TEST_DIRECTORY_NAME = "Data";
    public static final String TEST_SUBDIRECTORY_NAME = "Data2";
    public static final String TEST_FILE_NAME = "test.txt";
    public static final String TEST_FILE_DATA = "hello world!";

    // Aliases
    public static final String TEST_ALIAS = "somealias";
    public static final String TEST_COMMAND = "somecommand";
    public static final String TEST_ALIAS_2 = "somealias2";
    public static final String TEST_COMMAND_2 = "somecommand2";
    public static final String TEST_COMMAND_REGEX = "(?i)^(" + TEST_COMMAND + ")|"
            + "(?i)^(" + TEST_COMMAND_2 + ")";

    // Tasks
    public static final String TEST_TASK_DESCRIPTION_1 = "my favourite description";
    public static final String TEST_TASK_DESCRIPTION_2 = "my favourite description too";
    public static final LocalDateTime TEST_TASK_STARTDATETIME = LocalDateTime.MIN;
    public static final LocalDateTime TEST_TASK_ENDDATETIME = LocalDateTime.MAX;

}
```
###### src\main\java\jfdi\storage\DatabaseManager.java
``` java
package jfdi.storage;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;

import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.FilePathPair;

/**
 * This class manages all the databases in the Storage component.
 *
 * @author Thng Kai Yuan
 */
public class DatabaseManager {

    /*
     * Public APIs
     */

    /**
     * This method sets the file path of each database accordingly, using
     * storageFolderPath as the root directory of all data.
     *
     * @param storageFolderPath
     *            the root directory where all data will be stored
     */
    public static void setAllFilePaths(String storageFolderPath) {
        assert storageFolderPath != null;
        for (IDatabase database : Constants.DATABASES) {
            database.setFilePath(storageFolderPath);
        }
    }

    /**
     * This method persists all databases to disk.
     */
    public static void persistAll() {
        Arrays.stream(Constants.DATABASES).forEach(IDatabase::persist);
    }

    /**
     * This method loads/refreshes all databases based on data contained within
     * the data file defined by the file path of each record.
     *
     * @throws FilesReplacedException
     *             if unrecognized files were moved
     */
    public static void loadAllDatabases() throws FilesReplacedException {
        ArrayList<FilePathPair> movedFiles = new ArrayList<FilePathPair>();
        Arrays.stream(Constants.DATABASES)
            .map(IDatabase::load)
            .filter(Objects::nonNull)
            .forEach(movedFiles::add);

        if (!movedFiles.isEmpty()) {
            throw new FilesReplacedException(movedFiles);
        }
    }

    /**
     * This method returns an ArrayList of Paths to each data file.
     *
     * @return an ArrayList of Paths where the existing data for each database
     *         is stored
     */
    public static ArrayList<Path> getAllFilePaths() {
        ArrayList<Path> filePaths = new ArrayList<Path>();
        Arrays.stream(Constants.DATABASES)
            .map(IDatabase::getFilePath)
            .forEach(filePaths::add);

        return filePaths;
    }

    /**
     * This method resets all databases.
     */
    public static void resetAll() {
        Arrays.stream(Constants.DATABASES).forEach(IDatabase::reset);
    }

}
```
###### src\main\java\jfdi\storage\entities\Alias.java
``` java
package jfdi.storage.entities;

/**
 * This is the Alias entity class.
 *
 * @author Thng Kai Yuan
 *
 */
public class Alias {

    private String alias;
    private String command;

    public Alias(String alias, String command) {
        this.alias = alias;
        this.command = command;
    }

    public String getAlias() {
        return alias;
    }

    public String getCommand() {
        return command;
    }
}
```
###### src\main\java\jfdi\storage\entities\Task.java
``` java
package jfdi.storage.entities;

import java.time.LocalDateTime;

import jfdi.storage.apis.TaskAttributes;

/**
 * This is the Task entity class.
 *
 * @author Thng Kai Yuan
 *
 */
public class Task {

    private Integer id = null;
    private String description = null;
    private LocalDateTime startDateTime = null;
    private LocalDateTime endDateTime = null;
    private boolean isCompleted = false;

    public Task(Integer id, String description, LocalDateTime startDateTime, LocalDateTime endDateTime) {
        this.id = id;
        this.description = description;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getDescription() {
        return description;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * This method copies the attributes from taskAttributes onto itself.
     *
     * @param taskAttributes
     *            the data transfer object that we want to copy the attributes from
     */
    public void update(TaskAttributes taskAttributes) {
        assert this.getId() == taskAttributes.getId();
        this.description = taskAttributes.getDescription();
        this.startDateTime = taskAttributes.getStartDateTime();
        this.endDateTime = taskAttributes.getEndDateTime();
        this.isCompleted = taskAttributes.isCompleted();
    }
}
```
###### src\main\java\jfdi\storage\exceptions\DuplicateAliasException.java
``` java
package jfdi.storage.exceptions;

import jfdi.storage.apis.AliasAttributes;

@SuppressWarnings("serial")
public class DuplicateAliasException extends Exception {

    private String alias = null;
    private String command = null;

    public DuplicateAliasException(AliasAttributes aliasAttributes) {
        this.alias = aliasAttributes.getAlias();
        this.command = aliasAttributes.getCommand();
    }

    public String getAlias() {
        return alias;
    }

    public String getCommand() {
        return command;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\DuplicateTaskException.java
``` java
package jfdi.storage.exceptions;

import jfdi.storage.apis.TaskAttributes;

@SuppressWarnings("serial")
public class DuplicateTaskException extends Exception {

    private TaskAttributes duplicateTaskAttributes = null;

    public DuplicateTaskException(TaskAttributes taskAttributes) {
        duplicateTaskAttributes = taskAttributes;
    }

    /**
     * @return the duplicate task attributes
     */
    public TaskAttributes getDuplicateTaskAttributes() {
        return duplicateTaskAttributes;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\FilePathPair.java
``` java
package jfdi.storage.exceptions;

/**
 * FilePathPair maps the original filepath of a file to the new filepath of the
 * file after it has been moved.
 *
 * @author Thng Kai Yuan
 *
 */
public class FilePathPair {

    private String oldFilePath = null;
    private String newFilePath = null;

    public FilePathPair(String oldFilePath, String newFilePath) {
        this.oldFilePath = oldFilePath;
        this.newFilePath = newFilePath;
    }

    public String getOldFilePath() {
        return oldFilePath;
    }

    public String getNewFilePath() {
        return newFilePath;
    }
}
```
###### src\main\java\jfdi\storage\exceptions\FilesReplacedException.java
``` java
package jfdi.storage.exceptions;

import java.util.ArrayList;

/**
 * ExistingFilesFoundException is thrown when files are replaced with backups
 * made. The exception would contain an ArrayList of FilePathPairs that map
 * the replaced files to the location of their backups.
 *
 * @author Thng Kai Yuan
 */
@SuppressWarnings("serial")
public class FilesReplacedException extends Exception {

    private ArrayList<FilePathPair> replacedFilePairs = null;

    public FilesReplacedException(ArrayList<FilePathPair> replacedFilePairs) {
        this.replacedFilePairs = replacedFilePairs;
    }

    public ArrayList<FilePathPair> getReplacedFilePairs() {
        return replacedFilePairs;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\InvalidAliasException.java
``` java
package jfdi.storage.exceptions;

@SuppressWarnings("serial")
public class InvalidAliasException extends Exception {

    private String alias = null;

    public InvalidAliasException(String alias) {
        this.alias = alias;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\InvalidAliasParametersException.java
``` java
package jfdi.storage.exceptions;

import jfdi.storage.apis.AliasAttributes;

@SuppressWarnings("serial")
public class InvalidAliasParametersException extends Exception {

    private String alias = null;
    private String command = null;

    public InvalidAliasParametersException(AliasAttributes aliasAttributes) {
        this.alias = aliasAttributes.getAlias();
        this.command = aliasAttributes.getCommand();
    }

    public String getAlias() {
        return alias;
    }

    public String getCommand() {
        return command;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\InvalidFilePathException.java
``` java
package jfdi.storage.exceptions;

@SuppressWarnings("serial")
public class InvalidFilePathException extends Exception {

    private String path = null;

    public InvalidFilePathException(String path, String message) {
        super(message);
        this.path = path;
    }

    /**
     * @return the path
     */
    public String getPath() {
        return path;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\InvalidIdException.java
``` java
package jfdi.storage.exceptions;

@SuppressWarnings("serial")
public class InvalidIdException extends Exception {

    private Integer invalidId = null;

    public InvalidIdException(Integer id) {
        this.invalidId = id;
    }

    public Integer getInvalidId() {
        return invalidId;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\InvalidTaskParametersException.java
``` java
package jfdi.storage.exceptions;

import java.util.ArrayList;

@SuppressWarnings("serial")
public class InvalidTaskParametersException extends Exception {

    private ArrayList<String> errorList;

    public InvalidTaskParametersException(ArrayList<String> errors) {
        errorList = errors;
    }

    /**
     * @return the ArrayList of error messages
     */
    public ArrayList<String> getErrorList() {
        return errorList;
    }

}
```
###### src\main\java\jfdi\storage\exceptions\NoAttributesChangedException.java
``` java
package jfdi.storage.exceptions;

@SuppressWarnings("serial")
public class NoAttributesChangedException extends Exception {

}
```
###### src\main\java\jfdi\storage\FileManager.java
``` java
package jfdi.storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;

import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.FilePathPair;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * This class manages file operations required by Storage.
 *
 * @author Thng Kai Yuan
 */
public class FileManager {

    /*
     * Public APIs
     */

    /**
     * This method creates the necessary directories for files to be stored in
     * storageFolderPath. If there are issues creating the directory or if there
     * is insufficient permission to carry out normal file operations in the
     * directory, then an InvalidFilePathException is thrown.
     *
     * @param storageFolderPath
     *            the root directory of the data files
     * @throws InvalidFilePathException
     *             if there are errors creating the directory or if there is
     *             insufficient permission to carry out normal file operations
     *             in the directory
     */
    public static void prepareDirectory(String storageFolderPath) throws InvalidFilePathException {
        assert storageFolderPath != null;
        Path directoryPath = Paths.get(storageFolderPath);
        boolean isValidDirectory = true;

        // Attempt to create/load the storage directory with the right permissions
        try {
            directoryPath = Files.createDirectories(directoryPath);
            File directory = directoryPath.toFile();
            if (!canUseDirectory(directory)) {
                isValidDirectory = false;
            }
        } catch (IOException e) {
            isValidDirectory = false;
        }

        if (!isValidDirectory) {
            String errorMessage = String.format(Constants.MESSAGE_INVALID_PATH, storageFolderPath);
            throw new InvalidFilePathException(storageFolderPath, errorMessage);
        }
    }

    /**
     * This method moves all the existing data files to newStorageFolderPath.
     *
     * @param newStorageFolderPath
     *            the new storage directory
     * @throws FilesReplacedException
     *             if files in the new directory were replaced (with backups
     *             made)
     */
    public static void moveFilesToDirectory(String newStorageFolderPath) throws FilesReplacedException {
        assert newStorageFolderPath != null;
        // Create the new folder if it doesn't already exist
        File newStorageFolder = new File(newStorageFolderPath);
        newStorageFolder.mkdirs();

        // Get the paths of all data file and move them
        ArrayList<Path> filePaths = DatabaseManager.getAllFilePaths();
        ArrayList<FilePathPair> replacedFiles = moveFilesTo(filePaths, newStorageFolderPath);

        // Let the caller know if files were replaced
        if (!replacedFiles.isEmpty()) {
            throw new FilesReplacedException(replacedFiles);
        }
    }

    /**
     * This method makes a backup of the file at sourcePath before removing it.
     * The absolute path of the backup file made is returned.
     *
     * @param sourcePath
     *            the path of the original file
     * @return the path of the backup file created
     */
    public static String backupAndRemove(Path sourcePath) {
        assert sourcePath != null;
        String sourceDirectoryPath = sourcePath.getParent().toString();
        String originalFilename = sourcePath.getFileName().toString();
        Path destinationPath = getUnusedBackupPath(sourceDirectoryPath, originalFilename);

        try {
            Files.move(sourcePath, destinationPath);
        } catch (IOException e) {
            e.printStackTrace();
        }

        return destinationPath.toAbsolutePath().toString();
    }

    /**
     * This method is used to write data into the file given at filePath.
     *
     * @param data
     *            the data to be written into the specified file
     * @param filePath
     *            the path of the file that we want to write data into
     */
    public static void writeToFile(String data, Path filePath) {
        assert data != null && filePath != null;
        try {
            File file = filePath.toFile();
            file.getParentFile().mkdirs();
            PrintWriter writer = new PrintWriter(file, Constants.CHARSET);
            writer.println(data);
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method reads the content in the file specified by filePath and
     * returns the content in a String.
     *
     * @param filePath
     *            the path of the file that we want to read
     * @return a String of the file content, or an empty string if there was an
     *         error reading the file
     */
    public static String readFileToString(Path filePath) {
        assert filePath != null;
        try {
            File file = filePath.toFile();
            Scanner scanner = new Scanner(file, Constants.CHARSET);
            scanner.useDelimiter("\\Z");
            String data = scanner.next();
            scanner.close();
            return data;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return Constants.EMPTY_STRING;
        }
    }


    /*
     * Private helper methods
     */

    /**
     * This method returns a suitable backup path for the given file in the
     * given directory.
     *
     * @param directory
     *            the directory which contains the original file
     * @param originalFilename
     *            the filename of the original file
     * @return the path to a suitable (unused) backup file
     */
    private static Path getUnusedBackupPath(String directory, String originalFilename) {
        assert directory != null && originalFilename != null;
        String destinationFilename = null;
        Path destinationPath = null;
        int attempts = 0;

        // Try a different backup filename until we get one that doesn't yet exist
        do {
            destinationFilename = originalFilename + getBackupExtension(attempts++);
            destinationPath = Paths.get(directory, destinationFilename);
        } while (Files.exists(destinationPath));

        return destinationPath;
    }

    /**
     * This method moves all existing files in filePaths to the destination folder.
     *
     * @param filePaths
     *            an ArrayList of Paths for the files that are to be moved
     * @param destination
     *            the destination directory
     * @return an ArrayList of FilePathPairs for every file that was moved in
     *         the destination directory
     */
    private static ArrayList<FilePathPair> moveFilesTo(ArrayList<Path> filePaths, String destination) {
        assert filePaths != null && destination != null;
        ArrayList<FilePathPair> movedFiles = new ArrayList<FilePathPair>();

        // For each file path that exists, we backup the file and add it to the list of moved files
        filePaths.stream().filter(Files::exists).map(sourcePath -> {
            String filename = sourcePath.getFileName().toString();
            Path destinationPath = Paths.get(destination, filename);
            return moveAndBackup(sourcePath, destinationPath);
        }).filter(Objects::nonNull).forEach(movedFiles::add);

        return movedFiles;
    }

    /**
     * This method moves the file at the given source to the given destination.
     * If a file already exists at destination, a backup file of the destination
     * is made before it is replaced.
     *
     * @param source
     *            the path of the source file
     * @param destination
     *            the path of the destination file
     * @return FilePathPair if a backup was made, null otherwise
     */
    private static FilePathPair moveAndBackup(Path source, Path destination) {
        assert source != null && destination != null;
        FilePathPair filePathPair = null;

        if (Files.exists(destination)) {
            String movedTo = backupAndRemove(destination);
            filePathPair = new FilePathPair(source.toString(), movedTo);
        }

        try {
            Files.move(source, destination);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return filePathPair;
    }

    /**
     * This method returns the constant backup file extension concatenated with
     * the given integer i if i != 0. Examples of extensions generated: .bak,
     * .bak1, .bak2, etc.
     *
     * @param i
     *            the number that will be appended to the back of the extension
     * @return a backup file extension
     */
    private static String getBackupExtension(int i) {
        assert i >= 0;
        if (i == 0) {
            return Constants.EXTENSION_BACKUP;
        }

        return Constants.EXTENSION_BACKUP + String.valueOf(i);
    }

    /**
     * This method checks if the program has sufficient permissions to perform
     * certain file operations within the given directory.
     *
     * @param directory
     *            the root directory which files are to be stored in
     * @return a boolean indicating if the directory can be used for operations
     *         required by the program
     */
    private static boolean canUseDirectory(File directory) {
        assert directory != null;
        return directory.canExecute() && directory.canWrite();
    }

}
```
###### src\main\java\jfdi\storage\IDatabase.java
``` java
package jfdi.storage;

import java.nio.file.Path;

import jfdi.storage.exceptions.FilePathPair;

/**
 * This interface defines the methods that an entity database should implement
 * in order for the database to be managed by DatabaseManager appropriately.
 *
 * @author Thng Kai Yuan
 *
 */
public interface IDatabase {

    /**
     * This method loads the data currently stored on disk at the location given
     * by filePath.
     *
     * @return a FilePathPair if the existing file cannot be read and was
     *         renamed
     */
    FilePathPair load();

    /**
     * This method persists all existing data to the file system.
     */
    void persist();

    /**
     * @return the path of the folder storing the database file
     */
    Path getFilePath();

    /**
     * This method sets the path of the folder used to store the database file.
     *
     * @param absoluteFolderPath
     *            the directory that should contain the database file
     */
    void setFilePath(String path);

    /**
     * Resets the database.
     */
    void reset();

}
```
###### src\main\java\jfdi\storage\serializer\Serializer.java
``` java
package jfdi.storage.serializer;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;

/**
 * This is the Serializer used by the Storage component. It is extracted into a
 * class by itself to allow for global extensions and modifications.
 *
 * @author Thng Kai Yuan
 *
 */
public class Serializer {

    private static Gson gson = null;

    /**
     * The static constructor. We can configure the settings for the GSON
     * builder here.
     */
    static {
        if (gson == null) {
            gson = new GsonBuilder().setPrettyPrinting().create();
        }
    }

    /**
     * Turns an object into its JSON form.
     *
     * @param source
     *            the object that we want to serialize
     * @return the serialized string of the object
     */
    public static String serialize(Object source) {
        return gson.toJson(source);
    }

    /**
     * Transforms a JSON string into the object that it represents.
     *
     * @param persistedJsonData
     *            the JSON string
     * @param classOfT
     *            the class of the object that the JSON string represents
     * @return the deserialized object
     */
    public static <T> T deserialize(String persistedJsonData, Class<T> classOfT) {
        try {
            T resultantObject = gson.fromJson(persistedJsonData, classOfT);
            return resultantObject;
        } catch (JsonSyntaxException e) {
            return null;
        }
    }

}
```
###### src\test\java\dummytests\DummyTest.java
``` java
package dummytests;

import static org.junit.Assert.assertTrue;
import org.junit.Test;

import dummy.Dummy;

/**
 * DummyTest checks whether the test utility works
 *
 * @author Kai Yuan
 */
public class DummyTest {

    /**
     * Test whether the dummy exists
     */
    @Test
    public void testDummy() {
        Dummy myDummy = new Dummy();
        assertTrue(myDummy.isPresent());
    }

}
```
###### src\test\java\jfdi\test\storage\AliasAttributesTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.*;

import java.nio.file.Files;
import java.nio.file.Path;

import jfdi.storage.Constants;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.entities.Alias;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

import org.junit.After;
import org.junit.BeforeClass;
import org.junit.Test;

public class AliasAttributesTest {

    private static Path testDirectory = null;
    private static AliasDb aliasDbInstance = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectory = Files.createTempDirectory(Constants.TEST_DIRECTORY_NAME);
        aliasDbInstance = AliasDb.getInstance();
        AliasAttributes.setCommandRegex(Constants.TEST_COMMAND_REGEX);
        MainStorage.getInstance().load(testDirectory.toString());
    }

    @After
    public void tearDown() throws Exception {
        aliasDbInstance.reset();
    }

    @Test
    public void testConstructorsAndGetters() {
        // Test the first constructor (i.e. AliasAttributes(Alias))
        Alias alias = new Alias(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        AliasAttributes aliasAttributes = new AliasAttributes(alias);
        assertEquals(alias.getAlias(), aliasAttributes.getAlias());
        assertEquals(alias.getCommand(), aliasAttributes.getCommand());

        // Test the second constructor (i.e. AliasAttributes(alias, command))
        AliasAttributes aliasAttributes2 = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        assertEquals(Constants.TEST_ALIAS, aliasAttributes2.getAlias());
        assertEquals(Constants.TEST_COMMAND, aliasAttributes2.getCommand());
    }

    @Test(expected = AssertionError.class)
    public void testNullAliasInConstructor() throws Exception {
        // The AliasAttributes constructor should reject any null arguments
        new AliasAttributes(null, Constants.TEST_COMMAND);
    }

    @Test(expected = AssertionError.class)
    public void testNullCommandInConstructor() throws Exception {
        // The AliasAttributes constructor should reject any null arguments
        new AliasAttributes(Constants.TEST_ALIAS, null);
    }

    @Test(expected = InvalidAliasParametersException.class)
    public void testInvalidAliasSave() throws Exception {
        // Create an AliasAttributes with an invalid alias (the alias should not be a command)
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_COMMAND, Constants.TEST_COMMAND_2);
        aliasAttributes.save();
    }

    @Test(expected = InvalidAliasParametersException.class)
    public void testInvalidCommandSave() throws Exception {
        // Create an AliasAttributes with an invalid aliased command
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_ALIAS);
        aliasAttributes.save();
    }

    @Test(expected = DuplicateAliasException.class)
    public void testDuplicateSave() throws Exception {
        // Create an AliasAttributes and perform the first save
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasAttributes.save();

        // Duplicate save should throw an exception
        aliasAttributes.save();
    }

    @Test
    public void testSave() throws Exception {
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);

        // Make sure that the database is empty before save
        assertTrue(aliasDbInstance.getAll().isEmpty());

        // Command under test
        aliasAttributes.save();

        // Check that the alias has been persisted
        assertEquals(1, aliasDbInstance.getAll().size());
        assertEquals(Constants.TEST_COMMAND, aliasDbInstance.getCommandFromAlias(Constants.TEST_ALIAS));
    }

    @Test
    public void testToEntity() {
        // Create an AliasAttributes and turn it into an Alias entity
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        Alias alias = aliasAttributes.toEntity();

        // Assert that the attributes remain the same
        assertEquals(aliasAttributes.getAlias(), alias.getAlias());
        assertEquals(aliasAttributes.getCommand(), alias.getCommand());
    }

}
```
###### src\test\java\jfdi\test\storage\AliasDbTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.*;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import jfdi.storage.Constants;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.FilePathPair;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.serializer.Serializer;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

public class AliasDbTest {

    private static Path testDirectory = null;
    private static String testDirectoryString = null;
    private static AliasDb aliasDbInstance = null;
    private static MainStorage mainStorageInstance = null;
    private static String originalPreference = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectory = Files.createTempDirectory(Constants.TEST_DIRECTORY_NAME);
        testDirectoryString = testDirectory.toString();
        aliasDbInstance = AliasDb.getInstance();
        AliasAttributes.setCommandRegex(Constants.TEST_COMMAND_REGEX);
        mainStorageInstance = MainStorage.getInstance();
        originalPreference = mainStorageInstance.getPreferredDirectory();
        mainStorageInstance.setPreferredDirectory(testDirectoryString);
        mainStorageInstance.initialize();
        mainStorageInstance.use(testDirectoryString);
    }

    @AfterClass
    public static void tearDownAfterClass() {
        TestHelper.revertOriginalPreference(mainStorageInstance, originalPreference);
    }

    @After
    public void tearDown() throws Exception {
        aliasDbInstance.reset();
    }

    @Test
    public void testCreate() throws Exception {
        // Create an Alias from an AliasAttributes
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasDbInstance.create(aliasAttributes);

        // Assert that the properties remain the same
        assertEquals(aliasAttributes.getCommand(), aliasDbInstance.getCommandFromAlias(aliasAttributes.getAlias()));
    }

    @Test(expected = DuplicateAliasException.class)
    public void testCreateDuplicateAlias() throws Exception {
        // Create the first instance of the Alias
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasDbInstance.create(aliasAttributes);

        // This duplicate create triggers the exception
        aliasDbInstance.create(aliasAttributes);
    }

    @Test
    public void testGetAll() throws Exception {
        // Create 2 aliases
        assertTrue(aliasDbInstance.getAll().isEmpty());
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        AliasAttributes aliasAttributes2 = new AliasAttributes(Constants.TEST_ALIAS_2,
                Constants.TEST_COMMAND_2);
        aliasAttributes.save();
        aliasAttributes2.save();

        // Make sure that the database contains exactly these 2 aliases
        ArrayList<AliasAttributes> aliasAttributesList = new ArrayList<AliasAttributes>(
                aliasDbInstance.getAll());
        assertEquals(2, aliasAttributesList.size());
        assertTrue(contains(aliasAttributesList, aliasAttributes));
        assertTrue(contains(aliasAttributesList, aliasAttributes2));
    }

    @Test
    public void testHasAlias() throws Exception {
        // No aliases exist yet, so checking any alias should return false
        assertFalse(aliasDbInstance.hasAlias(Constants.TEST_ALIAS));

        // Create an alias
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasAttributes.save();

        // Check that aliasDbInstance has that alias
        assertTrue(aliasDbInstance.hasAlias(Constants.TEST_ALIAS));
    }

    @Test
    public void testDestroyAndUndestroy() throws Exception {
        // Create an alias
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasAttributes.save();
        assertEquals(1, aliasDbInstance.getAll().size());

        // Destroy it and check that the database is empty
        aliasDbInstance.destroy(aliasAttributes.getAlias());
        assertEquals(0, aliasDbInstance.getAll().size());

        // Undestroy it and check that it's back in the database
        aliasDbInstance.undestroy(aliasAttributes.getAlias());
        assertEquals(1, aliasDbInstance.getAll().size());
    }

    @Test
    public void testGetCommandFromAlias() throws Exception {
        // Create an Alias in the database
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasAttributes.save();

        // Assert the the command we obtain is the same as the one we set
        assertEquals(aliasAttributes.getCommand(), aliasDbInstance.getCommandFromAlias(aliasAttributes.getAlias()));
    }

    @Test(expected = InvalidAliasException.class)
    public void testGetCommandFromInvalidAlias() throws Exception {
        // Try getting the command of an inexistent alias
        aliasDbInstance.getCommandFromAlias(Constants.TEST_ALIAS);
    }

    @Test
    public void testLoad() throws Exception {
        // Create an alias and get the JSON form of the current state
        AliasAttributes aliasAttributes = new AliasAttributes(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        aliasAttributes.save();
        String json = Serializer.serialize(aliasDbInstance.getAll());

        // Remove the alias and create the data file
        aliasDbInstance.destroy(aliasAttributes.getAlias());
        assertTrue(aliasDbInstance.getAll().isEmpty());
        TestHelper.createDataFilesWith(testDirectoryString, json);

        // Command under test (load from data file)
        FilePathPair replacedFiles = aliasDbInstance.load();

        // Ensure that no files were replaced
        assertNull(replacedFiles);

        // Check that the original alias exists
        assertEquals(aliasDbInstance.getAll().size(), 1);
        assertEquals(aliasDbInstance.getCommandFromAlias(aliasAttributes.getAlias()), aliasAttributes.getCommand());
    }

    @Test
    public void testInvalidLoad() throws Exception {
        // Create an invalid alias data file to load from
        TestHelper.createInvalidAliasFile(testDirectoryString);

        // Command under test (load from the invalid data file)
        FilePathPair replacedFiles = aliasDbInstance.load();

        // Assert that the invalid file was moved
        assertNotNull(replacedFiles);
    }

    @Test
    public void testSetAndGetFilePath() {
        // Get the original file path so that we can revert it later
        Path originalFilePath = aliasDbInstance.getFilePath();

        // Set up the paths that we want to use during the test
        Path subdirectory = Paths.get(testDirectory.toString(), Constants.TEST_SUBDIRECTORY_NAME);
        Path expectedAliasPath = Paths.get(subdirectory.toString(), Constants.FILENAME_ALIAS);

        // Command under test
        aliasDbInstance.setFilePath(subdirectory.toString());

        // Assert that the file path is now set correctly
        assertEquals(expectedAliasPath, aliasDbInstance.getFilePath());

        // Reset back to the original file path
        aliasDbInstance.setFilePath(originalFilePath.getParent().toString());
    }

    /**
     * This method checks if aliasAttributesList contains an AliasAttributes
     * that is equal to aliasAttributes.
     *
     * @param aliasAttributesList
     *            the list that we want to check
     * @param aliasAttributes
     *            the aliasAttributes that we want to find in
     *            aliasAttributesList
     * @return a boolean indicating if aliasAttributesList contains an
     *         AliasAttributes that is equal to aliasAttributes
     */
    private boolean contains(ArrayList<AliasAttributes> aliasAttributesList, AliasAttributes aliasAttributes) {
        return aliasAttributesList.stream().anyMatch(aliasAttributes2 -> {
            return aliasAttributes2.getAlias().equals(aliasAttributes.getAlias())
                    && aliasAttributes2.getCommand().equals(aliasAttributes.getCommand());
        });
    }

}
```
###### src\test\java\jfdi\test\storage\AliasTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.assertEquals;
import jfdi.storage.Constants;
import jfdi.storage.entities.Alias;

import org.junit.Test;

public class AliasTest {

    @Test
    public void testAliasConstructorAndGetters() {
        // We create an alias and check that the getters return the correct values
        Alias alias = new Alias(Constants.TEST_ALIAS, Constants.TEST_COMMAND);
        assertEquals(alias.getAlias(), Constants.TEST_ALIAS);
        assertEquals(alias.getCommand(), Constants.TEST_COMMAND);
    }

}
```
###### src\test\java\jfdi\test\storage\DatabaseManagerTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.assertTrue;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;

import jfdi.storage.Constants;
import jfdi.storage.DatabaseManager;
import jfdi.storage.exceptions.FilesReplacedException;

import org.junit.BeforeClass;
import org.junit.Test;

public class DatabaseManagerTest {

    private static Path testDirectory = null;
    private static String testDirectoryString = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectory = Files.createTempDirectory(Constants.TEST_DIRECTORY_NAME);
        testDirectoryString = testDirectory.toString();
    }

    @Test
    public void testSetAndGetAllFilePaths() {
        // Test setting of all file paths
        DatabaseManager.setAllFilePaths(testDirectoryString);

        // Test getting of all file paths
        ArrayList<Path> obtainedFilePaths = DatabaseManager.getAllFilePaths();

        // Assert that it contains all the file paths we expect
        ArrayList<Path> expectedFilePaths = new ArrayList<Path>();
        Arrays.stream(Constants.FILENAME_DATA_ARRAY).map(filename -> {
            return Paths.get(testDirectoryString, filename);
        }).forEach(expectedFilePaths::add);
        assertTrue(TestHelper.hasSameElements(expectedFilePaths, obtainedFilePaths));
    }

    @Test
    public void testLoadAllDatabases() throws Exception {
        // Set all the file paths
        String dataPath = TestHelper.getDataDirectory(testDirectoryString);
        DatabaseManager.setAllFilePaths(dataPath);

        // Create some valid data files to load from
        TestHelper.createValidDataFiles(testDirectoryString);

        // Command under test (load from the valid data files)
        DatabaseManager.loadAllDatabases();
    }

    @Test(expected = FilesReplacedException.class)
    public void testLoadAllRecordsWithInvalidData() throws Exception {
        // Set all the file paths
        String dataPath = TestHelper.getDataDirectory(testDirectoryString);
        DatabaseManager.setAllFilePaths(dataPath);

        // Create some invalid data files to load from
        TestHelper.createInvalidDataFiles(testDirectoryString);

        // Command under test (load from the invalid data files)
        DatabaseManager.loadAllDatabases();
    }

}
```
###### src\test\java\jfdi\test\storage\FileManagerTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;

import jfdi.storage.Constants;
import jfdi.storage.FileManager;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.exceptions.FilesReplacedException;

import org.apache.commons.io.FileUtils;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class FileManagerTest {

    private static Path testDirectoryRoot = null;
    private static MainStorage mainStorageInstance = null;
    private static String originalPreference = null;

    private Path testDirectoryPath = null;
    private File testDirectoryFile = null;
    private String testDirectoryString = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectoryRoot = Files.createTempDirectory(Constants.TEST_DIRECTORY_PREFIX);
        mainStorageInstance = MainStorage.getInstance();
        originalPreference = mainStorageInstance.getPreferredDirectory();
        mainStorageInstance.setPreferredDirectory(testDirectoryRoot.toString());
        mainStorageInstance.initialize();
    }

    @AfterClass
    public static void tearDownAfterClass() throws Exception {
        FileUtils.deleteDirectory(testDirectoryRoot.toFile());
        TestHelper.revertOriginalPreference(mainStorageInstance, originalPreference);
    }

    @Before
    public void setUp() throws Exception {
        testDirectoryPath = Paths.get(testDirectoryRoot.toString(), Constants.TEST_DIRECTORY_NAME);
        testDirectoryFile = testDirectoryPath.toFile();
        testDirectoryString = testDirectoryFile.getAbsolutePath();
        assertFalse(testDirectoryFile.exists());
    }

    @After
    public void tearDown() throws Exception {
        if (testDirectoryFile.exists()) {
            FileUtils.deleteDirectory(testDirectoryFile);
        }
    }

    @Test
    public void testPrepareDirectory() throws Exception {
        // The folder should not exist at the start
        assertFalse(testDirectoryFile.exists());

        // Command under test (we prepare the directory for storage)
        FileManager.prepareDirectory(testDirectoryString);

        // Now the folder should exist
        assertTrue(testDirectoryFile.exists());
    }

    @Test
    public void testMoveFilesToNewDirectory() throws Exception {
        // Create some valid data files and get their checksums
        mainStorageInstance.use(testDirectoryString);
        TestHelper.createValidDataFiles(testDirectoryString);
        HashMap<String, Long> checksums = TestHelper.getDataFileChecksums(testDirectoryString);
        String subdirectory = Paths.get(testDirectoryString, Constants.TEST_SUBDIRECTORY_NAME).toString();

        // Command under test (move the data files to the new directory)
        String dataPath = TestHelper.getDataDirectory(subdirectory);
        FileManager.moveFilesToDirectory(dataPath);

        // Assert that their checksums remain the same
        assertTrue(TestHelper.hasDataFileChecksums(subdirectory, checksums));
    }

    @Test(expected = FilesReplacedException.class)
    public void testMoveFilesToDirectoryWithExistingData() throws Exception {
        // Create some valid data files and get their checksums
        mainStorageInstance.use(testDirectoryString);
        TestHelper.createValidDataFiles(testDirectoryString);
        HashMap<String, Long> checksums = TestHelper.getDataFileChecksums(testDirectoryString);
        String subdirectory = Paths.get(testDirectoryString, Constants.TEST_SUBDIRECTORY_NAME).toString();

        // Create some invalid data files in the destination directory for collision
        TestHelper.createInvalidDataFiles(subdirectory);

        try {
            // Command under test (move the data files to the new directory)
            String dataPath = TestHelper.getDataDirectory(subdirectory);
            FileManager.moveFilesToDirectory(dataPath);
        } catch (FilesReplacedException e) {
            // Ensure that files are replaced and assert that the data files in
            // the destination remains the same
            assertTrue(TestHelper.hasDataFileChecksums(subdirectory, checksums));
            throw e;
        }
    }

    @Test
    public void testBackupAndRemove() {
        // Create the test file
        Path testFilePath = Paths.get(testDirectoryString, Constants.TEST_FILE_NAME);
        File testFile = testFilePath.toFile();
        testFile.getParentFile().mkdirs();
        FileManager.writeToFile(Constants.TEST_FILE_DATA, testFilePath);

        // Command under test (backup and remove the file)
        String backupPath = FileManager.backupAndRemove(testFilePath);

        // Assert that the test file has now been moved to the backup location
        File backupFile = new File(backupPath);
        assertFalse(testFile.exists());
        assertTrue(backupFile.exists());
    }

    @Test
    public void testWriteAndRead() {
        // Create the necessary directories
        Path filePath = Paths.get(testDirectoryString, Constants.TEST_FILE_NAME);
        File parentFile = filePath.getParent().toFile();
        parentFile.mkdirs();

        // Test writing to the file
        FileManager.writeToFile(Constants.TEST_FILE_DATA, filePath);

        // Test reading from the file
        String readString = FileManager.readFileToString(filePath);

        // Ensure that both are the same
        assertEquals(Constants.TEST_FILE_DATA, readString);
    }

}
```
###### src\test\java\jfdi\test\storage\MainStorageTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import jfdi.storage.Constants;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.FilesReplacedException;

import org.apache.commons.io.FileUtils;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class MainStorageTest {

    private static Path testDirectoryRoot = null;

    private MainStorage mainStorageInstance = null;
    private Path testDirectoryPath = null;
    private File testDirectoryFile = null;
    private String testDirectoryString = null;
    private String originalPreference = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectoryRoot = Files.createTempDirectory(Constants.TEST_DIRECTORY_PREFIX);
    }

    @AfterClass
    public static void tearDownAfterClass() throws Exception {
        FileUtils.deleteDirectory(testDirectoryRoot.toFile());
    }

    @Before
    public void setUp() throws Exception {
        mainStorageInstance = MainStorage.getInstance();
        originalPreference = mainStorageInstance.getPreferredDirectory();
        testDirectoryPath = Paths.get(testDirectoryRoot.toString(), Constants.TEST_DIRECTORY_NAME);
        testDirectoryFile = testDirectoryPath.toFile();
        testDirectoryString = testDirectoryFile.getAbsolutePath();
        assertFalse(testDirectoryFile.exists());
    }

    @After
    public void tearDown() throws Exception {
        TestHelper.revertOriginalPreference(mainStorageInstance, originalPreference);
        mainStorageInstance.removeInstance();
        if (testDirectoryFile.exists()) {
            FileUtils.deleteDirectory(testDirectoryFile);
        }
    }

    @Test
    public void testGetInstance() {
        // Test the ability to get an instance of MainStorage in the test's setUp() method
        assertTrue(mainStorageInstance instanceof MainStorage);

        // Make sure that getInstance returns the same instance in every call
        assertSame(mainStorageInstance, MainStorage.getInstance());
    }

    @Test
    public void testInitialize() throws Exception {
        // Command under test
        initializeStorage();

        // Assert test folder exists after a successful initialization
        assertTrue(testDirectoryFile.exists());

        // Check that the file permissions are set correctly
        assertTrue(testDirectoryFile.canExecute());
        assertTrue(testDirectoryFile.canWrite());
    }

    @Test
    public void testUse() throws Exception {
        // Initialize storage and create a valid task file to load from
        initializeStorage();
        Path subdirectoryPath = Paths.get(testDirectoryString, Constants.TEST_SUBDIRECTORY_NAME);
        String subdirectoryString = subdirectoryPath.toString();
        TestHelper.createValidTaskFile(subdirectoryString);

        // There should be no tasks before we switch directory
        TaskDb.getInstance().reset();
        assertEquals(0, TaskDb.getInstance().getAll().size());

        // Command under test
        mainStorageInstance.use(subdirectoryString);

        // The preferred directory should be set as the subdirectory and there
        // should be 1 task loaded from the subdirectory
        assertEquals(subdirectoryString, mainStorageInstance.getPreferredDirectory());
        assertEquals(1, TaskDb.getInstance().getAll().size());
    }

    @Test
    public void testSuccessfulLoad() throws Exception {
        // Command under test
        mainStorageInstance.load(testDirectoryString);

        // Assert test folder exists after a successful load
        assertTrue(testDirectoryFile.exists());

        // Check that the file permissions are set correctly
        assertTrue(testDirectoryFile.canExecute());
        assertTrue(testDirectoryFile.canWrite());
    }

    @Test
    public void testLoadValidExistingFiles() throws Exception {
        // Create some valid data files to load from
        createValidDataFiles();

        // Command under test (there should be no exceptions thrown)
        mainStorageInstance.load(testDirectoryString);
    }

    @Test(expected = FilesReplacedException.class)
    public void testLoadInvalidExistingFiles() throws Exception {
        // Create some invalid data files to load from
        createInvalidDataFiles();

        // Loading the invalid data files should give an exception
        String dataDirectory = mainStorageInstance.getDataDirectory(testDirectoryString);
        mainStorageInstance.load(dataDirectory);
    }

    @Test(expected = AssertionError.class)
    public void testChangeDirectoryBeforeInitialization() throws Exception {
        // We should not be able to change directory before storage is initialized
        mainStorageInstance.changeDirectory(testDirectoryString);
    }

    @Test(expected = FilesReplacedException.class)
    public void testChangeDirectoryWithExistingInvalidFiles() throws Exception {
        // Initialized storage and create some valid data files to be moved
        initializeStorage();
        TestHelper.createValidDataFiles(testDirectoryString);

        // Create some invalid data files in the destination directory
        Path subdirectoryPath = Paths.get(testDirectoryString, Constants.TEST_SUBDIRECTORY_NAME);
        String subdirectoryString = subdirectoryPath.toString();
        TestHelper.createInvalidDataFiles(subdirectoryString);

        // An exception will be thrown when the invalid data files are replaced
        mainStorageInstance.changeDirectory(subdirectoryString);
    }

    @Test
    public void testChangeToNewDirectory() throws Exception {
        // Initialize storage and set up the paths to be used
        initializeStorage();
        Path subdirectoryPath = Paths.get(testDirectoryString, Constants.TEST_SUBDIRECTORY_NAME);
        String subdirectoryString = subdirectoryPath.toString();

        // Command under test (change to the new directory)
        mainStorageInstance.changeDirectory(subdirectoryString);

        // Check that the path to the new directory is saved and no exceptions are thrown
        String preferredDirectory = mainStorageInstance.getPreferredDirectory();
        assertEquals(preferredDirectory, subdirectoryString);
    }

    /**
     * This method initializes fileStorage with the test directory, then reverts
     * the preference file back to its original form.
     */
    private void initializeStorage() {
        mainStorageInstance.setPreferredDirectory(testDirectoryString);
        try {
            mainStorageInstance.initialize();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method creates valid data files in the test directory.
     */
    private void createValidDataFiles() {
        TestHelper.createValidDataFiles(testDirectoryString);
    }

    /**
     * This method creates invalid data files in the test directory.
     */
    private void createInvalidDataFiles() {
        TestHelper.createInvalidDataFiles(testDirectoryString);
    }
}
```
###### src\test\java\jfdi\test\storage\SerializerTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.assertEquals;

import jfdi.storage.Constants;
import jfdi.storage.entities.Task;
import jfdi.storage.serializer.Serializer;

import org.junit.Test;

public class SerializerTest {

    @Test
    public void testSerializeAndDeserialize() {
        // Generate a new Task
        Task task = new Task(
                1,
                Constants.TEST_TASK_DESCRIPTION_1,
                Constants.TEST_TASK_STARTDATETIME,
                Constants.TEST_TASK_ENDDATETIME
                );

        // Serialize it
        String serializedJson = Serializer.serialize(task);

        // Deserialize the serialized JSON
        Task deserializedTask = Serializer.deserialize(serializedJson, Task.class);

        // Assert that the properties are still the same
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, deserializedTask.getDescription());
        assertEquals(Constants.TEST_TASK_STARTDATETIME, deserializedTask.getStartDateTime());
        assertEquals(Constants.TEST_TASK_ENDDATETIME, deserializedTask.getEndDateTime());
        assertEquals(false, deserializedTask.isCompleted());
    }

}
```
###### src\test\java\jfdi\test\storage\TaskAttributesTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.*;

import java.nio.file.Files;
import java.nio.file.Path;

import jfdi.storage.Constants;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.entities.Task;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import org.junit.After;
import org.junit.BeforeClass;
import org.junit.Test;

public class TaskAttributesTest {

    private static Path testDirectory = null;
    private static TaskDb taskDbInstance = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectory = Files.createTempDirectory(Constants.TEST_DIRECTORY_NAME);
        MainStorage.getInstance().load(testDirectory.toString());
        taskDbInstance = TaskDb.getInstance();
    }

    @After
    public void tearDown() throws Exception {
        taskDbInstance.reset();
    }

    @Test
    public void testSettersAndGetters() {
        // Use the setters to set the task's attributes
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setId(1);
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskAttributes.setCompleted(true);

        // Assert that the getter returns the same attributes
        assertEquals(new Integer(1), taskAttributes.getId());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, taskAttributes.getDescription());
        assertEquals(Constants.TEST_TASK_STARTDATETIME, taskAttributes.getStartDateTime());
        assertEquals(Constants.TEST_TASK_ENDDATETIME, taskAttributes.getEndDateTime());
        assertEquals(true, taskAttributes.isCompleted());
    }

    @Test
    public void testConstructor() {
        // Generate a TaskAttribute from a Task
        Task task = getSimpleTask();
        TaskAttributes taskAttributes = new TaskAttributes(task);

        // Check for equivalence in all attributes
        assertEquals(task.getId(), taskAttributes.getId());
        assertEquals(task.getDescription(), taskAttributes.getDescription());
        assertEquals(task.getStartDateTime(), taskAttributes.getStartDateTime());
        assertEquals(task.getEndDateTime(), taskAttributes.getEndDateTime());
    }

    @Test(expected = InvalidTaskParametersException.class)
    public void testInvalidParametersSave() throws Exception {
        // Save an invalid TaskAttributes object (without parameters)
        // This should throw an exception
        new TaskAttributes().save();
    }

    @Test(expected = NoAttributesChangedException.class)
    public void testNoChangesSave() throws Exception {
        // Persist the Task to storage
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Call a second save with no changes
        // This should throw an exception
        taskAttributes.save();
    }

    @Test(expected = DuplicateTaskException.class)
    public void testSaveDuplicateTasks() throws Exception {
        // Save the first Task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskAttributes.save();

        // Save another identical Task
        // This should trigger the exception
        taskAttributes.setId(null);
        taskAttributes.save();
    }

    @Test(expected = InvalidIdException.class)
    public void testInvalidIdSave() throws Exception {
        // Ensure that there are no other tasks in the DB first
        assertTrue(taskDbInstance.getAll().isEmpty());

        // Create a Task with an invalid ID and save
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setId(1);

        // This should trigger the exception
        taskAttributes.save();
    }

    @Test
    public void testCreateOnSave() throws Exception {
        // Make sure that the database starts off empty
        assertTrue(taskDbInstance.getAll().isEmpty());

        // We create a Task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskAttributes.save();

        // Verify that a task has been created
        assertEquals(1, taskDbInstance.getAll().size());

        // Check that the task has been created with the correct attributes
        TaskAttributes taskAttributes2 = taskDbInstance.getById(1);
        assertEquals(new Integer(1), taskAttributes2.getId());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, taskAttributes2.getDescription());
        assertEquals(Constants.TEST_TASK_STARTDATETIME, taskAttributes2.getStartDateTime());
        assertEquals(Constants.TEST_TASK_ENDDATETIME, taskAttributes2.getEndDateTime());
        assertEquals(false, taskAttributes2.isCompleted());
    }

    @Test
    public void testUpdateOnSave() throws Exception {
        // Make sure that the database starts off empty
        assertTrue(taskDbInstance.getAll().isEmpty());

        // Create a Task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Verify that a task has been created
        assertEquals(1, taskDbInstance.getAll().size());

        // Add more attributes to it
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskAttributes.setCompleted(true);
        taskAttributes.save();

        // Verify that the attributes have been updated
        TaskAttributes taskAttributes2 = taskDbInstance.getById(1);
        assertEquals(new Integer(1), taskAttributes2.getId());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, taskAttributes2.getDescription());
        assertEquals(Constants.TEST_TASK_STARTDATETIME, taskAttributes2.getStartDateTime());
        assertEquals(Constants.TEST_TASK_ENDDATETIME, taskAttributes2.getEndDateTime());
        assertEquals(true, taskAttributes2.isCompleted());
    }

    @Test
    public void testToEntity() {
        // Generate a TaskAttribute and get its entity
        Task task = getSimpleTask();
        TaskAttributes taskAttributes = new TaskAttributes(task);
        Task taskMirror = taskAttributes.toEntity();

        // Check for equivalence in all attributes
        assertEquals(taskAttributes.getId(), taskMirror.getId());
        assertEquals(taskAttributes.getDescription(), taskMirror.getDescription());
        assertEquals(taskAttributes.getStartDateTime(), taskMirror.getStartDateTime());
        assertEquals(taskAttributes.getEndDateTime(), taskMirror.getEndDateTime());
    }

    @Test
    public void testEqualTo() {
        // Generate a task
        Task task = getSimpleTask();

        // Set identical attributes
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setId(1);
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);

        // Make sure they are equivalent
        assertTrue(taskAttributes.equalTo(task));
    }

    /**
     * @return a new Task with all of the first constants as its attributes
     */
    private Task getSimpleTask() {
        // Generate the new Task
        Task task = new Task(
                1,
                Constants.TEST_TASK_DESCRIPTION_1,
                Constants.TEST_TASK_STARTDATETIME,
                Constants.TEST_TASK_ENDDATETIME
                );
        return task;
    }

}
```
###### src\test\java\jfdi\test\storage\TaskDbTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.*;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import jfdi.storage.Constants;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.FilePathPair;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import jfdi.storage.serializer.Serializer;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

public class TaskDbTest {

    private static Path testDirectory = null;
    private static String testDirectoryString = null;
    private static TaskDb taskDbInstance = null;
    private static MainStorage mainStorageInstance = null;
    private static String originalPreference = null;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        testDirectory = Files.createTempDirectory(Constants.TEST_DIRECTORY_NAME);
        testDirectoryString = testDirectory.toString();
        mainStorageInstance = MainStorage.getInstance();
        originalPreference = mainStorageInstance.getPreferredDirectory();
        mainStorageInstance.setPreferredDirectory(testDirectoryString);
        mainStorageInstance.initialize();
        mainStorageInstance.use(testDirectoryString);
        taskDbInstance = TaskDb.getInstance();
    }

    @AfterClass
    public static void tearDownAfterClass() {
        TestHelper.revertOriginalPreference(mainStorageInstance, originalPreference);
    }

    @After
    public void tearDown() throws Exception {
        taskDbInstance.reset();
    }

    @Test
    public void testCreate() throws Exception {
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);

        // The database should be empty prior to the task creation
        assertTrue(taskDbInstance.getAll().isEmpty());

        // Command under test
        taskDbInstance.createOrUpdate(taskAttributes);

        // Check that the task has been created
        assertEquals(1, taskDbInstance.getAll().size());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1,
                taskDbInstance.getById(taskAttributes.getId()).getDescription());
    }

    @Test(expected = DuplicateTaskException.class)
    public void testCreateDuplicate() throws Exception {
        // Create the first Task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskDbInstance.createOrUpdate(taskAttributes);

        // Create another duplicate Task
        // This should trigger the exception
        taskAttributes.setId(null);
        taskDbInstance.createOrUpdate(taskAttributes);
    }

    @Test
    public void testUpdate() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskDbInstance.createOrUpdate(taskAttributes);

        // Check that the task has been created
        assertEquals(1, taskDbInstance.getAll().size());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, taskDbInstance.getById(1).getDescription());

        // Command under test (update the task's description)
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_2);
        taskDbInstance.createOrUpdate(taskAttributes);

        // Ensure that object update (and not creation) takes place
        assertEquals(1, taskDbInstance.getAll().size());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_2,
                taskDbInstance.getById(taskAttributes.getId()).getDescription());
    }

    @Test(expected = NoAttributesChangedException.class)
    public void testNoChangesUpdate() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskDbInstance.createOrUpdate(taskAttributes);

        // The second no-changes update triggers the exception
        taskDbInstance.createOrUpdate(taskAttributes);
    }

    @Test(expected = InvalidIdException.class)
    public void testInvalidIdUpdate() throws Exception {
        // Set the ID of a TaskAttributes to an invalid one
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setId(1);

        // Command under test (invalid ID will trigger exception)
        taskDbInstance.createOrUpdate(taskAttributes);
    }

    @Test
    public void testSetAndGetFilePath() {
        // Save the original file path so that we can revert it later
        Path originalFilePath = taskDbInstance.getFilePath();
        Path subdirectory = Paths.get(testDirectory.toString(), Constants.TEST_SUBDIRECTORY_NAME);
        Path expectedTaskPath = Paths.get(subdirectory.toString(), Constants.FILENAME_TASK);

        // Test setFilePath
        taskDbInstance.setFilePath(subdirectory.toString());

        // Assert that we get back the same file path
        assertEquals(expectedTaskPath, taskDbInstance.getFilePath());

        // Reset back to the original file path
        taskDbInstance.setFilePath(originalFilePath.getParent().toString());
    }

    @Test
    public void testGetAll() throws Exception {
        // Create the first task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // A hack to create another task
        taskAttributes.setId(null);
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_2);
        taskAttributes.save();

        // Check that the stored tasks are as expected
        ArrayList<TaskAttributes> taskAttributesList = new ArrayList<TaskAttributes>(taskDbInstance.getAll());
        assertEquals(2, taskAttributesList.size());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, taskAttributesList.get(0).getDescription());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_2, taskAttributesList.get(1).getDescription());
    }

    @Test
    public void testGetById() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Check that we can get the same task using getById
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1,
                taskDbInstance.getById(taskAttributes.getId()).getDescription());
    }

    @Test
    public void testHasId() throws Exception {
        // No task yet, so any ID should be invalid
        assertFalse(taskDbInstance.hasId(1));

        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Now taskAttribute's ID should exist
        assertTrue(taskDbInstance.hasId(taskAttributes.getId()));
    }

    @Test
    public void testMarkAsCompleteAndIncomplete() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Test markAsComplete
        taskDbInstance.markAsComplete(taskAttributes.getId());
        assertTrue(taskDbInstance.getById(taskAttributes.getId()).isCompleted());

        // Test markAsIncomplete
        taskDbInstance.markAsIncomplete(1);
        assertFalse(taskDbInstance.getById(taskAttributes.getId()).isCompleted());
    }

    @Test(expected = NoAttributesChangedException.class)
    public void testMarkCompletedAsComplete() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Mark the task as completed
        taskAttributes.setCompleted(true);
        taskAttributes.save();

        // Mark it as complete again (this should trigger an exception)
        taskDbInstance.markAsComplete(taskAttributes.getId());
    }

    @Test(expected = NoAttributesChangedException.class)
    public void testMarkIncompletedAsIncomplete() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Mark an incomplete task as incomplete (this should trigger an exception)
        taskDbInstance.markAsIncomplete(taskAttributes.getId());
    }

    @Test(expected = InvalidIdException.class)
    public void testMarkInvalidIdAsComplete() throws Exception {
        // Mark an invalid ID as complete
        taskDbInstance.markAsComplete(Integer.MAX_VALUE);
    }

    @Test(expected = InvalidIdException.class)
    public void testMarkInvalidIdAsIncomplete() throws Exception {
        // Mark an invalid ID as incomplete
        taskDbInstance.markAsIncomplete(Integer.MAX_VALUE);
    }

    @Test
    public void testDestroyAndUndestroy() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Check that it has been created
        assertEquals(1, taskDbInstance.getAll().size());

        // Destroy the task
        taskDbInstance.destroy(taskAttributes.getId());
        assertEquals(0, taskDbInstance.getAll().size());

        // Undestroy the task
        taskDbInstance.undestroy(taskAttributes.getId());
        assertEquals(1, taskDbInstance.getAll().size());
    }

    @Test(expected = InvalidIdException.class)
    public void testInvalidIdDestroy() throws Exception {
        // Destroy an invalid ID
        taskDbInstance.destroy(Integer.MAX_VALUE);
    }

    @Test(expected = InvalidIdException.class)
    public void testInvalidIdUndestroy() throws Exception {
        // Undestroy an invalid ID
        taskDbInstance.undestroy(Integer.MAX_VALUE);
    }

    @Test(expected = DuplicateTaskException.class)
    public void testUndestroyDuplicateTask() throws Exception {
        // Create the first Task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskDbInstance.createOrUpdate(taskAttributes);
        int firstTaskId = taskAttributes.getId();

        // Destroy the first task
        taskDbInstance.destroy(firstTaskId);

        // Create another duplicate Task
        taskAttributes.setId(null);
        taskDbInstance.createOrUpdate(taskAttributes);

        // Undestroy the first task (it becomes a duplicate now)
        // This should trigger the exception
        taskDbInstance.undestroy(firstTaskId);
    }

    @Test
    public void testLoad() throws Exception {
        // Create a task
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Get the JSON form of the current state
        String json = Serializer.serialize(taskDbInstance.getAll());

        // Remove the task
        taskDbInstance.destroy(taskAttributes.getId());
        assertTrue(taskDbInstance.getAll().isEmpty());

        // Create the data file and load from it
        TestHelper.createTaskFileWith(testDirectoryString, json);
        FilePathPair filesReplaced = taskDbInstance.load();

        // No files should have been replaced
        assertNull(filesReplaced);

        // Check that the original task exists after load
        assertEquals(1, taskDbInstance.getAll().size());
        TaskAttributes retrievedTaskAttributes = taskDbInstance.getById(taskAttributes.getId());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, retrievedTaskAttributes.getDescription());
    }

    @Test
    public void testLoadFromInvalidData() throws Exception {
        // Create an invalid task file to load from
        TestHelper.createInvalidTaskFile(testDirectoryString);

        // Command under test (load from the invalid task file)
        FilePathPair filesReplaced = taskDbInstance.load();

        // Assert the files have been replaced
        assertNotNull(filesReplaced);
    }

    @Test
    public void testTaskIdsResetUponLoad() throws Exception {
        // Create task 1
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_1);
        taskAttributes.save();

        // Create task 2
        taskAttributes.setId(null);
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_2);
        taskAttributes.save();

        // Delete the first task
        taskDbInstance.destroy(1);

        // Command under test
        taskDbInstance.load();

        // There should only be one task with ID of 1
        assertTrue(taskDbInstance.hasId(1));
        assertFalse(taskDbInstance.hasId(2));
    }

}
```
###### src\test\java\jfdi\test\storage\TaskTest.java
``` java
package jfdi.test.storage;

import static org.junit.Assert.*;

import jfdi.storage.Constants;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.entities.Task;

import org.junit.Test;

public class TaskTest {

    @Test
    public void testConstructorAndGetters() {
        // Generate the new Task
        Task task = new Task(
                1,
                Constants.TEST_TASK_DESCRIPTION_1,
                Constants.TEST_TASK_STARTDATETIME,
                Constants.TEST_TASK_ENDDATETIME
                );

        // Check for equivalence in all attributes
        assertEquals(new Integer(1), task.getId());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_1, task.getDescription());
        assertEquals(Constants.TEST_TASK_STARTDATETIME, task.getStartDateTime());
        assertEquals(Constants.TEST_TASK_ENDDATETIME, task.getEndDateTime());
        assertEquals(false, task.isCompleted());
    }

    @Test
    public void testUpdate() {
        // Create a new task
        Task task = new Task(1, Constants.TEST_TASK_DESCRIPTION_1, null, null);

        // Update its attributes
        TaskAttributes taskAttributes = new TaskAttributes();
        taskAttributes.setId(1);
        taskAttributes.setDescription(Constants.TEST_TASK_DESCRIPTION_2);
        taskAttributes.setStartDateTime(Constants.TEST_TASK_STARTDATETIME);
        taskAttributes.setEndDateTime(Constants.TEST_TASK_ENDDATETIME);
        taskAttributes.setCompleted(true);
        task.update(taskAttributes);

        // Check if the new attributes are correct
        assertEquals(new Integer(1), task.getId());
        assertEquals(Constants.TEST_TASK_DESCRIPTION_2, task.getDescription());
        assertEquals(Constants.TEST_TASK_STARTDATETIME, task.getStartDateTime());
        assertEquals(Constants.TEST_TASK_ENDDATETIME, task.getEndDateTime());
        assertEquals(true, task.isCompleted());
    }

}
```
###### src\test\java\jfdi\test\storage\TestHelper.java
``` java
package jfdi.test.storage;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;

import jfdi.storage.Constants;
import jfdi.storage.FileManager;
import jfdi.storage.apis.MainStorage;

import org.apache.commons.io.FileUtils;

public class TestHelper {

    /**
     * This method ensures that two given collections have the same elements.
     *
     * @param collection1
     *            the first collection to be compared
     * @param collection2
     *            the second collection to be compared
     * @return boolean indicating if the two collections have the same elements
     */
    public static <T> boolean hasSameElements(Collection<T> collection1, Collection<T> collection2) {
        HashSet<T> set1 = new HashSet<T>(collection1);
        HashSet<T> set2 = new HashSet<T>(collection2);
        return set1.equals(set2);
    }

    /**
     * This method returns the path to the data directory within the storage
     * directory.
     *
     * @param storageDirectory
     *            the folder which should store the user data
     * @return the path to the data directory within the storage directory
     */
    public static String getDataDirectory(String storageDirectory) {
        return MainStorage.getInstance().getDataDirectory(storageDirectory);
    }

    /**
     * This method creates a single valid task with the task's description set
     * as the first test task description.
     *
     * @param directoryPath
     *            the directory that holds the program data
     */
    public static void createValidTaskFile(String directoryPath) {
        String taskJson = "[{\"id\": 1,\"description\": \"" + Constants.TEST_TASK_DESCRIPTION_1
                + "\",\"tags\": [],\"reminders\": [],\"isCompleted\": false}]";
        createTaskFileWith(directoryPath, taskJson);
    }

    /**
     * This method creates a single invalid task with the task's description set
     * to null.
     *
     * @param directoryPath
     *            the directory that holds the program data
     */
    public static void createInvalidTaskFile(String directoryPath) {
        String taskJson = "[{\"id\": 1,\"tags\": [],\"reminders\": [],\"isCompleted\": false}]";
        createTaskFileWith(directoryPath, taskJson);
    }

    /**
     * This method creates a single invalid alias with the alias's command set
     * to null
     *
     * @param directoryPath
     *            the directory that holds the program data
     */
    public static void createInvalidAliasFile(String directoryPath) {
        String taskJson = "[{\"alias\": \"" + Constants.TEST_ALIAS + "\"}]";
        createAliasFileWith(directoryPath, taskJson);
    }

    /**
     * This method creates a task file with the given data in the given
     * directory path that stores the program data.
     *
     * @param directoryPath
     *            the directory that stores the program data
     * @param data
     *            the content that is to be written inside the task file
     */
    public static void createTaskFileWith(String directoryPath, String data) {
        String dataDirectory = TestHelper.getDataDirectory(directoryPath);
        Path dataPath = Paths.get(dataDirectory, Constants.FILENAME_TASK);
        FileManager.writeToFile(data, dataPath);
    }

    /**
     * This method creates an alias file with the given data in the given
     * directory path that stores the program data.
     *
     * @param directoryPath
     *            the directory that stores the program data
     * @param data
     *            the content that is to be written inside the task file
     */
    public static void createAliasFileWith(String directoryPath, String data) {
        String dataDirectory = TestHelper.getDataDirectory(directoryPath);
        Path dataPath = Paths.get(dataDirectory, Constants.FILENAME_ALIAS);
        FileManager.writeToFile(data, dataPath);
    }

    /**
     * This method creates valid data files in directoryPath
     *
     * @param directoryPath
     *            the directory to create the data files in
     */
    public static void createValidDataFiles(String directoryPath) {
        createDataFilesWith(directoryPath, Constants.EMPTY_LIST_STRING);
    }

    /**
     * This method creates invalid data files in directoryPath.
     *
     * @param directoryPath
     *            the directory to create the data files in
     */
    public static void createInvalidDataFiles(String directoryPath) {
        createDataFilesWith(directoryPath, Constants.EMPTY_STRING);
    }

    /**
     * This method creates data files in the specified directoryPath with the
     * given data written into the data files.
     *
     * @param directoryPath
     *            the path to the directory in which we create the data files
     * @param data
     *            the content that is to be written to the data files
     */
    public static void createDataFilesWith(String directoryPath, String data) {
        File parentDirectory = new File(directoryPath);
        parentDirectory.mkdirs();

        Path dataPath;
        String dataDirectory = TestHelper.getDataDirectory(directoryPath);
        for (String dataFilename : Constants.FILENAME_DATA_ARRAY) {
            dataPath = Paths.get(dataDirectory, dataFilename);
            FileManager.writeToFile(data, dataPath);
        }
    }

    /**
     * This method reverts the preference file to its original form after using
     * it in the tests.
     *
     * @param originalPreference
     *            the original storage directory path
     */
    public static void revertOriginalPreference(MainStorage mainStorage, String originalPreference) {
        if (originalPreference == null) {
            FileUtils.deleteQuietly(Constants.PATH_PREFERENCE_FILE.toFile());
            return;
        }
        mainStorage.setPreferredDirectory(originalPreference);
    }

    /**
     * This method returns an ArrayList of data files that exist in the given directory.
     *
     * @param directory
     *          the directory which contains data files
     * @return an ArrayList of data files that exist in the given directory
     */
    private static ArrayList<File> getDataFiles(String directory) {
        ArrayList<File> dataFiles = new ArrayList<File>();
        Path dataFilePath = null;
        File dataFile = null;

        for (String filename : Constants.FILENAME_DATA_ARRAY) {
            dataFilePath = Paths.get(directory, filename);
            dataFile = dataFilePath.toFile();
            if (dataFile.exists()) {
                dataFiles.add(dataFile);
            }
        }

        return dataFiles;
    }

    /**
     * This method returns a HashMap of data filenames mapped to their
     * respective checksums.
     *
     * @param storageDirectory
     *            the storage directory
     * @return a HashMap of data filenames mapped to their checksums
     */
    public static HashMap<String, Long> getDataFileChecksums(String storageDirectory) {
        try {
            HashMap<String, Long> checksums = new HashMap<String, Long>();
            String dataDirectory = getDataDirectory(storageDirectory);
            ArrayList<File> dataFiles = getDataFiles(dataDirectory);
            for (File dataFile : dataFiles) {
                checksums.put(dataFile.getName(), FileUtils.checksumCRC32(dataFile));
            }
            return checksums;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * This method checks if the given storageDirectory contains data files with
     * the same checksums.
     *
     * @param storageDirectory
     *            the storage directory
     * @param checksums
     *            the checksums that we want to check against
     * @return a boolean indicating if the given storageDirectory contains data
     *         files with the same checksums
     */
    public static boolean hasDataFileChecksums(String storageDirectory, HashMap<String, Long> checksums) {
        HashMap<String, Long> directoryChecksums = getDataFileChecksums(storageDirectory);
        return checksums.equals(directoryChecksums);
    }
}
```
