# A0127393B
###### ./src/main/java/jfdi/parser/commandparsers/AbstractCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.ParserUtils;
import jfdi.parser.exceptions.BadTaskIdException;

/**
 * The AbstractCommandParser class is the abstract class that defines the
 * functionality of all command parsers. It also contains the full
 * implementation of some methods that can be used across many different command
 * parsers.
 *
 * @author Leonard Hio
 *
 */
public abstract class AbstractCommandParser {

    /**
     * This method is used to build a command object based on the input String.
     *
     * @param input
     *            the input String from which a command object is to be built
     * @return a Command object.
     */
    public abstract Command build(String input);

    /**
     * This method checks if the given input is valid. A valid input is one that
     * is (1) not empty, and (2) not made of whitespaces only.
     *
     * @param input
     *            the input which validity is to be checked
     * @return true if the input is valid; false otherwise
     */
    protected boolean isValidInput(String input) {
        return input != null && !input.isEmpty() && !input.trim().isEmpty();
    }

    /**
     * Get the subString of an input String from startindex inclusive to
     * endindex exclusive, trimming it at the same time.
     *
     * @param input
     *            a String to get subString of
     * @param startIndex
     *            index of the start of the subString (inclusive)
     * @param endIndex
     *            index of the end of the subString (exclusive)
     * @return the trimmed subString
     */
    protected String getTrimmedSubstringInRange(String input, int startIndex, int endIndex) {
        assert isValidInput(input) && startIndex <= endIndex && startIndex >= 0 && endIndex <= input.length();
        return input.substring(startIndex, endIndex).trim();
    }

    /**
     * This method searches the input String for all instances of task IDs, and
     * returns them as an ArrayList. The search proceeds from left to right i.e.
     * from the start of the input to the end.
     *
     * @param input
     *            the String from which task IDs are found and extracted.
     * @return an ArrayList of task IDs, all Strings. If no task IDs can be
     *         found, an empty ArrayList is returned.
     */
    protected Collection<Integer> getTaskIds(String input) throws BadTaskIdException {
        assert isValidInput(input);

        Set<Integer> taskIdsForDeletion = new HashSet<Integer>();
        input = input.replaceAll("(\\d+)[ ]*-[ ]*(\\d+)", "$1-$2");
        input = input.replaceAll("[ ]+", ",");
        input = input.replaceAll(",+", ",");

        String[] taskIds = input.split(",");
        for (String taskId : taskIds) {
            if (taskId.matches("\\d+")) {
                taskIdsForDeletion.add(toInteger(taskId));
            } else if (taskId.matches("\\d+[ ]?-[ ]?\\d+")) {
                taskIdsForDeletion.addAll(getTaskIdsFromRange(taskId));
            } else {
                throw new BadTaskIdException(input);
            }
        }

        return taskIdsForDeletion;
    }

    protected Integer toInteger(String toInt) throws NumberFormatException {
        return Integer.parseInt(toInt);
    }

    /**
     * This method builds an InvalidCommand object. An InvalidCommand object has
     * to be built whenever a user inputs a String that cannot be parsed by the
     * parser for whatever reason.
     *
     * @param commandType
     *            the command type specified in the user's input.
     * @param inputString
     *            the actual input of the user.
     * @return an InvalidCommand object, containing the command type of the
     *         invalid user's input, and the user's input itself.
     */
    protected InvalidCommand createInvalidCommand(CommandType commandType, String inputString) {
        InvalidCommand.Builder invalidCommandBuilder = new InvalidCommand.Builder();
        invalidCommandBuilder.setInputString(inputString);
        invalidCommandBuilder.setCommandType(commandType);

        return invalidCommandBuilder.build();
    }

    /**
     * This method returns the first word of the input String.
     *
     * @param input
     *            a String from which the first word is to be returned.
     * @return the first word of the input String.
     */
    protected String getFirstWord(String input) {
        assert isValidInput(input);
        return input.trim().split(Constants.REGEX_WHITESPACE)[0];
    }

    /**
     * Removes the first word in the input String, and returns the rest of the
     * input.
     *
     * @param input
     *            the String from which the first word is to be removed
     * @return the input String without the first word and the whitespace
     *         separating the first word from the rest of the String. If the
     *         String only consists of one word, return an empty String.
     */
    protected String removeFirstWord(String input) {
        assert isValidInput(input);

        String[] splitInput = input.split(Constants.REGEX_WHITESPACE, 2);
        if (splitInput.length == 1) {
            return "";
        } else {
            return splitInput[1];
        }
    }

    protected boolean matchesCommandType(String input, CommandType commandType) {
        assert isValidInput(input);
        return ParserUtils.getCommandType(getFirstWord(input)).equals(commandType);
    }

    private Collection<? extends Integer> getTaskIdsFromRange(String taskId) throws BadTaskIdException {
        assert taskId.matches("\\d+[ ]?-[ ]?\\d+");
        String[] taskIdRangeArray = taskId.split("-");
        Collection<Integer> taskIdsInRange = new HashSet<>();
        assert taskIdRangeArray.length == 2;
        if (toInteger(taskIdRangeArray[0]) > toInteger(taskIdRangeArray[1])) {
            throw new BadTaskIdException(taskId);
        } else {
            for (int i = toInteger(taskIdRangeArray[0]); i <= toInteger(taskIdRangeArray[1]); i++) {
                taskIdsInRange.add(i);
            }
        }

        return taskIdsInRange;
    }

    protected boolean isSingleWord(String input) {
        assert isValidInput(input);
        return input.trim().split(Constants.REGEX_WHITESPACE).length == 1;
    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/AddCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.commands.AddTaskCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.DateTimeObject;
import jfdi.parser.DateTimeParser;
import jfdi.parser.exceptions.BadDateTimeException;
import jfdi.parser.exceptions.BadTaskDescriptionException;

/**
 * The AddCommandParser class is used to parse a user input String that
 * resembles an add command. All user inputs for adding tasks must adhere to the
 * following format: {add identifier}(optional) {task description} {date time
 * identifier}(optional). In addition, a user may wrap his task description with
 * "{task description}", where " is the escape delimiter, to escape inadventent
 * formatting of date-tme in the description.
 *
 * @author Leonard Hio
 *
 */
public class AddCommandParser extends AbstractCommandParser {

    private static AddCommandParser instance;

    private AddCommandParser() {

    }

    public static AddCommandParser getInstance() {
        if (instance == null) {
            return instance = new AddCommandParser();
        }

        return instance;
    }

    @Override
    /**
     * This method parses the user input (representing an add command) and builds the
     * AddTaskCommand object. To build the add command, we traverse from the back,
     * retrieving the date time identifiers if present, then the
     * task description.
     *
     * @param input
     *            the user input String
     * @return the AddTaskCommand object encapsulating the details of the add command.
     */
    public Command build(String input) {
        if (!isValidInput(input)) {
            return createInvalidCommand(Constants.CommandType.ADD, input);
        }

        String originalInput = input;
        Builder addCommandBuilder = new Builder();
        try {
            input = setAndRemoveDateTime(input, addCommandBuilder);
            setDescription(input, addCommandBuilder);
        } catch (BadDateTimeException | BadTaskDescriptionException e) {
            return createInvalidCommand(Constants.CommandType.ADD, originalInput);
        }

        AddTaskCommand addCommand = addCommandBuilder.build();
        return addCommand;
    }

    // ===================================
    // First Level of Abstraction
    // ===================================

    /**
     * Sets the date time identifier field in the builder, if it can be found in
     * the string input. If the user input has many instances of substrings that
     * match the Regex for date time identifiers (see parser.Constants.java),
     * then only the one closest to the tail of the string is taken as the date
     * time identifier. This is to allow for the user to both specify date times
     * for his task, while still allowing him the flexibility of typing in dates
     * and times in his task description.
     *
     * @param input
     *            the input string
     * @param builder
     *            the builder object for AddTaskCommand
     * @return the input, trimmed and without date time identifiers.
     *
     * @throws BadDateTimeException
     *             if input cannot be parsed as a date time
     */
    private String setAndRemoveDateTime(String input, Builder builder) throws BadDateTimeException {
        // Date time identifier must be at the end of the input String, hence
        // the "$" end-of-line flag
        Pattern dateTimePattern = Pattern.compile(Constants.REGEX_DATE_TIME_IDENTIFIER + "$");
        Matcher matcher = dateTimePattern.matcher(input);
        String dateTimeIdentifier = null;

        if (matcher.find()) {
            dateTimeIdentifier = getTrimmedSubstringInRange(input, matcher.start(), matcher.end());
            input = getTrimmedSubstringInRange(input, 0, matcher.start());
        }

        if (dateTimeIdentifier != null) {
            DateTimeParser dateTimeParser = DateTimeParser.getInstance();
            DateTimeObject dateTime = null;
            try {
                dateTime = dateTimeParser.parseDateTime(dateTimeIdentifier);
            } catch (BadDateTimeException e) {
                throw new BadDateTimeException(e.getInput());
            }
            builder.setStartDateTime(dateTime.getStartDateTime());
            builder.setEndDateTime(dateTime.getEndDateTime());
        }

        return input;
    }

    /**
     * Sets the description field of the builder object. Sets it to null if the
     * input String is empty, or just an add identifier without any task
     * descriptions.
     *
     * @param input
     *            is the input string from which the description is extracted.
     * @param builder
     *            the builder object for AddTaskCommand
     * @throws BadTaskDescriptionException
     *             if input is invalid as a task description
     */
    private void setDescription(String input, Builder builder) throws BadTaskDescriptionException {

        if (!input.isEmpty()) {
            String firstWord = getFirstWord(input);
            String taskDescription = null;
            if (firstWord.matches(Constants.REGEX_ADD)) {
                taskDescription = removeFirstWord(input);
            } else {
                taskDescription = input;
            }

            if (!taskDescription.isEmpty()) {
                if (isWrappedWithEscapeDelimiters(taskDescription)) {
                    taskDescription = removeEscapeDelimiters(taskDescription);
                }
                builder.setDescription(taskDescription);
            } else {
                throw new BadTaskDescriptionException(input);
            }

        } else {
            throw new BadTaskDescriptionException(input);
        }
    }

    // ===================================
    // Second Level of Abstraction
    // ===================================

    /**
     * This method checks to see if the given input is a task description,
     * wrapped with the description escape delimiters.
     *
     * @param input
     *            the task description input
     * @return true if description is wrapped; false otherwise
     */
    private boolean isWrappedWithEscapeDelimiters(String input) {
        return input.substring(0, 1).matches(Constants.REGEX_DESCRIPTION_ESCAPE_DELIMITER)
            && input.substring(input.length() - 1, input.length())
                .matches(Constants.REGEX_DESCRIPTION_ESCAPE_DELIMITER);
    }

    /**
     * This method strips the given input of the description escape delimiters.
     *
     * @param input
     *            the task description that is wrapped with delimiters.
     * @return the input without delimiters.
     * @throws BadTaskDescriptionException
     *             if the resulting input without delimiters is an empty string
     */
    private String removeEscapeDelimiters(String input) throws BadTaskDescriptionException {
        assert isWrappedWithEscapeDelimiters(input);
        String unwrappedInput = input.substring(1, input.length() - 1);
        if (unwrappedInput.isEmpty()) {
            throw new BadTaskDescriptionException(input);
        } else {
            return unwrappedInput;
        }
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/AliasCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.AliasCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.ParserUtils;

/**
 * The AliasCommandParser class takes in a user input representing an "Alias"
 * command and parses it into an AliasCommand object. This AliasCommand object
 * will then contain the associated mapping of alias to command type. All alias
 * user commands must be in the format:
 * "{alias identifier} {command type} {alias}"
 *
 * @author Leonard Hio
 *
 */
public class AliasCommandParser extends AbstractCommandParser {
    public static AliasCommandParser instance;

    private AliasCommandParser() {
    }

    public static AliasCommandParser getInstance() {
        if (instance == null) {
            return instance = new AliasCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidFormat(input)) {
            return createInvalidCommand(Constants.CommandType.ALIAS, input);
        }
        Builder builder = new Builder();
        String command = null;
        String alias = null;

        command = getCommand(input);

        alias = getAlias(input);

        builder.setIsValid(isPartOfCommandKeyword(alias));

        builder.setCommand(command);
        builder.setAlias(alias);

        return builder.build();
    }

    // ===================================
    // First Level of Abstraction
    // ===================================

    /**
     * This method checks to see if the format of the Alias command input is
     * valid. In this case, a user input is considered valid if it is 3 words
     * long.
     *
     * @param input
     *            the Alias input.
     * @return True if it is valid; false otherwise.
     */
    private boolean isValidFormat(String input) {
        if (!isValidInput(input)) {
            return false;
        }
        return input.split(Constants.REGEX_WHITESPACE).length == 3
            && getFirstWord(input).matches(Constants.REGEX_ALIAS);
    }

    /**
     * This method extracts the command from the user input.
     *
     * @param input
     *            the user input representing an alias command.
     * @return the command.
     */
    private String getCommand(String input) {
        assert isValidFormat(input);
        // Following the established format of alias command inputs, the command
        // type can be located as the second word.

        String secondWord = getSecondWord(input);
        return secondWord;
    }

    /**
     * This method extracts the alias from the user input.
     *
     * @param input
     *            the user input representing an alias command.
     * @return the alias.
     */
    private String getAlias(String input) {
        assert isValidFormat(input);
        String alias = getThirdWord(input);
        return alias;
    }

    private boolean isPartOfCommandKeyword(String alias) {
        return ParserUtils.getCommandType(alias).equals(CommandType.INVALID);
    }

    // ===================================
    // Second Level of Abstraction
    // ===================================

    private String getSecondWord(String input) {
        return input.split(Constants.REGEX_WHITESPACE)[1];
    }

    private String getThirdWord(String input) {
        return input.split(Constants.REGEX_WHITESPACE)[2];
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/DeleteCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.ArrayList;

import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.logic.commands.DeleteTaskCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.exceptions.BadTaskIdException;

/**
 * The DeleteCommandParser class takes in a user input representing a "Delete"
 * command and parses it into an DeleteCommand object. All delete user commands
 * must be in the format: "{delete identifier} {task ID(s)}". Additionally, task
 * IDs can be represented as a range i.e. "1-10", and all task IDs are to be
 * separated by a space and/or a comma.
 *
 * @author Leonard Hio
 *
 */
public class DeleteCommandParser extends AbstractCommandParser {

    public static DeleteCommandParser instance;

    private DeleteCommandParser() {

    }

    public static DeleteCommandParser getInstance() {
        if (instance == null) {
            return instance = new DeleteCommandParser();
        }

        return instance;
    }

    /**
     * This method builds a DeleteCommand by extracting out the list of taskIDs
     * specfied for deletion by the user and passing it into the command
     * builder.
     *
     * @param input
     *            the user input, representing a delete command.
     * @return a DeleteTaskCommand object, or an InvalidCommand if any
     *         exceptions are thrown.
     *
     */
    @Override
    public Command build(String input) {
        if (!isValidDeleteCommand(input)) {
            return createInvalidCommand(CommandType.DELETE, input);
        }
        input = removeFirstWord(input);
        Builder deleteCommandBuilder = new Builder();
        ArrayList<Integer> taskIds = new ArrayList<>();
        try {
            taskIds.addAll(getTaskIds(input));
        } catch (BadTaskIdException e) {
            return createInvalidCommand(CommandType.DELETE, input);
        }
        deleteCommandBuilder.addIds(taskIds);
        DeleteTaskCommand deleteCommand = deleteCommandBuilder.build();
        return deleteCommand;
    }

    /**
     * Checks to see if the given input is in a valid Delete format.
     */
    private boolean isValidDeleteCommand(String input) {
        return isValidInput(input) && input.trim().matches(Constants.REGEX_DELETE_FORMAT);
    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/DirectoryCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.DirectoryCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;

/**
 * This class parses the Directory command input by the user. The Directory
 * command is in the format {Directory identifier} i.e. a singular word.
 *
 * @author Leonard Hio
 *
 */
public class DirectoryCommandParser extends AbstractCommandParser {
    public static DirectoryCommandParser instance;

    private DirectoryCommandParser() {
    }

    public static DirectoryCommandParser getInstance() {
        if (instance == null) {
            return instance = new DirectoryCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidDirectoryCommand(input)) {
            return createInvalidCommand(CommandType.WILDCARD, input);
        }
        Builder builder = new Builder();
        return builder.build();
    }

    private boolean isValidDirectoryCommand(String input) {
        return isValidInput(input) && input.matches(Constants.REGEX_DIRECTORY);
    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/ExitCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.ExitCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;

/**
 * This class parses the Wildcard command input by the user. The Wildcard
 * command is in the format {Exit identifier} i.e. a singular word.
 *
 * @author Leonard Hio
 *
 */
public class ExitCommandParser extends AbstractCommandParser {
    public static ExitCommandParser instance;

    private ExitCommandParser() {
    }

    public static ExitCommandParser getInstance() {
        if (instance == null) {
            return instance = new ExitCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidExitCommand(input)) {
            return createInvalidCommand(CommandType.WILDCARD, input);
        }
        Builder builder = new Builder();
        return builder.build();
    }

    private boolean isValidExitCommand(String input) {
        return isValidInput(input) && input.matches(Constants.REGEX_EXIT);
    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/HelpCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.HelpCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;

/**
 * This class parses the Help command input by the user. The Help command is in
 * the format {Help identifier} i.e. a singular word.
 *
 * @author Leonard Hio
 *
 */
public class HelpCommandParser extends AbstractCommandParser {
    public static HelpCommandParser instance;

    private HelpCommandParser() {
    }

    public static HelpCommandParser getInstance() {
        if (instance == null) {
            return instance = new HelpCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidHelpCommand(input)) {
            return createInvalidCommand(CommandType.WILDCARD, input);
        }
        Builder builder = new Builder();
        return builder.build();
    }

    private boolean isValidHelpCommand(String input) {
        return isValidInput(input) && input.matches(Constants.REGEX_HELP);
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/ListCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.ListCommand;
import jfdi.logic.commands.ListCommand.ListType;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.exceptions.InvalidInputException;

/**
 * The ListCommandParser class is used to parse a user input String that
 * resembles a list command. All user inputs for listing tasks must adhere to
 * the following format: {list identifier} {completed | all | incomplete}. If
 * the {completed | all} field is unspecified, all incomplete tasks will by
 * default be displayed.
 *
 * @author Leonard Hio
 *
 */
public class ListCommandParser extends AbstractCommandParser {
    private static ListCommandParser instance;

    private ListCommandParser() {

    }

    public static ListCommandParser getInstance() {
        return instance == null ? instance = new ListCommandParser() : instance;
    }

    @Override
    /**
     * This method parses the user input (representing a list command) and
     * builds the ListCommand object.
     * @param input
     *            the user input String
     * @return the ListCommand object encapsulating the details of the list command.
     */
    public Command build(String input) {
        assert isValidInput(input)
            && matchesCommandType(input, CommandType.LIST);

        ListCommand.Builder builder = new ListCommand.Builder();
        ListType listType = null;
        try {
            listType = getListType(input);
        } catch (InvalidInputException e) {
            return createInvalidCommand(CommandType.LIST, input);
        }
        builder.setListType(listType);
        return builder.build();
    }

    /**
     * This method gets the type of the list, which corresponds to whether the
     * user wishes to list all tasks, or just those that are
     * completed/incomplete.
     *
     * @param input
     *            the list command input
     * @return the ListType specified in the command input
     * @throws InvalidInputException
     *             if no valid ListType is found
     */
    private ListType getListType(String input) throws InvalidInputException {
        input = removeFirstWord(input);
        if (input.isEmpty() || input.matches("(?i)Incomplete")) {
            return ListType.INCOMPLETE;
        } else if (input.matches("(?i)Completed")) {
            return ListType.COMPLETED;
        } else if (input.matches("(?i)All")) {
            return ListType.ALL;
        } else if (input.matches("(?i)Overdue")) {
            return ListType.OVERDUE;
        } else if (input.matches("(?i)Upcoming")) {
            return ListType.UPCOMING;
        } else {
            throw new InvalidInputException(input);
        }
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/MarkCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.Collection;
import java.util.HashSet;

import jfdi.logic.commands.MarkTaskCommand;
import jfdi.logic.commands.MarkTaskCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.exceptions.BadTaskIdException;

/**
 * The MarkCommandParser class is used to parse a given 'Mark' user input. The
 * 'Mark' user input is given by the user when there is a need to mark a task
 * (denoted by its taskID) as complete. Use this class in tandem with the
 * UnmarkCommandParser class to mark a task as complete to incomplete. The
 * format of an Unmark command is given by: {mark identifier} {task IDs}. Note
 * that task IDs can be represented as a range i.e. "1-10".
 *
 * @author Leonard Hio
 *
 */
public class MarkCommandParser extends AbstractCommandParser {

    public static MarkCommandParser instance;

    private MarkCommandParser() {

    }

    public static MarkCommandParser getInstance() {
        if (instance == null) {
            return instance = new MarkCommandParser();
        }

        return instance;
    }

    /**
     * This method builds a MarkCommand by extracting out the list of taskIDs
     * specfied to be marked as complete by the user and passing it into the
     * command builder.
     *
     * @param input
     *            the user input, representing a mark command.
     * @return a MarkTaskCommand object, or an InvalidCommand if any exceptions
     *         are thrown, or if the input is not in a valid mark format.
     *
     */
    @Override
    public Command build(String input) {
        assert isValidInput(input)
            && matchesCommandType(input, CommandType.MARK);

        if (!isValidMarkCommand(input)) {
            return createInvalidCommand(CommandType.MARK, input);
        }
        input = removeFirstWord(input);
        Builder markTaskCommandBuilder = new Builder();
        Collection<Integer> taskIds = new HashSet<>();
        try {
            taskIds = getTaskIds(input);
        } catch (BadTaskIdException e) {
            return createInvalidCommand(CommandType.MARK, input);
        }
        System.out.println(taskIds);
        markTaskCommandBuilder.addTaskIds(taskIds);
        MarkTaskCommand markTaskCommand = markTaskCommandBuilder.build();
        return markTaskCommand;
    }

    /**
     * Checks to see if the given input is in a valid Mark format.
     */
    private boolean isValidMarkCommand(String input) {
        return input.trim().matches(Constants.REGEX_MARK_FORMAT);
    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/MoveCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.MoveDirectoryCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;

/**
 * This class parses the 'Move' user command, which the user inputs whenever he
 * or she wishes to migrate from one directory to another. The format for this
 * command is a singular word i.e. {Mark identifier}.
 *
 * @author Leonard Hio
 *
 */
public class MoveCommandParser extends AbstractCommandParser {
    public static AbstractCommandParser instance;

    private MoveCommandParser() {

    }

    public static AbstractCommandParser getInstance() {
        if (instance == null) {
            return instance = new MoveCommandParser();
        }

        return instance;
    }

    @Override
    public Command build(String input) {
        Builder builder = new Builder();
        String directoryName = "";

        if (!isValidMoveInput(input)) {
            return createInvalidCommand(Constants.CommandType.MOVE, input);
        }

        directoryName = getDirectoryName(input);
        builder.setNewDirectory(directoryName);
        return builder.build();
    }

    private boolean isValidMoveInput(String input) {
        return isValidInput(input) && input.trim().split(Constants.REGEX_WHITESPACE).length >= 2
            && getFirstWord(input).matches(Constants.REGEX_MOVE);
    }

    private String getDirectoryName(String input) {
        assert isValidMoveInput(input);
        return removeFirstWord(input);
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/RenameCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jfdi.logic.commands.RenameTaskCommand;
import jfdi.logic.commands.RenameTaskCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.exceptions.BadTaskDescriptionException;
import jfdi.parser.exceptions.NoTaskIdFoundException;

/**
 * The RenameCommandParser class is used to parse user input String that
 * resembles a rename command. All user inputs for renaming tasks must adhere to
 * the following format: {rename identifier} {task ID} {new task description}
 *
 * @author leona_000
 *
 */
public class RenameCommandParser extends AbstractCommandParser {

    public static AbstractCommandParser instance;

    private RenameCommandParser() {

    }

    public static AbstractCommandParser getInstance() {
        if (instance == null) {
            return instance = new RenameCommandParser();
        }

        return instance;
    }

    /**
     * This method builds a RenameCommand by extracting out the task ID of the
     * task to be renamed, then its new task description, passing all these
     * information into a RenameCommand object.
     */
    @Override
    public Command build(String input) {
        if (!isValidRenameInput(input)) {
            return createInvalidCommand(CommandType.RENAME, input);
        }

        String originalInput = input;
        Builder renameCommandBuilder = new Builder();
        // Remove the rename command identifier.
        input = removeFirstWord(input);
        try {
            input = setAndRemoveTaskId(input, renameCommandBuilder);
            setTaskDescription(input, renameCommandBuilder);
        } catch (NoTaskIdFoundException | BadTaskDescriptionException e) {
            return createInvalidCommand(Constants.CommandType.RENAME, originalInput);
        }

        RenameTaskCommand renameCommand = renameCommandBuilder.build();
        return renameCommand;
    }

    /**
     * This method finds the task ID (if any) in the input, removes it from the
     * input, and adds the task ID to the rename command builder. If properly
     * called, the task ID should be located at index 0 of the input String.
     * This should be the case if the edit command identifier has been removed
     * beforehand. In the case where no task ID can be found, a NULL value is
     * added to the builder instead.
     *
     * @param input
     *            the user input String.
     * @param builder
     *            the rename command object builder.
     * @return the input String, without the task ID.
     */
    protected String setAndRemoveTaskId(String input, Builder builder) throws NoTaskIdFoundException {
        Pattern taskIdPattern = Pattern.compile(Constants.REGEX_TASKID);
        Matcher taskIdMatcher = taskIdPattern.matcher(input);

        // If the input is empty, or the matcher is unable to find a task ID,
        // then effectively the user input does not contain a task ID
        if (input.isEmpty() || !taskIdMatcher.find()) {
            throw new NoTaskIdFoundException(input);
        } else {
            assert taskIdMatcher.start() == 0;
            // The task ID for all rename command inputs should be the first
            // instance of all task ID instances found.
            String taskId = getTrimmedSubstringInRange(input, taskIdMatcher.start(), taskIdMatcher.end());
            builder.setId(toInteger(taskId));

            // Remove the task ID from the input
            input = getTrimmedSubstringInRange(input, taskIdMatcher.end(), input.length());
        }

        return input;
    }

    /**
     * This method finds the task description from the user input. If the
     * previous inputs were all properly executed, then the input itself should
     * be the task description.
     *
     * @param input
     *            the String including the task description.
     * @return the task description.
     * @throws BadTaskDescriptionException
     *             if the input is empty.
     */
    private String setTaskDescription(String input, Builder builder) throws BadTaskDescriptionException {
        if (!isValidInput(input)) {
            throw new BadTaskDescriptionException(input);
        }
        builder.setDescription(input);
        return input;
    }

    private boolean isValidRenameInput(String input) {
        return isValidInput(input) && getFirstWord(input).matches(Constants.REGEX_RENAME);

    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/RescheduleCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jfdi.logic.commands.RescheduleTaskCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.DateTimeObject;
import jfdi.parser.DateTimeParser;
import jfdi.parser.exceptions.BadDateTimeException;
import jfdi.parser.exceptions.NoTaskIdFoundException;

/**
 * The RescheduleCommandParser class is used to parse user input String that
 * resembles a reschedule command. All user inputs for renaming tasks must
 * adhere to the following format: {reschedule identifier} {task ID} to
 * (optional) {new task schedule}
 *
 * @author Leonard Hio
 *
 */
public class RescheduleCommandParser extends AbstractCommandParser {
    public static AbstractCommandParser instance;

    private RescheduleCommandParser() {

    }

    public static AbstractCommandParser getInstance() {
        if (instance == null) {
            return instance = new RescheduleCommandParser();
        }

        return instance;
    }

    /**
     * This method builds a RescheduleCommand by extracting out the task ID of
     * the task to be renamed, then its date time schedule, passing all these
     * information into a RenameCommand object.
     */
    @Override
    public Command build(String input) {
        if (!isValidRescheduleInput(input)) {
            return createInvalidCommand(CommandType.RESCHEDULE, input);
        }

        String originalInput = input;
        Builder rescheduleCommandBuilder = new Builder();
        // Remove the reschedule command identifier.
        input = removeFirstWord(input);
        try {
            input = setAndRemoveTaskId(input, rescheduleCommandBuilder);
            setTaskDateTime(input, rescheduleCommandBuilder);
        } catch (NoTaskIdFoundException | BadDateTimeException e) {
            return createInvalidCommand(Constants.CommandType.RESCHEDULE, originalInput);
        }

        setIsDateTimeSpecified(input, rescheduleCommandBuilder);

        Command rescheduleCommand = rescheduleCommandBuilder.build();
        return rescheduleCommand;
    }

    /**
     * This method finds the task ID (if any) in the input, removes it from the
     * input, and adds the task ID to the rename command builder. If properly
     * called, the task ID should be located at index 0 of the input String.
     * This should be the case if the edit command identifier has been removed
     * beforehand. In the case where no task ID can be found, a NULL value is
     * added to the builder instead.
     *
     * @param input
     *            the user input String.
     * @param rescheduleCommandBuilder
     *            the reschedule command object builder.
     * @return the input String, without the task ID.
     */
    protected String setAndRemoveTaskId(String input, Builder rescheduleCommandBuilder) throws NoTaskIdFoundException {
        assert input != null && rescheduleCommandBuilder != null;

        Pattern taskIdPattern = Pattern.compile(Constants.REGEX_TASKID);
        Matcher taskIdMatcher = taskIdPattern.matcher(input);

        // If the input is empty, or the matcher is unable to find a task ID,
        // then effectively the user input
        // does not contain a task ID
        if (!taskIdMatcher.find() || input.isEmpty()) {
            throw new NoTaskIdFoundException(input);
        } else {
            assert taskIdMatcher.start() == 0;
            // The task ID for all rename command inputs should be the first
            // instance of all task ID instances found.
            String taskId = getTrimmedSubstringInRange(input, taskIdMatcher.start(), taskIdMatcher.end());
            rescheduleCommandBuilder.setId(toInteger(taskId));

            // Remove the task ID from the input
            input = getTrimmedSubstringInRange(input, taskIdMatcher.end(), input.length());
        }

        return input;
    }

    /**
     * This method finds the date time fields from the user input, and adds them
     * to the RescheduleCommand object builder. If the previous inputs were all
     * properly executed, then the input itself should be the task date time
     * fields.
     *
     * @param input
     *            the String that corresponds to the new task date time.
     * @return the input String.
     */
    private String setTaskDateTime(String input, Builder builder) throws BadDateTimeException {
        assert input != null && builder != null;

        if (input.isEmpty()) {
            // No date time specified: user does not want any date/time
            // restrictions on task
            return input;
        }

        DateTimeParser dateTimeParser = DateTimeParser.getInstance();

        String dateTimeString = input;
        // The 'to' keyword needs special attention as it can change either
        // start or end date time depending on the current task type of the task
        if (input.matches("(to )?" + Constants.REGEX_DATE_TIME_FORMAT)) {
            if (input.matches("(to )" + Constants.REGEX_DATE_TIME_FORMAT)) {
                dateTimeString = getTrimmedSubstringInRange(input, 3, input.length());
            }

            DateTimeObject dateTimeObject = dateTimeParser.parseDateTime(dateTimeString);

            // Since we are parsing an input that strictly matches
            // DATE_TIME_FORMAT, dateTimeString should be parsed as a point
            // task, with only start date time.
            assert dateTimeObject.getTaskType().equals(Constants.TaskType.POINT);
            assert dateTimeObject.getStartDateTime() != null && dateTimeObject.getEndDateTime() == null;
            builder.setShiftedDateTime(dateTimeObject.getStartDateTime());

        } else if (input.matches(Constants.REGEX_POINT_TASK_IDENTIFIER + "|" + Constants.REGEX_DEADLINE_IDENTIFIER
            + "|" + Constants.REGEX_EVENT_IDENTIFIER + "|(to " + Constants.REGEX_DATE_TIME_FORMAT + " to "
            + Constants.REGEX_DATE_TIME_FORMAT + ")")) {

            if (input.matches("to " + Constants.REGEX_DATE_TIME_FORMAT + " to " + Constants.REGEX_DATE_TIME_FORMAT)) {
                dateTimeString = input.replaceAll("^to ", "from ");
            }
            System.out.println(dateTimeString);

            // If the input explicitly specifies a deadline, event, or point
            // task, then set start/end date time accordingly
            DateTimeObject dateTimeObject = DateTimeParser.getInstance().parseDateTime(dateTimeString);
            builder.setStartDateTime(dateTimeObject.getStartDateTime());
            builder.setEndDateTime(dateTimeObject.getEndDateTime());
        } else {
            throw new BadDateTimeException(input);
        }

        return input;
    }

    /**
     * This method sets the relevant boolean flags to true according to if the
     * input contains a date or a time or both.
     *
     * @param input
     *            the input on which checks are made to see if it contains a
     *            date, time or both.
     * @param rescheduleCommandBuilder
     *            the RescheduleCommandBuilder object.
     */
    private void setIsDateTimeSpecified(String input, Builder rescheduleCommandBuilder) {
        Pattern pattern = Pattern.compile(Constants.REGEX_TIME_FORMAT);
        Matcher matcher = pattern.matcher(input);
        if (matcher.find()) {
            rescheduleCommandBuilder.setShiftedTimeSpecified(true);
        }

        pattern = Pattern.compile(Constants.REGEX_DATE_FORMAT + "|" + Constants.REGEX_TIME_RELATIVE);
        matcher = pattern.matcher(input);
        if (matcher.find()) {
            rescheduleCommandBuilder.setShiftedDateSpecified(true);
        }

    }

    private boolean isValidRescheduleInput(String input) {
        return isValidInput(input) && getFirstWord(input).matches(Constants.REGEX_RESCHEDULE);
    }
}
```
###### ./src/main/java/jfdi/parser/commandparsers/SearchCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;

import jfdi.logic.commands.SearchCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.exceptions.InvalidInputException;

/**
 * The SearchCommandParser class is used to parse a user input that represents a
 * search command. The search input format is: {search identifier} {keywords}.
 *
 * @author Leonard Hio
 *
 */
public class SearchCommandParser extends AbstractCommandParser {
    private static SearchCommandParser instance;

    private SearchCommandParser() {

    }

    public static SearchCommandParser getInstance() {
        return instance == null ? instance = new SearchCommandParser() : instance;
    }

    @Override
    /**
     * This method parses the user input (representing a search command) and
     * builds the SearchCommand object.
     * @param input
     *            the user input String
     * @return the SearchCommand object encapsulating the keywords of the search command.
     */
    public Command build(String input) {

        if (!isValidSearchInput(input)) {
            return createInvalidCommand(CommandType.SEARCH, input);
        }

        SearchCommand.Builder builder = new SearchCommand.Builder();
        Collection<String> keywords = new HashSet<String>();
        try {
            keywords = getKeywords(input);
        } catch (InvalidInputException e) {
            return createInvalidCommand(CommandType.SEARCH, input);
        }
        builder.addKeywords(keywords);
        return builder.build();
    }

    /**
     * This method returns a list of keywords that can be extracted from the
     * given input.
     *
     * @param input
     *            the input string.
     * @return a Collection of keywords found.
     * @throws InvalidInputException
     *             if no keywords are specified in the input, or if the input is
     *             empty to begin with.
     */
    private Collection<String> getKeywords(String input) throws InvalidInputException {
        assert isValidSearchInput(input);

        String[] keywords = input.split(Constants.REGEX_WHITESPACE);
        if (keywords.length <= 1) {
            throw new InvalidInputException(input);
        }
        List<String> keywordsAsList = new ArrayList<>();
        for (int i = 1; i < keywords.length; i++) {
            keywordsAsList.add(keywords[i]);
        }

        return keywordsAsList;
    }

    private boolean isValidSearchInput(String input) {
        return isValidInput(input) && getFirstWord(input).matches(Constants.REGEX_SEARCH);
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/UnaliasCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.UnaliasCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;

/**
 * The UnaliasCommandParser class takes in a user input representing an "Alias"
 * command and parses it into an UnaliasCommand object. This UnaliasCommand
 * object will then contain the alias that is to be removed from the list of
 * aliases. All unalias user commands must be in the format:
 * "{unalias identifier} {alias}"
 *
 * @author Leonard Hio
 *
 */
public class UnaliasCommandParser extends AbstractCommandParser {
    public static UnaliasCommandParser instance;

    private UnaliasCommandParser() {
    }

    public static UnaliasCommandParser getInstance() {
        if (instance == null) {
            return instance = new UnaliasCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidFormat(input)) {
            return createInvalidCommand(Constants.CommandType.UNALIAS, input);
        }

        Builder builder = new Builder();
        String alias = null;

        alias = getAlias(input);

        builder.setAlias(alias);

        return builder.build();
    }

    /**
     * This method checks the validity of the unalias user input. The input is
     * considered valid if it begins with an 'unalias' keyword and is exactly 2
     * words long.
     *
     * @param input
     *            is the user unalias input.
     * @return true if the unalias input is valid; false otherwise.
     */
    private boolean isValidFormat(String input) {
        if (input == null) {
            return false;
        }
        String[] inputAsArray = input.split(Constants.REGEX_WHITESPACE);
        return inputAsArray.length == 2 && inputAsArray[0].matches(Constants.REGEX_UNALIAS);
    }

    /**
     * This method attempts to retrive the alias to be removed from the input,
     * making sure that the alias found is in the list of existing aliases in
     * the first place.
     *
     * @param input
     *            the input string from which the alias that is to be removed is
     *            found.
     * @return the alias to be removed.
     */
    private String getAlias(String input) {
        assert isValidFormat(input);

        String alias = getSecondWord(input);
        return alias;
    }

    private String getSecondWord(String input) {
        return input.split(Constants.REGEX_WHITESPACE)[1];
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/UndoCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.UndoCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;

/**
 * This class parses the Undo command input by the user. The Undo command is in
 * the format {Undo identifier} i.e. a singular word.
 *
 * @author Leonard Hio
 *
 */
public class UndoCommandParser extends AbstractCommandParser {
    public static UndoCommandParser instance;

    private UndoCommandParser() {
    }

    public static UndoCommandParser getInstance() {
        if (instance == null) {
            return instance = new UndoCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidUndoCommand(input)) {
            return createInvalidCommand(CommandType.WILDCARD, input);
        }
        Builder builder = new Builder();
        return builder.build();
    }

    private boolean isValidUndoCommand(String input) {
        return isValidInput(input) && input.matches(Constants.REGEX_UNDO);
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/UnmarkCommandParser.java
``` java

package jfdi.parser.commandparsers;

import java.util.Collection;
import java.util.HashSet;

import jfdi.logic.commands.UnmarkTaskCommand;
import jfdi.logic.commands.UnmarkTaskCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.exceptions.BadTaskIdException;

/**
 * The UnmarkCommandParser class is used to parse a given 'Unmark' user input.
 * The 'Unmark' user input is given by the user when there is a need to mark a
 * task (denoted by its taskID) as incomplete. Use this class in tandem with the
 * MarkCommandParser class to mark a task as incomplete to complete. The format
 * of an Unmark command is given by: {unmark identifier} {task IDs}. Note that
 * task IDs can be represented as a range i.e. "1-10".
 *
 * @author Leonard Hio
 *
 */
public class UnmarkCommandParser extends AbstractCommandParser {

    public static UnmarkCommandParser instance;

    private UnmarkCommandParser() {

    }

    public static UnmarkCommandParser getInstance() {
        if (instance == null) {
            return instance = new UnmarkCommandParser();
        }

        return instance;
    }

    /**
     * This method builds an UnmarkCommand by extracting out the list of taskIDs
     * specfied to be marked as incomplete by the user and passing it into the
     * command builder.
     *
     * @param input
     *            the user input, representing an unmark command.
     * @return an UnmarkTaskCommand object, or an InvalidCommand if any
     *         exceptions are thrown, or if the input is not in a valid Unmark
     *         format.
     *
     */
    @Override
    public Command build(String input) {
        assert isValidInput(input)
            && matchesCommandType(input, CommandType.UNMARK);

        if (!isValidUnmarkCommand(input)) {
            return createInvalidCommand(CommandType.UNMARK, input);
        }
        input = removeFirstWord(input);
        Builder unmarkTaskCommandBuilder = new Builder();
        Collection<Integer> taskIds = new HashSet<>();
        try {
            taskIds = getTaskIds(input);
        } catch (BadTaskIdException e) {
            return createInvalidCommand(CommandType.UNMARK, input);
        }
        unmarkTaskCommandBuilder.addTaskIds(taskIds);
        UnmarkTaskCommand unmarkTaskCommand = unmarkTaskCommandBuilder.build();
        return unmarkTaskCommand;
    }

    /**
     * Checks to see if the given input is in a valid Unmark format.
     */
    private boolean isValidUnmarkCommand(String input) {
        return input.trim().matches(Constants.REGEX_UNMARK_FORMAT);
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/UseCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.UseDirectoryCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;

/**
 * This class parses the 'Use' user command, which the user inputs whenever he
 * or she wishes to load tasks from another directory. The user input should
 * follow the format: {Use command} {Directory}
 *
 * @author Leonard Hio
 *
 */
public class UseCommandParser extends AbstractCommandParser {
    public static AbstractCommandParser instance;

    private UseCommandParser() {

    }

    public static AbstractCommandParser getInstance() {
        if (instance == null) {
            return instance = new UseCommandParser();
        }

        return instance;
    }

    /**
     * This method builds a UseCommand from the given input.
     */
    @Override
    public Command build(String input) {
        if (!isValidUseInput(input)) {
            return createInvalidCommand(CommandType.USE, input);
        }

        String directoryName = getDirectoryName(input);

        Builder builder = new Builder();
        builder.setNewDirectory(directoryName);

        return builder.build();
    }

    private boolean isValidUseInput(String input) {
        return isValidInput(input) && input.trim().split(Constants.REGEX_WHITESPACE).length >= 2
            && getFirstWord(input).matches(Constants.REGEX_USE);
    }

    private String getDirectoryName(String input) {
        assert isValidInput(input);
        return removeFirstWord(input);
    }

}
```
###### ./src/main/java/jfdi/parser/commandparsers/WildcardCommandParser.java
``` java

package jfdi.parser.commandparsers;

import jfdi.logic.commands.WildcardCommand.Builder;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.Constants.CommandType;

/**
 * This class parses the Wildcard command input by the user. The Wildcard
 * command is in the format {Wildcard identifier} i.e. a singular word.
 *
 * @author Leonard Hio
 *
 */
public class WildcardCommandParser extends AbstractCommandParser {
    public static WildcardCommandParser instance;

    private WildcardCommandParser() {
    }

    public static WildcardCommandParser getInstance() {
        if (instance == null) {
            return instance = new WildcardCommandParser();
        }
        return instance;
    }

    @Override
    public Command build(String input) {
        if (!isValidWildCardCommand(input)) {
            return createInvalidCommand(CommandType.WILDCARD, input);
        }
        Builder builder = new Builder();
        return builder.build();
    }

    private boolean isValidWildCardCommand(String input) {
        return isValidInput(input) && input.matches(Constants.REGEX_WILDCARD);
    }

}
```
###### ./src/main/java/jfdi/parser/Constants.java
``` java

package jfdi.parser;

import java.time.ZoneId;

/**
 * The Constants class is a database of all relevant constants used for parsing.
 * These constants include Regex constants that define date time formats,
 * command formats, and other miscellaneous formats.
 *
 * @author Leonard Hio
 *
 */
public class Constants {

    // ===============================
    // Regex Constants
    // ===============================

    // General Regex Strings
    public static final String REGEX_WHITESPACE = "\\s";
    public static final String REGEX_DESCRIPTION_ESCAPE_DELIMITER = "\"";

    // Task type specific Regex Strings
    public static final String REGEX_ADD = "(?i)^(add)";
    public static final String REGEX_LIST = "(?i)^(list)";
    public static final String REGEX_RENAME = "(?i)^(rename)";
    public static final String REGEX_RESCHEDULE = "(?i)^(reschedule)";
    public static final String REGEX_DELETE = "(?i)^(delete|remove)";
    public static final String REGEX_SEARCH = "(?i)^(search)";
    public static final String REGEX_MARK = "(?i)^(mark)";
    public static final String REGEX_UNMARK = "(?i)^(unmark)";
    public static final String REGEX_ALIAS = "(?i)^(alias)";
    public static final String REGEX_UNALIAS = "(?i)^(unalias)";
    public static final String REGEX_DIRECTORY = "(?i)^(directory)";
    public static final String REGEX_USE = "(?i)^(use)";
    public static final String REGEX_MOVE = "(?i)^(move)";
    public static final String REGEX_UNDO = "(?i)^(undo)";
    public static final String REGEX_HELP = "(?i)^(help)";
    public static final String REGEX_WILDCARD = "(?i)^(surprise[!]*)";
    public static final String REGEX_EXIT = "(?i)^(exit|quit)";

    // Task related Regex Strings
    public static final String REGEX_DELETE_FORMAT = String
        .format("%s ((\\d+|\\d+[ ]*-[ ]*\\d+),?[ ]*)+", REGEX_DELETE);
    public static final String REGEX_MARK_FORMAT = String.format("%s ((\\d+|\\d+[ ]*-[ ]*\\d+),?[ ]*)+", REGEX_MARK);
    public static final String REGEX_UNMARK_FORMAT = String
        .format("%s ((\\d+|\\d+[ ]*-[ ]*\\d+),?[ ]*)+", REGEX_UNMARK);

    // A taskID is simply an integer
    public static final String REGEX_TASKID = "\\b\\d+\\b";

    // Date and Time related Regex Strings
    public static final String REGEX_DAYS_NUMERIC = "(((?i)0?[1-9]|[12][\\d]|3[01])(st|th|nd|rd)?)";
    public static final String REGEX_DAYS_TEXTUAL = "((?i)(mon)(day)?|" + "(tue)(s|sday)?|" + "(wed)(s|nesday)?|"
        + "(thu)(r|rs|rsday)?|" + "(fri)(day)?|" + "(sat)(urday)?|" + "(sun)(day)?)";
    public static final String REGEX_MONTHS_NUMERIC = "(0?[1-9]|1[0-2])";
    public static final String REGEX_MONTHS_TEXTUAL = "((?i)(jan)(uary)?|" + "(feb)(ruary)?|" + "(mar)(ch)?|"
        + "(apr)(il)?|" + "(may)|" + "(jun)(e)?|" + "(jul)(y)?|" + "(aug)(ust)?|" + "(sep)(tember)?|" + "(oct)(ober)?|"
        + "(nov)(ember)?|" + "(dec)(ember)?)";
    public static final String REGEX_YEARS = "((19|20)?\\d\\d)";
    public static final String REGEX_DATE_ATTRIBUTES = "(?i)((day|(week|wk)|(month|mth)|(year|yr))(s)?)";
    public static final String REGEX_TIME_ATTRIBUTES = "(?i)(((sec|second)|(min|minute)|(hr|hour))(s)?)";
    public static final String REGEX_TIME_MILITARY = "(?i)([0-1][0-9]|[2][0-4])[.:]?[0-5][\\d]([h]([r][s]?)?)";
    public static final String REGEX_TIME_NORMAL = "(?i)(0?[1-9]|1[0-2])([.:]?([0-5][0-9]))?[ :]?([a|p][m])";
    public static final String REGEX_TIME_RELATIVE = "((?i)((this )?(morning|afternoon|evening)|(to)?night|midnight))";

    public static final String REGEX_DATE_RELATIVE_1 = "(?i)(tomorrow|yesterday|today|now)";
    public static final String REGEX_DATE_RELATIVE_2 = String.format(
        "(?i)((((the )?next|this|last) %s)|((the )?next |this |last )?%s)", REGEX_DATE_ATTRIBUTES, REGEX_DAYS_TEXTUAL);
    public static final String REGEX_DATE_RELATIVE_3 = String.format(
        "(\\d+ (%s|%s) (?i)(later|before|after|from now))", REGEX_DATE_ATTRIBUTES, REGEX_TIME_ATTRIBUTES);
    public static final String REGEX_DATE_RELATIVE_4 = String.format("(?i)(in )?\\d+ (%s|%s)'?( time)?",
        REGEX_TIME_ATTRIBUTES, REGEX_DATE_ATTRIBUTES);

    public static final String REGEX_DATE_RELATIVE = String.format("(%s|%s|%s|%s)", REGEX_DATE_RELATIVE_1,
        REGEX_DATE_RELATIVE_2, REGEX_DATE_RELATIVE_3, REGEX_DATE_RELATIVE_4);

    public static final String REGEX_DATE_ABSOLUTE_DDMMYYYY = String.format("\\b%s[-/.]%s([-/.]%s)?\\b",
        REGEX_DAYS_NUMERIC, REGEX_MONTHS_NUMERIC, REGEX_YEARS);
    public static final String REGEX_DATE_ABSOLUTE_DDMONTHYYYY = String.format("\\b%s[-/. ]%s([-/. ]%s)?\\b",
        REGEX_DAYS_NUMERIC, REGEX_MONTHS_TEXTUAL, REGEX_YEARS);

    // Formats for date, time, and date-time in Regex (built from date and time
    // related Regex Strings)
    public static final String REGEX_DATE_FORMAT = String.format("(%s|%s|%s)", REGEX_DATE_ABSOLUTE_DDMMYYYY,
        REGEX_DATE_ABSOLUTE_DDMONTHYYYY, REGEX_DATE_RELATIVE);
    public static final String REGEX_TIME_FORMAT = String.format("(%s|%s|%s)", REGEX_TIME_MILITARY, REGEX_TIME_NORMAL,
        REGEX_TIME_RELATIVE);
    public static final String REGEX_DATE_TIME_FORMAT_DATE_FIRST = String.format("(%s,? %s)", REGEX_DATE_FORMAT,
        REGEX_TIME_FORMAT);
    public static final String REGEX_DATE_TIME_FORMAT_DATE_FIRST_WITH_NAMED_GROUPS = String.format(
        "((?<date1>%s),? (?<time1>%s))", REGEX_DATE_FORMAT, REGEX_TIME_FORMAT);
    public static final String REGEX_DATE_TIME_FORMAT_TIME_FIRST = String.format("(%s,? %s)", REGEX_TIME_FORMAT,
        REGEX_DATE_FORMAT);
    public static final String REGEX_DATE_TIME_FORMAT_TIME_FIRST_WITH_NAMED_GROUPS = String.format(
        "((?<time2>%s),? (?<date2>%s))", REGEX_TIME_FORMAT, REGEX_DATE_FORMAT);
    public static final String REGEX_DATE_TIME_FORMAT = String.format("(%s|%s|%s|%s)", REGEX_DATE_FORMAT,
        REGEX_TIME_FORMAT, REGEX_DATE_TIME_FORMAT_DATE_FIRST, REGEX_DATE_TIME_FORMAT_TIME_FIRST);

    // Regex used to detect date-time fields in the user's input String
    public static final String REGEX_DEADLINE_IDENTIFIER = String.format("(?i)\\b(by|before) %s",
        REGEX_DATE_TIME_FORMAT);
    public static final String REGEX_EVENT_IDENTIFIER = String.format("(?i)\\b((from )?%s (to|until) %s)",
        REGEX_DATE_TIME_FORMAT, REGEX_DATE_TIME_FORMAT);
    public static final String REGEX_POINT_TASK_IDENTIFIER = String.format("(?i)\\b(on |at )?%s",
        REGEX_DATE_TIME_FORMAT);
    public static final String REGEX_DATE_TIME_IDENTIFIER = String.format("(%s|%s|%s)", REGEX_DEADLINE_IDENTIFIER,
        REGEX_EVENT_IDENTIFIER, REGEX_POINT_TASK_IDENTIFIER);

    // =============================
    // Non-Regex constants
    // =============================

    // A task can be any one of these task types
    public enum TaskType {
        FLOATING,
        DEADLINE,
        EVENT,
        POINT,
        REPEATED;
    }

    // An enum containing all the commands available to the user
    public enum CommandType {
        ADD,
        DELETE,
        RENAME,
        RESCHEDULE,
        LIST,
        SEARCH,
        MARK,
        UNMARK,
        ALIAS,
        UNALIAS,
        DIRECTORY,
        MOVE,
        USE,
        UNDO,
        HELP,
        WILDCARD,
        INVALID,
        EXIT;
    }

    public static final int INDEX_ACTION = 0;

    /**
     * A class to encapsulate the fields associated with time, such as the hour,
     * the minute, etc.
     *
     * @author Leonard Hio
     *
     */
    public static class Time {
        public static final int MIN_HOUR = 0;
        public static final int MIN_MINUTES = 0;
        public static final int MIN_SECONDS = 0;
        public static final int MIN_NANOSECONDS = 0;
        public static final int MAX_HOUR = 23;
        public static final int MAX_MINUTES = 59;
        public static final int MAX_SECONDS = 59;
        public static final int MAX_NANOSECONDS = 999999999;
        public static final int DEFAULT_HOUR = 12;
        public static final int DEFAULT_MINUTES = 0;
        public static final int DEFAULT_SECONDS = 0;
        public static final int DEFAULT_NANOSECONDS = 0;

        public int hour;
        public int minutes;
        public int seconds;
        public int nanoseconds;

        public Time(int hour, int minutes, int seconds, int nanoseconds) {
            this.hour = hour;
            this.minutes = minutes;
            this.seconds = seconds;
            this.nanoseconds = nanoseconds;
        }
    }

    public static final Time TIME_BEGINNING_OF_DAY = new Time(Time.MIN_HOUR, Time.MIN_MINUTES, Time.MIN_SECONDS,
        Time.MIN_NANOSECONDS);
    public static final Time TIME_END_OF_DAY = new Time(Time.MAX_HOUR, Time.MAX_MINUTES, Time.MAX_SECONDS,
        Time.MAX_NANOSECONDS);
    public static final Time TIME_DEFAULT = new Time(Time.DEFAULT_HOUR, Time.DEFAULT_MINUTES, Time.DEFAULT_SECONDS,
        Time.DEFAULT_NANOSECONDS);

    // The current time zone of the system, used to find LocalDateTime when
    // parsing dates
    public static final ZoneId ZONE_ID = ZoneId.systemDefault();

    private static final String[] COMMAND_REGEXES = {REGEX_ADD, REGEX_LIST, REGEX_RENAME, REGEX_RENAME,
        REGEX_RESCHEDULE, REGEX_DELETE, REGEX_SEARCH, REGEX_MARK, REGEX_UNMARK, REGEX_ALIAS, REGEX_UNALIAS,
        REGEX_DIRECTORY, REGEX_USE, REGEX_MOVE, REGEX_UNDO, REGEX_HELP, REGEX_WILDCARD, REGEX_EXIT};

    public static String[] getCommandRegexes() {
        return COMMAND_REGEXES;
    }
}
```
###### ./src/main/java/jfdi/parser/DateTimeObject.java
``` java

package jfdi.parser;

import java.time.LocalDateTime;

import jfdi.parser.Constants.TaskType;

/**
 * The DateTimeObject class encapsulates all the information relevant to the
 * datetime field of a user's input. This includes the task type (floating,
 * event, etc), the values of the start and end date time specified, and so on.
 * Creating a DateTimeObject should only be done through the Builder subclass.
 *
 * @author Leonard Hio
 *
 */
public class DateTimeObject {

    private TaskType taskType;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;

    public DateTimeObject(DateTimeObjectBuilder builder) {
        this.taskType = builder.taskType;
        this.startDateTime = builder.startDateTime;
        this.endDateTime = builder.endDateTime;
    }

    public TaskType getTaskType() {
        return taskType;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public static class DateTimeObjectBuilder {
        private TaskType taskType = null;
        private LocalDateTime startDateTime = null;
        private LocalDateTime endDateTime = null;

        public DateTimeObjectBuilder setTaskType(TaskType t) {
            this.taskType = t;
            return this;
        }

        public DateTimeObjectBuilder setStartDateTime(LocalDateTime ldt) {
            this.startDateTime = ldt;
            return this;
        }

        public DateTimeObjectBuilder setEndDateTime(LocalDateTime ldt) {
            this.endDateTime = ldt;
            return this;
        }

        public DateTimeObject build() {
            return new DateTimeObject(this);
        }
    }
}
```
###### ./src/main/java/jfdi/parser/DateTimeParser.java
``` java

package jfdi.parser;

import java.time.LocalDateTime;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jfdi.common.utilities.JfdiLogger;
import jfdi.parser.Constants.TaskType;
import jfdi.parser.DateTimeObject.DateTimeObjectBuilder;
import jfdi.parser.exceptions.BadDateTimeException;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * DateTimeParser is a class used to parse a String input into one a list of
 * LocalDateTime objects it represents. It supports parsing Strings of different
 * formats. For example, it can parse "by 23rd February 2015" or "from 23/02/15
 * 2359hrs to 29/03/16 09:40pm". For an idea of the format of String parseable,
 * see parser.Constants.java.
 *
 * @author Leonard Hio
 *
 */
public class DateTimeParser {
    private static DateTimeParser dateTimeParser;
    private static final String SOURCECLASS = DateTimeParser.class.getName();
    private static final Logger LOGGER = JfdiLogger.getLogger();
    private String originalInput = "";

    public static DateTimeParser getInstance() {
        return dateTimeParser == null ? dateTimeParser = new DateTimeParser() : dateTimeParser;
    }

    /**
     * This method parses the given input String into a DateTimeObject.
     *
     * @param input
     *            a String that should match the date-time format listed in
     *            parser.Constants.java.
     * @return a DateTimeObject encapsulating the details of the input date time
     *         String.
     * @throws a
     *             BadDateTimeException if the input String doesn't match a
     *             valid date time format.
     */
    public DateTimeObject parseDateTime(String input) throws BadDateTimeException {
        if (!isValidDateTime(input)) {
            LOGGER.throwing(SOURCECLASS, "parseDateTime", new BadDateTimeException(input));
            throw new BadDateTimeException(input);
        }
        originalInput = input;
        DateTimeObject dateTimeObject = buildDateTimeObject(input);

        return dateTimeObject;
    }

    // =========================================
    // First Level of Abstraction
    // =========================================

    /**
     * This method builds a DateTimeObject from a given String input. An 'event'
     * type task will have both start and end date time. A 'point' task will
     * only have a start date time and NULL end date time. A 'deadline' task
     * will only have an end date time and NULL start date time. A 'floating'
     * task will have neither.
     *
     * @param input
     *            a String that contains date time fields
     * @return a DateTimeObject.
     * @throws BadDateTimeException
     *             if the start date parsed is later than the end date parsed.
     */
    private DateTimeObject buildDateTimeObject(String input) throws BadDateTimeException {
        assert isValidDateTime(input);
        DateTimeObjectBuilder dateTimeObjectBuilder = new DateTimeObjectBuilder();

        TaskType taskType = getTaskType(input);
        input = formatDateTimeInput(input);

        LocalDateTime startDateTime = null;
        LocalDateTime endDateTime = null;

        LocalDateTime[] startEndDateTime = new LocalDateTime[2];

        setStartEndDateTime(startEndDateTime, input, taskType);

        dateTimeObjectBuilder.setTaskType(taskType);
        dateTimeObjectBuilder.setStartDateTime(startEndDateTime[0]);
        dateTimeObjectBuilder.setEndDateTime(startEndDateTime[1]);

        DateTimeObject dateTimeObject = dateTimeObjectBuilder.build();

        return dateTimeObject;
    }

    private String formatDateTimeInput(String input) {
        assert isValidDateTime(input);
        input = formatDate(input);
        input = formatTime(input);
        input = toAmericanTime(input);
        return input;
    }

    // =========================================
    // Second Level of Abstraction
    // =========================================

    /**
     * This method formats the dates in the given date-time input into something
     * readable by the underlying date-time parser.
     *
     * @param input
     *            the date-time input.
     * @return the formatted String.
     */
    private String formatDate(String input) {

        input = input.replaceAll(Constants.REGEX_DATE_TIME_FORMAT_DATE_FIRST_WITH_NAMED_GROUPS, "${time1}, ${date1}");
        input = input.replaceAll(Constants.REGEX_DATE_TIME_FORMAT_TIME_FIRST_WITH_NAMED_GROUPS, "${time2}, ${date2}");
        input =
            input.replaceAll("\\b(?<days>" + Constants.REGEX_DAYS_NUMERIC + ")[-/. ](?<months>"
                + Constants.REGEX_MONTHS_TEXTUAL + ")[-/. ]" + "(?<year>\\d\\d)\\b", "${days} ${months} 20${year}");
        StringBuilder inputBuilder = new StringBuilder(input);
        Pattern dateFormatPattern = Pattern.compile(Constants.REGEX_DATE_ABSOLUTE_DDMMYYYY);
        Matcher dateFormatMatcher = dateFormatPattern.matcher(input);
        while (dateFormatMatcher.find()) {
            int start = dateFormatMatcher.start();
            int end = dateFormatMatcher.end();
            inputBuilder.replace(start, end, inputBuilder.substring(start, end).replaceAll("[.-]", "/"));
        }

        Pattern dateFormatPattern2 = Pattern.compile(Constants.REGEX_DATE_ABSOLUTE_DDMONTHYYYY);
        Matcher dateFormatMatcher2 = dateFormatPattern2.matcher(input);
        while (dateFormatMatcher2.find()) {
            int start = dateFormatMatcher2.start();
            int end = dateFormatMatcher2.end();
            inputBuilder.replace(start, end, inputBuilder.substring(start, end).replaceAll("[./-]", " "));
        }

        return inputBuilder.toString();
    }

    /**
     * This method formats the times in the given date-time input into something
     * readable by the underlying date-time parser.
     *
     * @param input
     *            the date-time input.
     * @return the formatted String.
     */
    private String formatTime(String input) {
        input = input.replaceAll("(?i)(0?[1-9]|1[0-2])([0-5][0-9])([ :]?([a|p][m]))", "$1.$2$3");
        return input;
    }

    /**
     * This method extracts the start date time and end date time found in the
     * input and sets the startEndDateTime array to its correct LocalDateTime
     * value.
     *
     * @param startEndDateTime
     *            the array of length 2 where startEndDateTime[0] stores the
     *            start date time and startEndDateTime[1] stores the end date
     *            time.
     * @param input
     *            the string input from which date times are to be extracted.
     * @param taskType
     *            determines whether the type of the task is to be event, point,
     *            floating, etc.
     * @throws BadDateTimeException
     *             if the end date time is earlier than the start date time.
     */
    private void setStartEndDateTime(LocalDateTime[] startEndDateTime, String input, TaskType taskType)
        throws BadDateTimeException {
        assert startEndDateTime.length == 2;

        switch (taskType) {
            case EVENT:
                String[] splitInput = input.split("\\bto\\b");
                String[] splitOriginalInput = originalInput.split("\\bto\\b");
                assert splitInput.length == 2;
                startEndDateTime[0] = getLocalDateTime(splitInput[0]);
                startEndDateTime[1] = getLocalDateTime(splitInput[1]);
                if (!checkTimeSpecified(originalInput)) {
                    startEndDateTime[0] = setTime(startEndDateTime[0], Constants.TIME_BEGINNING_OF_DAY);
                    startEndDateTime[1] = setTime(startEndDateTime[1], Constants.TIME_END_OF_DAY);
                } else {
                    if (!checkTimeSpecified(splitOriginalInput[0])) {
                        startEndDateTime[0] = setTime(startEndDateTime[0], Constants.TIME_DEFAULT);
                    }
                    if (!checkTimeSpecified(splitOriginalInput[1])) {
                        startEndDateTime[1] = setTime(startEndDateTime[1], Constants.TIME_DEFAULT);
                    }
                    if (!checkDateSpecified(splitOriginalInput[1])) {
                        startEndDateTime[1] = setDate(startEndDateTime[1], startEndDateTime[0]);
                    }
                }
                if (startEndDateTime[0].compareTo(startEndDateTime[1]) > 0) {
                    LOGGER.throwing(SOURCECLASS, "buildDateTimeObject", new BadDateTimeException(input));
                    throw new BadDateTimeException(input);
                }
                break;
            case POINT:
                startEndDateTime[0] = getLocalDateTime(input);
                if (!checkTimeSpecified(input)) {
                    startEndDateTime[0] = setTime(startEndDateTime[0], Constants.TIME_DEFAULT);
                }
                break;
            case DEADLINE:
                startEndDateTime[1] = getLocalDateTime(input);
                if (!checkTimeSpecified(input)) {
                    startEndDateTime[1] = setTime(startEndDateTime[1], Constants.TIME_DEFAULT);
                }
                break;
            default:
                break;
        }
    }

    /**
     * This method converts dates of the form {day}/{month}/{year} to
     * {month}/{day}/{year}. This has to be done because the underlying parsing
     * library, prettyTime, can only parse American dates.
     *
     * @param input
     *            the date time String to be parsed.
     * @return the same input String, except with day and month reversed, if
     *         any.
     */
    private String toAmericanTime(String input) {
        assert isValidDateTime(input);

        return input.replaceAll("\\b(?<day>0?[1-9]|[12][\\d]|3[01])(?<delimiter1>[-/.])"
            + "(?<month>0?[1-9]|1[0-2])((?<delimiter2>[-/.])(?<year>(19|20)?\\d\\d))?\\b",
            "${month}${delimiter1}${day}${delimiter2}${year}");
    }

    /**
     * This method parses the input String into a list of Dates.
     *
     * @param input
     *            the input String representing a date time.
     * @return a list of Date objects, storing information about the date and
     *         time specified in the String.
     */
    private LocalDateTime getLocalDateTime(String input) {
        assert input != null;
        Parser parser = new Parser();
        List<DateGroup> dateList = parser.parse(input);
        assert dateList.size() == 1;
        return getLocalDateTimeFromDate(dateList.get(0).getDates().get(0));
    }

    /**
     * This method checks to see if a time is specified in the date time String.
     *
     * @param input
     *            a date time String.
     * @return true if time is specified; false otherwise.
     */
    private boolean checkTimeSpecified(String input) {
        Pattern pattern = Pattern.compile(Constants.REGEX_TIME_FORMAT + "|" + Constants.REGEX_TIME_ATTRIBUTES);
        Matcher matcher = pattern.matcher(input);
        return matcher.find();
    }

    /**
     * This method checks to see if a date is specified in the date time String.
     *
     * @param input
     *            a date time String.
     * @return true if date is specified; false otherwise.
     */
    private boolean checkDateSpecified(String input) {
        Pattern pattern = Pattern.compile(Constants.REGEX_DATE_FORMAT);
        Matcher matcher = pattern.matcher(input);
        return matcher.find();
    }

    /**
     * This method gets the type of the task depending on the format of the
     * input.
     *
     * @param input
     *            the date time String.
     * @return a TaskType enum representing the task type of the input String.
     */
    private TaskType getTaskType(String input) {
        assert isValidDateTime(input);
        if (input.matches(Constants.REGEX_EVENT_IDENTIFIER)) {
            return TaskType.EVENT;
        } else if (input.matches(Constants.REGEX_DEADLINE_IDENTIFIER)) {
            return TaskType.DEADLINE;
        } else {
            return TaskType.POINT;
        }
    }

    /**
     * This method checks to see if the provided input matches a format out of
     * all supported date time formats.
     *
     * @param input
     *            the String to be checked.
     * @return true if the String is in a valid date time format; false
     *         otherwise.
     */
    private boolean isValidDateTime(String input) {
        return input != null && input.matches(Constants.REGEX_DATE_TIME_IDENTIFIER);
    }

    /**
     * This method reformats a given Date object to a LocalDateTime object. The
     * zone is taken to be the one found in the system.
     *
     * @param d
     *            a Date object.
     * @return the LocalDateTime object formatted from the Date object.
     */
    public LocalDateTime getLocalDateTimeFromDate(Date d) {
        assert d != null;
        return LocalDateTime.ofInstant(d.toInstant(), Constants.ZONE_ID);
    }

    private LocalDateTime setTime(LocalDateTime dateTime, Constants.Time time) {
        return dateTime.withHour(time.hour).withMinute(time.minutes).withSecond(time.seconds)
            .withNano(time.nanoseconds);
    }

    private LocalDateTime setDate(LocalDateTime to, LocalDateTime from) {
        return to.withYear(from.getYear()).withMonth(from.getMonthValue()).withDayOfMonth(from.getDayOfMonth());
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/BadDateTimeException.java
``` java

package jfdi.parser.exceptions;

/**
 * This exception is thrown when attempting to parse a string that does not
 * match with the supported formats of date and time. It contains a String
 * variable which corresponds to the bad input that was supposed to be parsed
 *
 * @author Leonard Hio
 *
 */
@SuppressWarnings("serial")
public class BadDateTimeException extends Exception {

    private String input = null;

    public BadDateTimeException(String input) {
        this.input = input;
    }

    public String getInput() {
        return this.input;
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/BadTaskDescriptionException.java
``` java

package jfdi.parser.exceptions;

/**
 * This exception is thrown when attempting to parse a string that does not
 * contain a valid task description. It contains a String variable which
 * corresponds to the bad input that was supposed to be parsed
 *
 * @author Leonard Hio
 *
 */
@SuppressWarnings("serial")
public class BadTaskDescriptionException extends Exception {

    private String input = null;

    public BadTaskDescriptionException(String input) {
        this.input = input;
    }

    public String getInput() {
        return this.input;
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/BadTaskIdException.java
``` java

package jfdi.parser.exceptions;

/**
 * This exception is thrown when attempting to parse a string that does not
 * contain a valid task ID. It contains a String variable which corresponds to
 * the bad input that was supposed to be parsed
 *
 * @author Leonard Hio
 *
 */
@SuppressWarnings("serial")
public class BadTaskIdException extends Exception {

    private String input = null;

    public BadTaskIdException(String input) {
        this.input = input;
    }

    public String getInput() {
        return this.input;
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/InvalidAliasException.java
``` java

package jfdi.parser.exceptions;

/**
 * This exception is thrown when attempting to assign a command to an alias that
 * has already been used for another command. It contains a String variable
 * which corresponds to the invalid alias.
 *
 * @author Leonard Hio
 *
 */
@SuppressWarnings("serial")
public class InvalidAliasException extends Exception {

    private String alias = null;

    public InvalidAliasException(String alias) {
        this.alias = alias;
    }

    public String getInput() {
        return this.alias;
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/InvalidCommandException.java
``` java

package jfdi.parser.exceptions;

/**
 * This exception is thrown when attempting to parse a string that makes
 * reference to an invalid command type. It contains a String variable which
 * corresponds to the invalid input that was supposed to be parsed.
 *
 * @author Leonard Hio
 *
 */
@SuppressWarnings("serial")
public class InvalidCommandException extends Exception {

    private String input = null;

    public InvalidCommandException(String input) {
        this.input = input;
    }

    public String getInput() {
        return this.input;
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/InvalidInputException.java
``` java

package jfdi.parser.exceptions;

/**
 * This exception is thrown when attempting to parse a string that is invalid in
 * some way. It contains a String variable which corresponds to the invalid
 * input that was supposed to be parsed.
 *
 * @author Leonard Hio
 *
 */
@SuppressWarnings("serial")
public class InvalidInputException extends Exception {

    private String input = null;

    public InvalidInputException(String input) {
        this.input = input;
    }

    public String getInput() {
        return this.input;
    }

}
```
###### ./src/main/java/jfdi/parser/exceptions/NoTaskIdFoundException.java
``` java

package jfdi.parser.exceptions;

@SuppressWarnings("serial")
public class NoTaskIdFoundException extends Exception {
    private String input = null;

    public NoTaskIdFoundException(String input) {
        this.input = input;
    }

    public String getInput() {
        return this.input;
    }
}
```
###### ./src/main/java/jfdi/parser/InputParser.java
``` java

package jfdi.parser;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Set;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants.CommandType;
import jfdi.parser.commandparsers.AddCommandParser;
import jfdi.parser.commandparsers.AliasCommandParser;
import jfdi.parser.commandparsers.DeleteCommandParser;
import jfdi.parser.commandparsers.DirectoryCommandParser;
import jfdi.parser.commandparsers.ExitCommandParser;
import jfdi.parser.commandparsers.HelpCommandParser;
import jfdi.parser.commandparsers.ListCommandParser;
import jfdi.parser.commandparsers.MarkCommandParser;
import jfdi.parser.commandparsers.MoveCommandParser;
import jfdi.parser.commandparsers.RenameCommandParser;
import jfdi.parser.commandparsers.RescheduleCommandParser;
import jfdi.parser.commandparsers.SearchCommandParser;
import jfdi.parser.commandparsers.UnaliasCommandParser;
import jfdi.parser.commandparsers.UndoCommandParser;
import jfdi.parser.commandparsers.UnmarkCommandParser;
import jfdi.parser.commandparsers.UseCommandParser;
import jfdi.parser.commandparsers.WildcardCommandParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.AliasAttributes;

/**
 * The InputParser class is used to parse a String input into its associated
 * Command object. This class should be used to interface with the Logic
 * component via the parse(String) method.
 *
 * @author Leonard Hio
 *
 */
public class InputParser implements IParser {

    private static InputParser parserInstance;
    private static final Logger LOGGER = JfdiLogger.getLogger();
    private static final String SOURCECLASS = InputParser.class.getName();
    private Collection<AliasAttributes> aliases = new ArrayList<AliasAttributes>();
    private HashMap<String, String> aliasMap = new HashMap<>();
    private String originalInput = "";

    public static InputParser getInstance() {
        LOGGER.entering(SOURCECLASS, "getInstance");
        if (parserInstance == null) {
            parserInstance = new InputParser();
        }
        LOGGER.exiting(SOURCECLASS, "getInstance");
        return parserInstance;
    }

    @Override
    public Command parse(String input) throws InvalidInputException {
        if (!isValidInput(input)) {
            LOGGER.throwing(SOURCECLASS, "parse", new InvalidInputException(input));
            throw new InvalidInputException(input);
        }

        originalInput = input;
        input = trimInput(input);

        // input is guaranteed to be at least one word long at this point
        String unaliasedInput = unalias(input);
        String firstWord = getFirstWord(unaliasedInput);
        CommandType commandType = ParserUtils.getCommandType(firstWord);
        Command userCommand = getCommand(commandType, unaliasedInput);
        return userCommand;
    }

    @Override
    public void setAliases(Collection<AliasAttributes> aliases) {
        assert aliases != null;
        this.aliases = new ArrayList<AliasAttributes>();
        this.aliases.addAll(aliases);
        buildAliasMap();
    }

    @Override
    public String getAllCommandRegexes() {
        return String.join("|", Constants.getCommandRegexes());
    }

    public HashMap<String, String> getAliasMap() {
        return aliasMap;
    }

    // ===================================
    // First Level of Abstraction
    // ===================================

    /**
     * This method builds a mapping of aliases to their corresponding command
     * types (represented as Strings).
     */
    private void buildAliasMap() {
        aliasMap = new HashMap<>();
        for (AliasAttributes att : aliases) {
            aliasMap.put(att.getAlias(), att.getCommand());
        }
    }

    /**
     * This method replaces an alias (if present) in the input into its
     * corresponding command type.
     *
     * @param input
     *            the String that may or may not have an alias.
     * @return the unaliased input.
     */
    private String unalias(String input) {
        assert isValidInput(input);
        String firstWord = getFirstWord(input);
        Set<String> aliasSet = aliasMap.keySet();
        for (String str : aliasSet) {
            if (firstWord.matches("^" + Pattern.quote(str))) {
                return input.replaceAll("^" + Pattern.quote(str), aliasMap.get(str));
            }
        }
        return input;
    }

    /**
     * This method gets the Command object associated with the user's input.
     *
     * @param commandType
     *            the CommandType of the user's input.
     * @param input
     *            the user's input itself.
     * @return a Command object that was built from the user's input.
     */
    private Command getCommand(CommandType commandType, String input) {
        assert commandType != null && isValidInput(input);

        switch (commandType) {
            case ADD:
                return AddCommandParser.getInstance().build(input);
            case LIST:
                return ListCommandParser.getInstance().build(input);
            case DELETE:
                return DeleteCommandParser.getInstance().build(input);
            case RENAME:
                return RenameCommandParser.getInstance().build(input);
            case RESCHEDULE:
                return RescheduleCommandParser.getInstance().build(input);
            case SEARCH:
                return SearchCommandParser.getInstance().build(input);
            case MARK:
                return MarkCommandParser.getInstance().build(input);
            case UNMARK:
                return UnmarkCommandParser.getInstance().build(input);
            case ALIAS:
                return AliasCommandParser.getInstance().build(input);
            case UNALIAS:
                return UnaliasCommandParser.getInstance().build(input);
            case DIRECTORY:
                // In this case, we check to see if input is made up of just the
                // command name. If it is not, parse it as an 'Add' command
                // instead.
                return isSingleWord(input) ? DirectoryCommandParser.getInstance().build(input) : AddCommandParser
                    .getInstance().build(input);
            case MOVE:
                return MoveCommandParser.getInstance().build(input);
            case USE:
                return UseCommandParser.getInstance().build(input);
            case UNDO:
                return isSingleWord(input) ? UndoCommandParser.getInstance().build(input) : AddCommandParser
                    .getInstance().build(originalInput);
            case HELP:
                return isSingleWord(input) ? HelpCommandParser.getInstance().build(input) : AddCommandParser
                    .getInstance().build(originalInput);
            case WILDCARD:
                return isSingleWord(input) ? WildcardCommandParser.getInstance().build(input) : AddCommandParser
                    .getInstance().build(originalInput);
            case EXIT:
                return isSingleWord(input) ? ExitCommandParser.getInstance().build(input) : AddCommandParser
                    .getInstance().build(originalInput);
            default:
                return AddCommandParser.getInstance().build(input);
        }
    }

    // ===================================
    // Second Level of Abstraction
    // ===================================

    /**
     * This method checks if the given input is valid. A valid input is one that
     * is (1) not empty, and (2) not made of whitespaces only.
     *
     * @param input
     *            the input which validity is to be checked
     * @return true if the input is valid; false otherwise
     */
    private boolean isValidInput(String input) {
        return input != null && !input.isEmpty() && !input.trim().isEmpty();
    }

    /**
     * This method returns the first word of the input String.
     *
     * @param input
     *            a String from which the first word is to be returned.
     * @return the first word of the input String.
     */
    private String getFirstWord(String input) {
        assert isValidInput(input);
        return input.trim().split(Constants.REGEX_WHITESPACE)[0];
    }

    private boolean isSingleWord(String input) {
        return input.trim().split(Constants.REGEX_WHITESPACE).length == 1;
    }

    private String trimInput(String input) {
        return input.trim();
    }
}
```
###### ./src/main/java/jfdi/parser/IParser.java
``` java

package jfdi.parser;

import java.util.Collection;

import jfdi.logic.interfaces.Command;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.AliasAttributes;

/**
 * This is the interface for the Parser component. All other components should
 * access the Parser component using only the methods in this interface. The
 * Parser component is simple: it takes in a String as input, and returns a
 * Command object.
 *
 * @author leona_000
 */
public interface IParser {

    /**
     * This method takes in a String as input and returns its associated Command
     * object. In most cases, the input should be what the user inputs into the
     * UI, and should be passed into the Parser via the Logic component.
     *
     * @param userinput
     *            the String input to be parsed. In most cases, this input
     *            should be the input by the user.
     * @return a Command object.
     * @throws InvalidInputException
     *             if the userInput is determined to be invalid.
     */
    Command parse(String userInput) throws InvalidInputException;

    /**
     * This method accepts a collection of AliasAttributes. This collection is
     * necessary for the InputParser to parse user inputs according to the alias
     * used.
     *
     * @param aliases
     *            a collection of AliasAttributes, earlier defined by the user
     */
    void setAliases(Collection<AliasAttributes> aliases);

    /**
     * This method returns a concatenated string of all command regexes, as
     * found in Constants.Java. All command regexes are seperated by a '|'
     * delimiter.
     *
     * @return a string of all command regexes.
     */
    String getAllCommandRegexes();
}
```
###### ./src/main/java/jfdi/parser/ParserUtils.java
``` java

package jfdi.parser;

import jfdi.parser.Constants.CommandType;

/**
 * This class contains some common methods to be shared amongst all Parser
 * classes.
 *
 * @author Leonard Hio
 *
 */
public class ParserUtils {

    /**
     * This method returns the CommandType associated with the input String.
     *
     * @param input
     *            a String interpretation of a CommandType.
     * @return a CommandType enum. If no matches were found, return invalid.
     */
    public static CommandType getCommandType(String input) {
        assert input.split(Constants.REGEX_WHITESPACE).length == 1;
        if (input.matches(Constants.REGEX_ADD)) {
            return CommandType.ADD;
        } else if (input.matches(Constants.REGEX_LIST)) {
            return CommandType.LIST;
        } else if (input.matches(Constants.REGEX_DELETE)) {
            return CommandType.DELETE;
        } else if (input.matches(Constants.REGEX_RENAME)) {
            return CommandType.RENAME;
        } else if (input.matches(Constants.REGEX_RESCHEDULE)) {
            return CommandType.RESCHEDULE;
        } else if (input.matches(Constants.REGEX_SEARCH)) {
            return CommandType.SEARCH;
        } else if (input.matches(Constants.REGEX_MARK)) {
            return CommandType.MARK;
        } else if (input.matches(Constants.REGEX_UNMARK)) {
            return CommandType.UNMARK;
        } else if (input.matches(Constants.REGEX_ALIAS)) {
            return CommandType.ALIAS;
        } else if (input.matches(Constants.REGEX_UNALIAS)) {
            return CommandType.UNALIAS;
        } else if (input.matches(Constants.REGEX_DIRECTORY)) {
            return CommandType.DIRECTORY;
        } else if (input.matches(Constants.REGEX_MOVE)) {
            return CommandType.MOVE;
        } else if (input.matches(Constants.REGEX_USE)) {
            return CommandType.USE;
        } else if (input.matches(Constants.REGEX_UNDO)) {
            return CommandType.UNDO;
        } else if (input.matches(Constants.REGEX_HELP)) {
            return CommandType.HELP;
        } else if (input.matches(Constants.REGEX_WILDCARD)) {
            return CommandType.WILDCARD;
        } else if (input.matches(Constants.REGEX_EXIT)) {
            return CommandType.EXIT;
        } else {
            return CommandType.INVALID;
        }

    }

}
```
###### ./src/test/java/jfdi/test/parser/AddCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;

import java.time.LocalDateTime;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.DateTimeObject;
import jfdi.parser.DateTimeParser;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.AddCommandParser;
import jfdi.parser.exceptions.BadDateTimeException;

import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;

public class AddCommandParserTest {
    private static AbstractCommandParser parser = AddCommandParser.getInstance();

    @BeforeClass
    public static void init() {
        parser = AddCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, AddCommandParser.getInstance());
    }

    @Test
    public void testValidAddInputWithoutDateTime() {
        // Equivalance class: valid inputs
        Command cmd = parser.build("add hello");
        AddTaskCommand addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "hello");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));

        // Boundary case: capitalised add keyword
        cmd = parser.build("ADD hello, it's me.");
        addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "hello, it's me.");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));

        // Boundary case: no 'add' keyword
        cmd = parser.build("This should parse as an add command.");
        addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "This should parse as an add command.");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));

        // Boundary case: With escape delimiters
        cmd = parser.build("\"This should parse as an add command.\"");
        addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "This should parse as an add command.");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));

        // Boundary case: With escape delimiters
        cmd = parser.build("\"The date time here should not be parsed by tomorrow\"");
        addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "The date time here should not be parsed by tomorrow");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));

        // Boundary case: symbols
        cmd = parser.build("&%&^%%*@^#!)!@#()\\@*@)_    @#@#***");
        addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "&%&^%%*@^#!)!@#()\\@*@)_    @#@#***");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));

        // Boundary case: numbers
        cmd = parser.build("12381209474");
        addTaskCommand = validateAndReturnAddCommand(cmd);
        validateDescription(addTaskCommand, "12381209474");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));
    }

    @Test
    public void testValidAddInputWithDateTime() {
        // Equivalence class: valid inputs with date-time
        // covers the three types of date-time tasks: deadline, event, point
        Command addCommand = parser.build("add watch how i met your mother by tomorrow");
        AddTaskCommand addTaskCommand = validateAndReturnAddCommand(addCommand);
        validateDescription(addTaskCommand, "watch how i met your mother");
        Assert.assertFalse(hasStartDateTime(addTaskCommand));
        Assert.assertTrue(hasEndDateTime(addTaskCommand));
        Assert.assertEquals(getEndDateTime(addTaskCommand), getEndDateTime("by tomorrow"));

        addCommand = parser.build("go to bed at 9pm");
        addTaskCommand = validateAndReturnAddCommand(addCommand);
        validateDescription(addTaskCommand, "go to bed");
        Assert.assertTrue(hasStartDateTime(addTaskCommand));
        Assert.assertFalse(hasEndDateTime(addTaskCommand));
        Assert.assertEquals(getStartDateTime(addTaskCommand), getStartDateTime("at 9pm"));

        addCommand = parser.build("play Goat Simulator from 4pm to 11pm");
        addTaskCommand = validateAndReturnAddCommand(addCommand);
        validateDescription(addTaskCommand, "play Goat Simulator");
        Assert.assertTrue(hasStartDateTime(addTaskCommand));
        Assert.assertTrue(hasEndDateTime(addTaskCommand));
        Assert.assertEquals(getStartDateTime(addTaskCommand), getStartDateTime("from 4pm to 11pm"));
        Assert.assertEquals(getEndDateTime(addTaskCommand), getEndDateTime("from 4pm to 11pm"));

        // Boundary case: with escape delimiters
        addCommand = parser.build("\"play Goat Simulator\" from 4pm to 11pm");
        addTaskCommand = validateAndReturnAddCommand(addCommand);
        validateDescription(addTaskCommand, "play Goat Simulator");
        Assert.assertTrue(hasStartDateTime(addTaskCommand));
        Assert.assertTrue(hasEndDateTime(addTaskCommand));
        Assert.assertEquals(getStartDateTime(addTaskCommand), getStartDateTime("from 4pm to 11pm"));
        Assert.assertEquals(getEndDateTime(addTaskCommand), getEndDateTime("from 4pm to 11pm"));

    }

    @Test
    public void testInvalidInput() {
        // Boundary case: no description and no date-time
        Command addCommand = parser.build("add");
        Assert.assertTrue(addCommand instanceof InvalidCommand);

        // Boundary case: no description
        addCommand = parser.build("add from 5pm to 6pm");
        Assert.assertTrue(addCommand instanceof InvalidCommand);

        addCommand = parser.build("from 5pm to 6pm");
        Assert.assertTrue(addCommand instanceof InvalidCommand);

        // Boundary case: with delimiters, wrapped around nothing
        addCommand = parser.build("\"\" from 5pm to 6pm");
        Assert.assertTrue(addCommand instanceof InvalidCommand);

        // Boundary case: null
        addCommand = parser.build(null);
        Assert.assertTrue(addCommand instanceof InvalidCommand);

        // Boundary case: Empty string
        addCommand = parser.build("");
        Assert.assertTrue(addCommand instanceof InvalidCommand);

    }

    private AddTaskCommand validateAndReturnAddCommand(Command cmd) {
        Assert.assertNotNull(cmd);
        Assert.assertTrue(cmd instanceof AddTaskCommand);

        return (AddTaskCommand) cmd;
    }

    private void validateDescription(AddTaskCommand addTaskCommand, String expected) {
        Assert.assertEquals(addTaskCommand.getDescription(), expected);
    }

    private boolean hasStartDateTime(AddTaskCommand addTaskCommand) {
        return addTaskCommand.getStartDateTime().isPresent();
    }

    private LocalDateTime getStartDateTime(AddTaskCommand addTaskCommand) {
        return addTaskCommand.getStartDateTime().get();
    }

    private LocalDateTime getStartDateTime(String input) {
        DateTimeObject res = null;
        try {
            res = DateTimeParser.getInstance().parseDateTime(input);
        } catch (BadDateTimeException e) {
            Assert.fail();
        }

        return res.getStartDateTime();
    }

    private boolean hasEndDateTime(AddTaskCommand addTaskCommand) {
        return addTaskCommand.getEndDateTime().isPresent();
    }

    private LocalDateTime getEndDateTime(AddTaskCommand addTaskCommand) {
        return addTaskCommand.getEndDateTime().get();
    }

    private LocalDateTime getEndDateTime(String input) {
        DateTimeObject res = null;
        try {
            res = DateTimeParser.getInstance().parseDateTime(input);
        } catch (BadDateTimeException e) {
            Assert.fail();
        }

        return res.getEndDateTime();
    }

}
```
###### ./src/test/java/jfdi/test/parser/AliasCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.AliasCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.AliasCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class AliasCommandParserTest {

    AbstractCommandParser parser = AliasCommandParser.getInstance();

    @Before
    public void init() {
        parser = AliasCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, AliasCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("alias add happy");
        Assert.assertTrue(command instanceof AliasCommand);
        AliasCommand aliasCommand = (AliasCommand) command;
        assertSameFields(aliasCommand, "add", "happy", true);

        command = parser.build("alias delete 12345");
        Assert.assertTrue(command instanceof AliasCommand);
        aliasCommand = (AliasCommand) command;
        assertSameFields(aliasCommand, "delete", "12345", true);

        command = parser.build("alias haha delete");
        Assert.assertTrue(command instanceof AliasCommand);
        aliasCommand = (AliasCommand) command;
        assertSameFields(aliasCommand, "haha", "delete", false);
    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("delete 1-5");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello 3words");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: insufficient arguments
        command = parser.build("alias");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("alias oneword");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    private void assertSameFields(AliasCommand aliasCommand, String command, String alias, boolean isValid) {
        Assert.assertEquals(aliasCommand.getCommand(), command);
        Assert.assertEquals(aliasCommand.getAlias(), alias);
        Assert.assertEquals(aliasCommand.isValid(), isValid);
    }

}
```
###### ./src/test/java/jfdi/test/parser/DateTimeParserTest.java
``` java

package jfdi.test.parser;

import java.time.LocalDateTime;
import java.time.Month;

import jfdi.parser.Constants;
import jfdi.parser.DateTimeObject;
import jfdi.parser.DateTimeParser;
import jfdi.parser.exceptions.BadDateTimeException;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class DateTimeParserTest {

    // month[1] represents the first month (Jan), month[2] represents Feb, etc
    static final Month[] MONTH = {null, Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE,
        Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER};

    // Time values specifying the beginning of day
    static final int BEGINNING_NANO = Constants.TIME_BEGINNING_OF_DAY.nanoseconds;
    static final int BEGINNING_SECONDS = Constants.TIME_BEGINNING_OF_DAY.seconds;
    static final int BEGINNING_MINUTES = Constants.TIME_BEGINNING_OF_DAY.minutes;
    static final int BEGINNING_HOUR = Constants.TIME_BEGINNING_OF_DAY.hour;

    // Default time values for date time inputs without specified time
    static final int DEFAULT_NANO = Constants.TIME_DEFAULT.nanoseconds;
    static final int DEFAULT_SECONDS = Constants.TIME_DEFAULT.seconds;
    static final int DEFAULT_MINUTES = Constants.TIME_DEFAULT.minutes;
    static final int DEFAULT_HOUR = Constants.TIME_DEFAULT.hour;

    // Time values specifying the end of day
    static final int END_NANO = Constants.TIME_END_OF_DAY.nanoseconds;
    static final int END_SECONDS = Constants.TIME_END_OF_DAY.seconds;
    static final int END_MINUTES = Constants.TIME_END_OF_DAY.minutes;
    static final int END_HOUR = Constants.TIME_END_OF_DAY.hour;

    DateTimeParser parser;

    @Before
    public void setupParser() {
        parser = DateTimeParser.getInstance();
    }

    // Relative date time queries
    // Deadline task
    // With no time specified
    @Test
    public void testParseRelativeQueries() {
        DateTimeObject res = parseDateTime("by next year");

        // Start date-time should be null
        Assert.assertNull(res.getStartDateTime());

        // Check end date time is corrently parsed
        LocalDateTime expectedDateTime = getCurrentDatePlus(1, 0, 0, 0, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), DEFAULT_HOUR, DEFAULT_MINUTES);

        res = parseDateTime("by 1 month later");

        // Start date-time should be null
        Assert.assertNull(res.getStartDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 1, 0, 0, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), DEFAULT_HOUR, DEFAULT_MINUTES);

        res = parseDateTime("by tomorrow");

        // Start date-time should be null
        Assert.assertNull(res.getStartDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 1, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), DEFAULT_HOUR, DEFAULT_MINUTES);
    }

    // Relative date time queries
    // Deadline task
    // With time specified
    @Test
    public void testParseRelativeQueries2() {
        DateTimeObject res = parseDateTime("by 18.32h, tomorrow");

        // Start date-time should be null
        Assert.assertNull(res.getStartDateTime());

        // Check end date time is corrently parsed
        LocalDateTime expectedDateTime = getCurrentDatePlus(0, 0, 0, 1, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 18, 32);
        res = parseDateTime("by 3 days later, 1100pm");

        // Start date-time should be null
        Assert.assertNull(res.getStartDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 3, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 23, 00);

        res = parseDateTime("by 23:00h 3 days later");

        // Start date-time should be null
        Assert.assertNull(res.getStartDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 3, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 23, 00);

    }

    // Relative date time queries
    // Point task
    // With time specified
    @Test
    public void testParseRelativeQueries3() {
        DateTimeObject res = parseDateTime("next month 11pm");

        // Start date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        LocalDateTime expectedDateTime = getCurrentDatePlus(0, 1, 0, 0, 0, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 23, 00);

        res = parseDateTime("11pm, tomorrow");

        // Start date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 1, 0, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 23, 00);

        res = parseDateTime("3 hours later");

        // Start date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 0, 3, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), expectedDateTime.getHour(), expectedDateTime.getMinute());

        res = parseDateTime("5 hours from now");

        // Start date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 0, 5, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), expectedDateTime.getHour(), expectedDateTime.getMinute());

        res = parseDateTime("in 4 days' time");

        // Start date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 4, 0, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), DEFAULT_HOUR, DEFAULT_MINUTES);

        res = parseDateTime("in 4 hours");

        // Start date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 0, 4, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), expectedDateTime.getHour(), expectedDateTime.getMinute());

    }

    // Relative date time queries
    // Event Task
    // Without time specified
    @Test
    public void testParseRelativeQueries4() {
        DateTimeObject res = parseDateTime("From tomorrow to 4 days later");

        // Check start date time is corrently parsed
        LocalDateTime expectedDateTime = getCurrentDatePlus(0, 0, 0, 1, 0, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), BEGINNING_HOUR, BEGINNING_MINUTES);
        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, 4, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), END_HOUR, END_MINUTES);

        res = parseDateTime("From yesterday to 3 weeks later");

        // Check start date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 0, -1, 0, 0);
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), BEGINNING_HOUR, BEGINNING_MINUTES);

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDatePlus(0, 0, 3, 0, 0, 0);
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), END_HOUR, END_MINUTES);
    }

    // Explicit date time queries
    // Point task
    // With time specified
    @Test
    public void testParseExplicitQueries() {
        DateTimeObject res = parseDateTime("on 26th February 17, 9.30pm");

        // End date-time should be null
        Assert.assertNull(res.getEndDateTime());

        checkMatchingDateTime(res.getStartDateTime(), 2017, MONTH[2], 26, 21, 30);

        res = parseDateTime("on 22nd july, 21:00h");

        // End date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2016, MONTH[7], 22, 21, 00);
    }

    // Explicit date time queries
    // Point Task
    // Without time specified
    @Test
    public void testParseExplicitQueries2() {
        DateTimeObject res = parseDateTime("on 22/07/17");

        // End date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2017, MONTH[7], 22, DEFAULT_HOUR, DEFAULT_MINUTES);

        res = parseDateTime("09-Jan-2022");

        // End date-time should be null
        Assert.assertNull(res.getEndDateTime());

        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2022, MONTH[1], 9, DEFAULT_HOUR, DEFAULT_MINUTES);
    }

    // Explicit date time queries
    // Event Task
    // Without time specified
    @Test
    public void testParseExplicitQueries3() {
        DateTimeObject res = parseDateTime("26th February 17 to 28th December 2019");

        // Check start date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2017, MONTH[2], 26, BEGINNING_HOUR, BEGINNING_MINUTES);

        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getEndDateTime(), 2019, MONTH[12], 28, END_HOUR, END_MINUTES);

        res = parseDateTime("From 25/11/94 to 23/12/97");

        // Check start date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 1994, MONTH[11], 25, BEGINNING_HOUR, BEGINNING_MINUTES);

        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getEndDateTime(), 1997, MONTH[12], 23, END_HOUR, END_MINUTES);

    }

    // Explicit date time queries
    // Event Task
    // With time specified
    @Test
    public void testParseExplicitQueries4() {
        DateTimeObject res = parseDateTime("From 26th.February.2017 9pm to 930pm 28th December 19");

        // Check start date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2017, MONTH[2], 26, 21, DEFAULT_MINUTES);
        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getEndDateTime(), 2019, MONTH[12], 28, 21, 30);

        res = parseDateTime("From 25/11 23.12hr to 12:34hrs, 23/12");

        res = parseDateTime("From 26th.February.2017 to 930pm 28th December 19");

        // Check start date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2017, MONTH[2], 26, DEFAULT_HOUR, DEFAULT_MINUTES);
        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getEndDateTime(), 2019, MONTH[12], 28, 21, 30);

        res = parseDateTime("From 25/11 23.12hr to 12:34hrs, 23/12");

        res = parseDateTime("From 26th.February.2017 2100hrs to 28th December 19");

        // Check start date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2017, MONTH[2], 26, 21, DEFAULT_MINUTES);
        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getEndDateTime(), 2019, MONTH[12], 28, DEFAULT_HOUR, DEFAULT_MINUTES);

        res = parseDateTime("From 25/11 23.12hr to 12:34hrs, 23/12");

        // Check start date time is corrently parsed
        checkMatchingDateTime(res.getStartDateTime(), 2016, Month.NOVEMBER, 25, 23, 12);

        // Check end date time is corrently parsed
        checkMatchingDateTime(res.getEndDateTime(), 2016, Month.DECEMBER, 23, 12, 34);

        res = parseDateTime("From 3pm to 8pm");

        // Check start date time is corrently parsed
        LocalDateTime expectedDateTime = getCurrentDate();
        checkMatchingDateTime(res.getStartDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 15, 00);

        // Check end date time is corrently parsed
        expectedDateTime = getCurrentDate();
        checkMatchingDateTime(res.getEndDateTime(), expectedDateTime.getYear(), expectedDateTime.getMonth(),
            expectedDateTime.getDayOfMonth(), 20, 00);

    }

    @Test
    public void testParseInvalid1() {
        try {
            parser.parseDateTime("no date time format");
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testParseInvalid2() {
        try {
            parser.parseDateTime("by 42/01/99");
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testParseInvalid3() {
        try {
            parser.parseDateTime("by Wednesday Thursday");
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testParseInvalid4() {
        try {
            parser.parseDateTime("from 3pm and 9pm");
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testParseInvalid5() {
        try {
            parser.parseDateTime("from 26/5/17 3pm to 22/5/17 9pm");
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testParseInvalid6() {
        try {
            parser.parseDateTime("");
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testParseInvalid7() {
        try {
            parser.parseDateTime(null);
        } catch (BadDateTimeException e) {
            Assert.assertTrue(true);
        }
    }

    private DateTimeObject parseDateTime(String input) {
        DateTimeObject res = null;
        try {
            res = parser.parseDateTime(input);
        } catch (BadDateTimeException e) {
            Assert.fail();
        }

        return res;
    }

    private void checkMatchingDateTime(LocalDateTime res, int year, Month month, int day, int hour, int minutes) {
        Assert.assertNotNull(res);
        Assert.assertEquals(year, res.getYear());
        Assert.assertEquals(month, res.getMonth());
        Assert.assertEquals(day, res.getDayOfMonth());
        Assert.assertEquals(minutes, res.getMinute());
        Assert.assertEquals(hour, res.getHour());
    }

    private LocalDateTime getCurrentDatePlus(int addYears, int addMonths, int addWeeks, int addDays, int addHours,
        int addMinutes) {
        return LocalDateTime.now().plusYears(addYears).plusMonths(addMonths).plusWeeks(addWeeks).plusDays(addDays)
            .plusHours(addHours).plusMinutes(addMinutes);
    }

    private LocalDateTime getCurrentDate() {
        return LocalDateTime.now();
    }

}
```
###### ./src/test/java/jfdi/test/parser/DeleteCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.DeleteCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import edu.emory.mathcs.backport.java.util.Arrays;

public class DeleteCommandParserTest {

    AbstractCommandParser parser = DeleteCommandParser.getInstance();

    @Before
    public void init() {
        parser = DeleteCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, DeleteCommandParser.getInstance());
    }

    @Test
    public void testValidDeleteInput() {
        Command command = parser.build("Delete 1");
        DeleteTaskCommand deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1);

        command = parser.build("delete 1 2 3");
        deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1, 2, 3);

        command = parser.build("Delete 1, 2, 3");
        deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1, 2, 3);

        command = parser.build("Delete 1, 2    3");
        deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1, 2, 3);

        command = parser.build("deLETE 1, 2-9, 20, 43");
        deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20, 43);

        command = parser.build("Delete 1-3 2-9");
        deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9);

        command = parser.build("Delete 1    -3,   2-  9");
        deleteCommand = validateAndReturnDeleteCommand(command);
        validateDeleteType(deleteCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    }

    @Test
    public void testInvalidDeleteInput() {
        Command command = parser.build("Delete");
        Assert.assertTrue(command instanceof InvalidCommand);

        command = parser.build("Delete 11-9");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        try {
            command = parser.build("List 1-8");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: empty string
        try {
            command = parser.build("");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: null
        try {
            command = parser.build(null);
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }
    }

    private DeleteTaskCommand validateAndReturnDeleteCommand(Command cmd) {
        Assert.assertNotNull(cmd);
        Assert.assertTrue(cmd instanceof DeleteTaskCommand);

        return (DeleteTaskCommand) cmd;
    }

    private void validateDeleteType(DeleteTaskCommand deleteCommand,
        int... screenIds) {
        int[] screenIdsInDeleteCommand = deleteCommand.getScreenIds().stream()
            .mapToInt(i -> i).toArray();
        Arrays.sort(screenIds);
        Arrays.sort(screenIdsInDeleteCommand);
        Assert.assertArrayEquals(screenIds, screenIdsInDeleteCommand);
    }
}
```
###### ./src/test/java/jfdi/test/parser/DirectoryCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.DirectoryCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.DirectoryCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class DirectoryCommandParserTest {

    AbstractCommandParser parser = DirectoryCommandParser.getInstance();

    @Before
    public void init() {
        parser = DirectoryCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, DirectoryCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("directory");
        Assert.assertTrue(command instanceof DirectoryCommand);
        command = parser.build("Directory");
        Assert.assertTrue(command instanceof DirectoryCommand);
        command = parser.build("DirECToRy");
        Assert.assertTrue(command instanceof DirectoryCommand);
    }

    @Test
    public void testInvalidCommand() {
        // Multiple words
        Command command = parser.build("directory to somewhere");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("direct me");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        command = parser.build("add 1-8");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

    }

}
```
###### ./src/test/java/jfdi/test/parser/ExitCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.ExitCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.ExitCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class ExitCommandParserTest {

    AbstractCommandParser parser = ExitCommandParser.getInstance();

    @Before
    public void init() {
        parser = ExitCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, ExitCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("exit");
        Assert.assertTrue(command instanceof ExitCommand);
        command = parser.build("Exit");
        Assert.assertTrue(command instanceof ExitCommand);
        command = parser.build("exit");
        Assert.assertTrue(command instanceof ExitCommand);
    }

    @Test
    public void testInvalidCommand() {
        // Multiple words
        Command command = parser.build("exit via the back door");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        command = parser.build("add 1-8");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);

    }

}
```
###### ./src/test/java/jfdi/test/parser/HelpCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.HelpCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.HelpCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class HelpCommandParserTest {

    AbstractCommandParser parser = HelpCommandParser.getInstance();

    @Before
    public void init() {
        parser = HelpCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, HelpCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("help");
        Assert.assertTrue(command instanceof HelpCommand);
        command = parser.build("Help");
        Assert.assertTrue(command instanceof HelpCommand);
        command = parser.build("hELP");
        Assert.assertTrue(command instanceof HelpCommand);
    }

    @Test
    public void testInvalidCommand() {
        // Multiple words
        Command command = parser.build("help me");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("help 1-5");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        command = parser.build("list incomplete");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

}
```
###### ./src/test/java/jfdi/test/parser/InputParserTest.java
``` java

package jfdi.test.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.commands.AliasCommand;
import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.logic.commands.DirectoryCommand;
import jfdi.logic.commands.ExitCommand;
import jfdi.logic.commands.HelpCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.ListCommand;
import jfdi.logic.commands.MarkTaskCommand;
import jfdi.logic.commands.MoveDirectoryCommand;
import jfdi.logic.commands.RenameTaskCommand;
import jfdi.logic.commands.RescheduleTaskCommand;
import jfdi.logic.commands.SearchCommand;
import jfdi.logic.commands.UnaliasCommand;
import jfdi.logic.commands.UndoCommand;
import jfdi.logic.commands.UnmarkTaskCommand;
import jfdi.logic.commands.UseDirectoryCommand;
import jfdi.logic.commands.WildcardCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.entities.Alias;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class InputParserTest {
    InputParser parser;
    ArrayList<AliasAttributes> aliasAttributes = new ArrayList<>();

    @Before
    public void setupParser() {
        parser = InputParser.getInstance();
        aliasAttributes.clear();
        aliasAttributes.add(new AliasAttributes(new Alias("ad", "add")));
        aliasAttributes.add(new AliasAttributes(new Alias("del", "delete")));
        aliasAttributes.add(new AliasAttributes(new Alias("res", "reschedule")));
        aliasAttributes.add(new AliasAttributes(new Alias("q", "quit")));
        aliasAttributes.add(new AliasAttributes(new Alias("un", "undo")));
        aliasAttributes.add(new AliasAttributes(new Alias("rm", "delete")));
        aliasAttributes.add(new AliasAttributes(new Alias("dir", "directory")));

        parser.setAliases(aliasAttributes);
    }

    // ==============================================================
    // Each of the below test methods represent an equivalence class
    // representing the command type under test.
    // Each test method contain tests for valid inputs as well as
    // boundary cases.
    // ==============================================================

    @Test
    public void testUserInputAdd() throws InvalidInputException {
        String addCommand = "add hello";
        Command command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);

        addCommand = "hello";
        command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);

        addCommand = "hello 23/12/1993 to 26/09/1998";
        command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);

        addCommand = "hello by 22nd Jan 1500hrs";
        command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);

        // With alias
        addCommand = "ad hello on 15th Sep 2015";
        command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);

        addCommand = "from now to tomorrow";
        command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof InvalidCommand);

        addCommand = "add";
        command = parser.parse(addCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputList() throws InvalidInputException {
        String listCommand = "List";
        Command command = parser.parse(listCommand);
        Assert.assertTrue(command instanceof ListCommand);

        listCommand = "List all";
        command = parser.parse(listCommand);
        Assert.assertTrue(command instanceof ListCommand);

        listCommand = "list completed";
        command = parser.parse(listCommand);
        Assert.assertTrue(command instanceof ListCommand);

        listCommand = "list voodoo";
        command = parser.parse(listCommand);
        Assert.assertTrue(command instanceof InvalidCommand);

        listCommand = "list 12345";
        command = parser.parse(listCommand);
        Assert.assertTrue(command instanceof InvalidCommand);

    }

    @Test
    public void testUserInputDelete() throws InvalidInputException {
        String deleteCommand = "delete 1,2,3";

        Command command = parser.parse(deleteCommand);
        Assert.assertTrue(command instanceof DeleteTaskCommand);

        deleteCommand = "delete";
        command = parser.parse(deleteCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputRename() throws InvalidInputException {
        String renameCommand = "rename 1 hello";

        Command command = parser.parse(renameCommand);
        Assert.assertTrue(command instanceof RenameTaskCommand);

        renameCommand = "rename 10";

        command = parser.parse(renameCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputReschedule() throws InvalidInputException {
        String rescheduleCommand = "reschedule 4 by next week";

        Command command = parser.parse(rescheduleCommand);
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
    }

    @Test
    public void testUserInputSearch() throws InvalidInputException {
        String searchCommand = "search hello";

        Command command = parser.parse(searchCommand);
        Assert.assertTrue(command instanceof SearchCommand);

        searchCommand = "search";

        command = parser.parse(searchCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputMark() throws InvalidInputException {
        String markCommand = "mark 1";

        Command command = parser.parse(markCommand);
        Assert.assertTrue(command instanceof MarkTaskCommand);

        markCommand = "mark";

        command = parser.parse(markCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputUnmark() throws InvalidInputException {
        String unmarkCommand = "unmark 1";

        Command command = parser.parse(unmarkCommand);
        Assert.assertTrue(command instanceof UnmarkTaskCommand);

        unmarkCommand = "unmark dfsdfsdf";

        command = parser.parse(unmarkCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputAlias() throws InvalidInputException {
        String aliasCommand = "alias add hello";

        Command command = parser.parse(aliasCommand);
        Assert.assertTrue(command instanceof AliasCommand);

        aliasCommand = "alias banana hello";

        command = parser.parse(aliasCommand);
        Assert.assertTrue(command instanceof AliasCommand);

        aliasCommand = "alias hello";

        command = parser.parse(aliasCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputUnalias() throws InvalidInputException {
        String unaliasCommand = "unalias hello";

        Command command = parser.parse(unaliasCommand);
        Assert.assertTrue(command instanceof UnaliasCommand);

        unaliasCommand = "unalias ";

        command = parser.parse(unaliasCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    @Test
    public void testUserInputDirectory() throws InvalidInputException {
        String directoryCommand = "directory";

        Command command = parser.parse(directoryCommand);
        Assert.assertTrue(command instanceof DirectoryCommand);

        // For single word commands, add extra characters after the command
        directoryCommand = "directory to NUS";

        command = parser.parse(directoryCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);
    }

    @Test
    public void testUserInputMove() throws InvalidInputException {
        String moveCommand = "move";

        Command command = parser.parse(moveCommand);
        Assert.assertTrue(command instanceof InvalidCommand);

        moveCommand = "move C:/";

        command = parser.parse(moveCommand);
        Assert.assertTrue(command instanceof MoveDirectoryCommand);
    }

    @Test
    public void testUserInputUse() throws InvalidInputException {
        String useCommand = "use";

        Command command = parser.parse(useCommand);
        Assert.assertTrue(command instanceof InvalidCommand);
        useCommand = "use C://";

        command = parser.parse(useCommand);
        Assert.assertTrue(command instanceof UseDirectoryCommand);
    }

    @Test
    public void testUserInputUndo() throws InvalidInputException {
        String undoCommand = "undo";

        Command command = parser.parse(undoCommand);
        Assert.assertTrue(command instanceof UndoCommand);

        undoCommand = "undo my life";

        command = parser.parse(undoCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);
    }

    @Test
    public void testUserInputHelp() throws InvalidInputException {
        String helpCommand = "help";

        Command command = parser.parse(helpCommand);
        Assert.assertTrue(command instanceof HelpCommand);

        helpCommand = "help me get my life back on track";

        command = parser.parse(helpCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);
    }

    @Test
    public void testUserInputWildcard() throws InvalidInputException {
        String wildcardCommand = "surprise";
        Command command = parser.parse(wildcardCommand);
        Assert.assertTrue(command instanceof WildcardCommand);

        wildcardCommand = "surprise!!";
        command = parser.parse(wildcardCommand);
        Assert.assertTrue(command instanceof WildcardCommand);

        wildcardCommand = "surprise!!!!!!!!!!!!!!";
        command = parser.parse(wildcardCommand);
        Assert.assertTrue(command instanceof WildcardCommand);

        wildcardCommand = "surprise myself on my birthday (since nobody else will :()";
        command = parser.parse(wildcardCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);
    }

    @Test
    public void testUserInputExit() throws InvalidInputException {
        String exitCommand = "exit";

        Command command = parser.parse(exitCommand);
        Assert.assertTrue(command instanceof ExitCommand);

        exitCommand = "quit";

        command = parser.parse(exitCommand);
        Assert.assertTrue(command instanceof ExitCommand);

        exitCommand = "quit slacking";

        command = parser.parse(exitCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);

        exitCommand = "exit on the left";

        command = parser.parse(exitCommand);
        Assert.assertTrue(command instanceof AddTaskCommand);
    }

    @Test
    public void testInvalid() throws InvalidInputException {

        Command command = null;
        try {
            command = parser.parse(null);
        } catch (InvalidInputException e) {
            Assert.assertTrue(true);
        }

        try {
            command = parser.parse("");
        } catch (InvalidInputException e) {
            Assert.assertTrue(true);
        }

        try {
            command = parser.parse(" ");
        } catch (InvalidInputException e) {
            Assert.assertTrue(true);
        }
    }

    @Test
    public void testSetAliases() {

        List<String> aliasesInAliasAttributes =
            Arrays.asList(aliasAttributes.stream().map(aliasAttribute -> aliasAttribute.getAlias())
                .toArray(size -> new String[size]));
        List<String> commandsInAliasAttributes =
            Arrays.asList(aliasAttributes.stream().map(aliasAttribute -> aliasAttribute.getCommand())
                .toArray(size -> new String[size]));

        for (String alias : parser.getAliasMap().keySet()) {
            Assert.assertTrue(aliasesInAliasAttributes.contains(alias));
            String command = commandsInAliasAttributes.get(aliasesInAliasAttributes.indexOf(alias));
            Assert.assertTrue(parser.getAliasMap().get(alias).equals(command));
        }

        for (String alias : aliasesInAliasAttributes) {
            Assert.assertTrue(parser.getAliasMap().keySet().contains(alias));
            String command = parser.getAliasMap().get(alias);
            Assert.assertTrue(commandsInAliasAttributes.get(aliasesInAliasAttributes.indexOf(alias)).equals(command));
        }
    }

    @Test
    public void testGetAllCommandRegexes() {
        String allCommandRegexes = parser.getAllCommandRegexes();
        Assert.assertTrue(allCommandRegexes.equals(String.join("|", Constants.getCommandRegexes())));
    }
}
```
###### ./src/test/java/jfdi/test/parser/ListCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.ListCommand;
import jfdi.logic.commands.ListCommand.ListType;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.ListCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class ListCommandParserTest {
    AbstractCommandParser parser = ListCommandParser.getInstance();

    @Before
    public void init() {
        parser = ListCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, ListCommandParser.getInstance());
    }

    @Test
    public void testDefault() {
        Command cmd = parser.build("list");
        ListCommand listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.INCOMPLETE);

        // Boundary case: capitalised list keyword
        cmd = parser.build("LiSt");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.INCOMPLETE);

        cmd = parser.build("LiSt incomplete");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.INCOMPLETE);
    }

    @Test
    public void testAll() {
        Command cmd = parser.build("list all");
        ListCommand listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.ALL);

        // Boundary case: capitalised list keyword
        cmd = parser.build("LiSt AlL");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.ALL);
    }

    @Test
    public void testCompleted() {
        Command cmd = parser.build("list completed");
        ListCommand listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.COMPLETED);

        // Boundary case: capitalised list keyword
        cmd = parser.build("LiSt CoMplETEd");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.COMPLETED);
    }

    @Test
    public void testOverdue() {
        Command cmd = parser.build("list overdue");
        ListCommand listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.OVERDUE);

        // Boundary case: capitalised list keyword
        cmd = parser.build("LiSt overDUE");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.OVERDUE);

        // Boundary case: alternative spelling + capitalisation
        cmd = parser.build("List Overdue");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.OVERDUE);
    }

    @Test
    public void testUpcoming() {
        Command cmd = parser.build("list upcoming");
        ListCommand listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.UPCOMING);

        // Boundary case: capitalised list keyword
        cmd = parser.build("LiSt upCOMING");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.UPCOMING);

        // Boundary case: alternative spelling + capitalisation
        cmd = parser.build("List Upcoming");
        listCommand = validateAndReturnListCommand(cmd);
        validateListType(listCommand, ListType.UPCOMING);
    }

    @Test
    public void testInvalid() {
        Command cmd = parser.build("list nonsense");
        Assert.assertTrue(cmd instanceof InvalidCommand);

        // Boundary case: numbers
        cmd = parser.build("list 12343121");
        Assert.assertTrue(cmd instanceof InvalidCommand);

        // Boundary case: symbols
        cmd = parser.build("LiSt *&(*&(*@$*^$");
        Assert.assertTrue(cmd instanceof InvalidCommand);

        // Boundary case: null
        cmd = parser.build("LiSt *&(*&(*@$*^$");
        Assert.assertTrue(cmd instanceof InvalidCommand);

        // Boundary case: symbols
        cmd = parser.build("LiSt *&(*&(*@$*^$");
        Assert.assertTrue(cmd instanceof InvalidCommand);

        // Boundary case: wrong command
        try {
            cmd = parser.build("delete 1-9");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: empty string
        try {
            cmd = parser.build("");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: null
        try {
            cmd = parser.build(null);
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }
    }

    private ListCommand validateAndReturnListCommand(Command cmd) {
        Assert.assertNotNull(cmd);
        Assert.assertTrue(cmd instanceof ListCommand);

        return (ListCommand) cmd;
    }

    private void validateListType(ListCommand listCommand, ListType listType) {
        Assert.assertEquals(listCommand.getListType(), listType);
    }

}
```
###### ./src/test/java/jfdi/test/parser/MarkCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.MarkTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.MarkCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import edu.emory.mathcs.backport.java.util.Arrays;

public class MarkCommandParserTest {

    AbstractCommandParser parser = MarkCommandParser.getInstance();

    @Before
    public void init() {
        parser = MarkCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, MarkCommandParser.getInstance());
    }

    @Test
    public void testValidMarkInput() {
        Command command = parser.build("Mark 1");
        MarkTaskCommand markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1);

        command = parser.build("mark 1 2 3");
        markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1, 2, 3);

        command = parser.build("Mark 1, 2, 3");
        markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1, 2, 3);

        command = parser.build("Mark 1, 2    3");
        markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1, 2, 3);

        command = parser.build("mARk 1, 2-9, 20, 43");
        markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20, 43);

        command = parser.build("Mark 1-3 2-9");
        markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9);

        command = parser.build("Mark 1    -3,   2-  9");
        markCommand = validateAndReturnMarkCommand(command);
        validateMarkType(markCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    }

    @Test
    public void testInvalidMarkInput() {
        Command command = parser.build("Mark");
        Assert.assertTrue(command instanceof InvalidCommand);

        command = parser.build("Mark 11-9");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        try {
            command = parser.build("List 1-8");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: empty string
        try {
            command = parser.build("");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: null
        try {
            command = parser.build(null);
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }
    }

    private MarkTaskCommand validateAndReturnMarkCommand(Command cmd) {
        Assert.assertNotNull(cmd);
        Assert.assertTrue(cmd instanceof MarkTaskCommand);

        return (MarkTaskCommand) cmd;
    }

    private void validateMarkType(MarkTaskCommand markCommand, int... screenIds) {
        int[] screenIdsInMarkCommand = markCommand.getScreenIds().stream()
            .mapToInt(i -> i).toArray();
        Arrays.sort(screenIds);
        Arrays.sort(screenIdsInMarkCommand);
        Assert.assertArrayEquals(screenIds, screenIdsInMarkCommand);
    }
}
```
###### ./src/test/java/jfdi/test/parser/MoveCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.MoveDirectoryCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.MoveCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class MoveCommandParserTest {

    AbstractCommandParser parser = MoveCommandParser.getInstance();

    @Before
    public void init() {
        parser = MoveCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, MoveCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("move happy");
        Assert.assertTrue(command instanceof MoveDirectoryCommand);
        MoveDirectoryCommand moveCommand = (MoveDirectoryCommand) command;
        Assert.assertEquals("happy", moveCommand.getNewDirectory());

        command = parser.build("Move C://leonard hio/dir");
        Assert.assertTrue(command instanceof MoveDirectoryCommand);
        moveCommand = (MoveDirectoryCommand) command;
        Assert.assertEquals("C://leonard hio/dir", moveCommand.getNewDirectory());

        command = parser.build("Move 12343 45451 15454 56 6 6 ");
        Assert.assertTrue(command instanceof MoveDirectoryCommand);
        moveCommand = (MoveDirectoryCommand) command;
        Assert.assertEquals("12343 45451 15454 56 6 6 ", moveCommand.getNewDirectory());
    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("surprise me");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: no arguments
        command = parser.build("Move");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

}
```
###### ./src/test/java/jfdi/test/parser/RenameCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.RenameTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.RenameCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class RenameCommandParserTest {

    AbstractCommandParser parser = RenameCommandParser.getInstance();

    @Before
    public void init() {
        parser = RenameCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, RenameCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("rename 1 happy");
        Assert.assertTrue(command instanceof RenameTaskCommand);
        RenameTaskCommand renameCommand = (RenameTaskCommand) command;
        assertSameFields(renameCommand, 1, "happy");

        command = parser.build("rename 123 12345");
        Assert.assertTrue(command instanceof RenameTaskCommand);
        renameCommand = (RenameTaskCommand) command;
        assertSameFields(renameCommand, 123, "12345");

        command = parser.build("rename 100232132 2 or more words");
        Assert.assertTrue(command instanceof RenameTaskCommand);
        renameCommand = (RenameTaskCommand) command;
        assertSameFields(renameCommand, 100232132, "2 or more words");
    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("delete 1-5");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello 3words");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: insufficient arguments
        command = parser.build("rename");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("rename oneword");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("rename 1");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    private void assertSameFields(RenameTaskCommand renameTaskCommand, int taskId, String desc) {
        Assert.assertEquals(renameTaskCommand.getScreenId(), taskId);
        Assert.assertEquals(renameTaskCommand.getDescription(), desc);
    }

}
```
###### ./src/test/java/jfdi/test/parser/RescheduleCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;

import java.time.LocalDateTime;

import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.RescheduleTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.DateTimeObject;
import jfdi.parser.DateTimeParser;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.RescheduleCommandParser;
import jfdi.parser.exceptions.BadDateTimeException;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class RescheduleCommandParserTest {

    AbstractCommandParser parser = RescheduleCommandParser.getInstance();
    DateTimeParser dateTimeParser = DateTimeParser.getInstance();

    @Before
    public void init() {
        parser = RescheduleCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, RescheduleCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("reschedule 1 to 5pm");
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        RescheduleTaskCommand rescheduleCommand = (RescheduleTaskCommand) command;
        DateTimeObject dateTimeObject = getDateTimeObject("5pm");
        assertSameFields(rescheduleCommand, 1, false, true, dateTimeObject, null, null);

        command = parser.build("reschedule 1 5pm");
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        rescheduleCommand = (RescheduleTaskCommand) command;
        dateTimeObject = getDateTimeObject("5pm");
        assertSameFields(rescheduleCommand, 1, false, true, dateTimeObject, null, null);

        command = parser.build("Reschedule 123 to 23rd feb 2016 5pm");
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        rescheduleCommand = (RescheduleTaskCommand) command;
        dateTimeObject = getDateTimeObject("23rd feb 2016 5pm");
        assertSameFields(rescheduleCommand, 123, true, true, dateTimeObject, null, null);

        command = parser.build("RescheDULE 123 by 23rd feb 2016 5pm");
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        rescheduleCommand = (RescheduleTaskCommand) command;
        dateTimeObject = getDateTimeObject("by 23rd feb 2016 5pm");
        assertSameFields(rescheduleCommand, 123, true, true, null, dateTimeObject.getStartDateTime(),
            dateTimeObject.getEndDateTime());

        command = parser.build("reschedule 543457 at 23rd feb 2016");
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        rescheduleCommand = (RescheduleTaskCommand) command;
        dateTimeObject = getDateTimeObject("at 23rd feb 2016");
        assertSameFields(rescheduleCommand, 543457, true, false, null, dateTimeObject.getStartDateTime(),
            dateTimeObject.getEndDateTime());

        command = parser.build("reschedule 543457 to 23rd feb 2016 to 15 May 2016 7pm");
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        rescheduleCommand = (RescheduleTaskCommand) command;
        dateTimeObject = getDateTimeObject("23rd feb 2016 to 15 May 2016 7pm");
        assertSameFields(rescheduleCommand, 543457, true, true, null, dateTimeObject.getStartDateTime(),
            dateTimeObject.getEndDateTime());

        command = parser.build("reschedule 1");
        rescheduleCommand = (RescheduleTaskCommand) command;
        Assert.assertTrue(command instanceof RescheduleTaskCommand);
        assertSameFields(rescheduleCommand, 1, false, false, null, null, null);

    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("delete 1-5");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello 3words");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: insufficient arguments
        command = parser.build("reschedule");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("reschedule oneword");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("reschedule to 6pm");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("reschedule 1 to nonsense");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    private void
        assertSameFields(RescheduleTaskCommand rescheduleTaskCommand, int taskId, boolean isDateSpecified,
            boolean isTimeSpecified, DateTimeObject shiftedDateTime, LocalDateTime startDateTime,
            LocalDateTime endDateTime) {
        Assert.assertEquals(rescheduleTaskCommand.getScreenId(), taskId);
        Assert.assertEquals(rescheduleTaskCommand.isShiftedDateSpecified(), isDateSpecified);
        Assert.assertEquals(rescheduleTaskCommand.isShiftedTimeSpecified(), isTimeSpecified);

        if (shiftedDateTime != null) {
            Assert.assertNull(shiftedDateTime.getEndDateTime());
            Assert.assertNotNull(shiftedDateTime.getStartDateTime());
            assertSameDateTime(rescheduleTaskCommand.getShiftedDateTime(), shiftedDateTime.getStartDateTime());
        } else {
            Assert.assertNull(rescheduleTaskCommand.getShiftedDateTime());
        }
        if (startDateTime != null) {
            assertSameDateTime(rescheduleTaskCommand.getStartDateTime(), startDateTime);
        } else {
            Assert.assertNull(rescheduleTaskCommand.getStartDateTime());
        }
        if (endDateTime != null) {
            assertSameDateTime(rescheduleTaskCommand.getEndDateTime(), endDateTime);
        } else {
            Assert.assertNull(rescheduleTaskCommand.getEndDateTime());
        }

    }

    private void assertSameDateTime(LocalDateTime dateTime, LocalDateTime dateTime2) {
        Assert.assertNotNull(dateTime);
        Assert.assertNotNull(dateTime2);
        Assert.assertEquals(dateTime.getYear(), dateTime2.getYear());
        Assert.assertEquals(dateTime.getMonth(), dateTime2.getMonth());
        Assert.assertEquals(dateTime.getDayOfMonth(), dateTime2.getDayOfMonth());
        Assert.assertEquals(dateTime.getMinute(), dateTime2.getMinute());
        Assert.assertEquals(dateTime.getHour(), dateTime2.getHour());
    }

    private DateTimeObject getDateTimeObject(String dateTime) {
        DateTimeObject dateTimeObject = null;
        try {
            dateTimeObject = dateTimeParser.parseDateTime(dateTime);
        } catch (BadDateTimeException e) {
            Assert.fail();
        }
        return dateTimeObject;
    }

}
```
###### ./src/test/java/jfdi/test/parser/SearchCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.SearchCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.SearchCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class SearchCommandParserTest {

    AbstractCommandParser parser = SearchCommandParser.getInstance();

    @Before
    public void init() {
        parser = SearchCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, SearchCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("search happy");
        Assert.assertTrue(command instanceof SearchCommand);
        SearchCommand searchCommand = (SearchCommand) command;
        assertSameKeywords(searchCommand.getKeywords(), "happy");

        command = parser.build("search i am am happy");
        Assert.assertTrue(command instanceof SearchCommand);
        searchCommand = (SearchCommand) command;
        assertSameKeywords(searchCommand.getKeywords(), "i", "am", "am", "happy");

        command = parser.build("search CS2106 Project Work 23/13 ");
        Assert.assertTrue(command instanceof SearchCommand);
        searchCommand = (SearchCommand) command;
        assertSameKeywords(searchCommand.getKeywords(), "CS2106", "Project", "Work", "23/13");
    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("delete 1-5");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: no arguments
        command = parser.build("search");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    private void assertSameKeywords(HashSet<String> searchCommand, String... expected) {
        List<String> expectedKeywords = Arrays.asList(expected);
        for (String keyword : searchCommand) {
            Assert.assertTrue(expectedKeywords.contains(keyword));
        }

        for (String keyword : expectedKeywords) {
            Assert.assertTrue(searchCommand.contains(keyword));
        }

    }

}
```
###### ./src/test/java/jfdi/test/parser/UnaliasCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.UnaliasCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.UnaliasCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class UnaliasCommandParserTest {

    AbstractCommandParser parser = UnaliasCommandParser.getInstance();

    @Before
    public void init() {
        parser = UnaliasCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, UnaliasCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("unalias happy");
        Assert.assertTrue(command instanceof UnaliasCommand);
        UnaliasCommand unaliasCommand = (UnaliasCommand) command;
        assertSameAlias(unaliasCommand.getAlias(), "happy");

        command = parser.build("unalias 12345");
        Assert.assertTrue(command instanceof UnaliasCommand);
        unaliasCommand = (UnaliasCommand) command;
        assertSameAlias(unaliasCommand.getAlias(), "12345");

        command = parser.build("unalias q");
        Assert.assertTrue(command instanceof UnaliasCommand);
        unaliasCommand = (UnaliasCommand) command;
        assertSameAlias(unaliasCommand.getAlias(), "q");
    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("delete 1-5");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: no arguments
        command = parser.build("search");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

    private void assertSameAlias(String alias, String expected) {
        Assert.assertTrue(alias.equals(expected));
    }

}
```
###### ./src/test/java/jfdi/test/parser/UndoCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.UndoCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.UndoCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class UndoCommandParserTest {

    AbstractCommandParser parser = UndoCommandParser.getInstance();

    @Before
    public void init() {
        parser = UndoCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, UndoCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("undo");
        Assert.assertTrue(command instanceof UndoCommand);
        command = parser.build("Undo");
        Assert.assertTrue(command instanceof UndoCommand);
        command = parser.build("UNdo");
        Assert.assertTrue(command instanceof UndoCommand);
    }

    @Test
    public void testInvalidCommand() {
        // Multiple words
        Command command = parser.build("surprise me");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("surprise! me too");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        command = parser.build("add 1-8");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);

    }

}
```
###### ./src/test/java/jfdi/test/parser/UnmarkCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.UnmarkTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.UnmarkCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import edu.emory.mathcs.backport.java.util.Arrays;

public class UnmarkCommandParserTest {

    AbstractCommandParser parser = UnmarkCommandParser.getInstance();

    @Before
    public void init() {
        parser = UnmarkCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, UnmarkCommandParser.getInstance());
    }

    @Test
    public void testValidUnmarkInput() {
        Command command = parser.build("Unmark 1");
        UnmarkTaskCommand unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1);

        command = parser.build("unmark 1 2 3");
        unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1, 2, 3);

        command = parser.build("Unmark 1, 2, 3");
        unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1, 2, 3);

        command = parser.build("Unmark 1, 2    3");
        unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1, 2, 3);

        command = parser.build("unmARk 1, 2-9, 20, 43");
        unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20, 43);

        command = parser.build("Unmark 1-3 2-9");
        unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9);

        command = parser.build("Unmark 1    -3,   2-  9");
        unmarkCommand = validateAndReturnUnmarkCommand(command);
        validateUnmarkType(unmarkCommand, 1, 2, 3, 4, 5, 6, 7, 8, 9);
    }

    @Test
    public void testInvalidUnmarkInput() {
        Command command = parser.build("Unmark");
        Assert.assertTrue(command instanceof InvalidCommand);

        command = parser.build("Unmark 11-9");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        try {
            command = parser.build("List 1-8");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: empty string
        try {
            command = parser.build("");
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }

        // Boundary case: null
        try {
            command = parser.build(null);
        } catch (AssertionError e) {
            Assert.assertTrue(true);
        }
    }

    private UnmarkTaskCommand validateAndReturnUnmarkCommand(Command cmd) {
        Assert.assertNotNull(cmd);
        Assert.assertTrue(cmd instanceof UnmarkTaskCommand);

        return (UnmarkTaskCommand) cmd;
    }

    private void validateUnmarkType(UnmarkTaskCommand unmarkCommand,
        int... screenIds) {
        int[] screenIdsInUnmarkCommand = unmarkCommand.getScreenIds().stream()
            .mapToInt(i -> i).toArray();
        Arrays.sort(screenIds);
        Arrays.sort(screenIdsInUnmarkCommand);
        Assert.assertArrayEquals(screenIds, screenIdsInUnmarkCommand);
    }
}
```
###### ./src/test/java/jfdi/test/parser/UseCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.UseDirectoryCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.UseCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class UseCommandParserTest {

    AbstractCommandParser parser = UseCommandParser.getInstance();

    @Before
    public void init() {
        parser = UseCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, UseCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("use happy");
        Assert.assertTrue(command instanceof UseDirectoryCommand);
        UseDirectoryCommand useCommand = (UseDirectoryCommand) command;
        Assert.assertEquals("happy", useCommand.getNewDirectory());

        command = parser.build("Use C://leonard hio/dir");
        Assert.assertTrue(command instanceof UseDirectoryCommand);
        useCommand = (UseDirectoryCommand) command;
        Assert.assertEquals("C://leonard hio/dir", useCommand.getNewDirectory());

        command = parser.build("Use 12343 45451 15454 56 6 6");
        Assert.assertTrue(command instanceof UseDirectoryCommand);
        useCommand = (UseDirectoryCommand) command;
        Assert.assertEquals("12343 45451 15454 56 6 6", useCommand.getNewDirectory());
    }

    @Test
    public void testInvalidCommand() {

        // Boundary case: wrong command
        Command command = parser.build("surprise me");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("add hello");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: no arguments
        command = parser.build("Use");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

}
```
###### ./src/test/java/jfdi/test/parser/WildcardCommandParserTest.java
``` java

package jfdi.test.parser;

import static org.junit.Assert.assertSame;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.WildcardCommand;
import jfdi.logic.interfaces.Command;
import jfdi.parser.commandparsers.AbstractCommandParser;
import jfdi.parser.commandparsers.WildcardCommandParser;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class WildcardCommandParserTest {

    AbstractCommandParser parser = WildcardCommandParser.getInstance();

    @Before
    public void init() {
        parser = WildcardCommandParser.getInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(parser, WildcardCommandParser.getInstance());
    }

    @Test
    public void testValidCommand() {
        Command command = parser.build("surprise");
        Assert.assertTrue(command instanceof WildcardCommand);
        command = parser.build("surprise!");
        Assert.assertTrue(command instanceof WildcardCommand);
        command = parser.build("Surprise!!!");
        Assert.assertTrue(command instanceof WildcardCommand);
        command = parser.build("suRPriSe!!!!!");
        Assert.assertTrue(command instanceof WildcardCommand);
    }

    @Test
    public void testInvalidCommand() {
        // Multiple words
        Command command = parser.build("surprise me");
        Assert.assertTrue(command instanceof InvalidCommand);
        command = parser.build("surprise! me too");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: wrong command
        command = parser.build("add 1-8");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: empty string
        command = parser.build("");
        Assert.assertTrue(command instanceof InvalidCommand);

        // Boundary case: null
        command = parser.build(null);
        Assert.assertTrue(command instanceof InvalidCommand);
    }

}
```
