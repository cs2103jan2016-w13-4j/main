# A0130195M
###### ./build/reports/jacoco/test/html/jfdi.logic/ControlCenter.java.html
``` html

package jfdi.logic;

import com.google.common.eventbus.EventBus;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.InitializationFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.logic.interfaces.ILogic;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.*;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import jfdi.ui.UI;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ControlCenter implements ILogic {

    private static ControlCenter ourInstance;

<span class="fc" id="L30">    private static EventBus eventBus = UI.getEventBus();</span>

<span class="fc" id="L32">    private static MainStorage mainStorage = MainStorage.getInstance();</span>
<span class="fc" id="L33">    private static TaskDb taskDb = TaskDb.getInstance();</span>
<span class="fc" id="L34">    private static AliasDb aliasDb = AliasDb.getInstance();</span>

<span class="fc" id="L36">    private static InputParser parser = InputParser.getInstance();</span>

<span class="fc" id="L38">    private ControlCenter() {</span>
<span class="fc" id="L39">        initStorage();</span>
<span class="fc" id="L40">        initParser();</span>
<span class="fc" id="L41">    }</span>

    public static ControlCenter getInstance() {
<span class="fc bfc" id="L44" title="All 2 branches covered.">        if (ourInstance == null) {</span>
<span class="fc" id="L45">            ourInstance = new ControlCenter();</span>
        }
<span class="fc" id="L47">        return ourInstance;</span>
    }

    @Override
    public void handleInput(String input) {
        Command command;
        try {
<span class="fc" id="L54">            command = parser.parse(input);</span>
<span class="fc" id="L55">        } catch (InvalidInputException e) {</span>
<span class="fc" id="L56">            command = new InvalidCommand.Builder().build();</span>
<span class="fc" id="L57">        }</span>
<span class="fc" id="L58">        command.execute();</span>
<span class="fc" id="L59">    }</span>

    @Override
    public TreeSet&lt;String&gt; getKeywords() {
<span class="fc" id="L63">        TreeSet&lt;String&gt; keywords = Arrays.stream(InputParser.getInstance()</span>
<span class="fc" id="L64">            .getAllCommandRegexes()</span>
<span class="fc" id="L65">            .replaceAll(&quot;\\W+&quot;, &quot; &quot;).split(&quot;\\s+&quot;))</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            .filter(part -&gt; part.length() &gt; 1)</span>
<span class="fc" id="L67">            .collect(Collectors.toCollection(TreeSet::new));</span>

<span class="fc" id="L69">        AliasDb.getInstance()</span>
<span class="fc" id="L70">            .getAll().stream()</span>
<span class="fc" id="L71">            .map(AliasAttributes::getAlias)</span>
<span class="fc" id="L72">            .forEach(keywords::add);</span>

<span class="fc" id="L74">        return keywords;</span>
    }

    @Override
    public ArrayList&lt;TaskAttributes&gt; getIncompleteTasks() {
<span class="fc" id="L79">        return taskDb.getAll().stream()</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">            .filter(task -&gt; !task.isCompleted())</span>
<span class="fc" id="L81">            .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public ArrayList&lt;TaskAttributes&gt; getCompletedTasks() {
<span class="fc" id="L86">        return taskDb.getAll().stream()</span>
<span class="fc" id="L87">            .filter(TaskAttributes::isCompleted)</span>
<span class="fc" id="L88">            .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public ArrayList&lt;TaskAttributes&gt; getAllTasks() {
<span class="fc" id="L93">        return taskDb.getAll().stream()</span>
<span class="fc" id="L94">            .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public ArrayList&lt;TaskAttributes&gt; getUpcomingTasks() {
<span class="fc" id="L99">        return taskDb.getUpcoming().stream()</span>
<span class="fc" id="L100">            .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public ArrayList&lt;TaskAttributes&gt; getOverdueTasks() {
<span class="fc" id="L105">        return taskDb.getOverdue().stream()</span>
<span class="fc" id="L106">            .collect(Collectors.toCollection(ArrayList::new));</span>
    }

    private void initStorage() {
        // Set a list of permitted commands that can be aliased
<span class="fc" id="L111">        AliasAttributes.setCommandRegex(parser.getAllCommandRegexes());</span>
        try {
<span class="fc" id="L113">            mainStorage.initialize();</span>
<span class="fc" id="L114">        } catch (FilesReplacedException e) {</span>
<span class="fc" id="L115">            eventBus.post(new FilesReplacedEvent(e.getReplacedFilePairs()));</span>
<span class="fc" id="L116">        } catch (InvalidFilePathException e) {</span>
<span class="fc" id="L117">            eventBus.post(new InitializationFailedEvent(InitializationFailedEvent.Error.INVALID_PATH,</span>
<span class="fc" id="L118">                e.getPath()));</span>
<span class="fc" id="L119">        }</span>
<span class="fc" id="L120">    }</span>

    private void initParser() {
<span class="fc" id="L123">        parser.setAliases(aliasDb.getAll());</span>
<span class="fc" id="L124">    }</span>

    //================================================================
    // Methods for testing.
    //================================================================

    public static void removeInstance() {
<span class="fc" id="L131">        ourInstance = null;</span>
<span class="fc" id="L132">    }</span>

    public static void setParser(InputParser parser) {
<span class="fc" id="L135">        ControlCenter.parser = parser;</span>
<span class="fc" id="L136">    }</span>

    public static void setMainStorage(MainStorage mainStorage) {
<span class="fc" id="L139">        ControlCenter.mainStorage = mainStorage;</span>
<span class="fc" id="L140">    }</span>

    public static void setTaskDb(TaskDb taskDb) {
<span class="fc" id="L143">        ControlCenter.taskDb = taskDb;</span>
<span class="fc" id="L144">    }</span>

    public static void setAliasDb(AliasDb aliasDb) {
<span class="fc" id="L147">        ControlCenter.aliasDb = aliasDb;</span>
<span class="fc" id="L148">    }</span>

    public static void setEventBus(EventBus eventBus) {
<span class="fc" id="L151">        ControlCenter.eventBus = eventBus;</span>
<span class="fc" id="L152">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/AddTaskCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.logic.events.AddTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.LocalDateTime;
import java.util.Optional;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L20" title="1 of 2 branches missed.">public class AddTaskCommand extends Command {</span>

    private String description;
    private Optional&lt;LocalDateTime&gt; startDateTime;
    private Optional&lt;LocalDateTime&gt; endDateTime;
<span class="fc" id="L25">    private int id = -1;</span>

<span class="fc" id="L27">    private AddTaskCommand(Builder builder) {</span>
<span class="fc" id="L28">        this.description = builder.description;</span>
<span class="fc" id="L29">        this.startDateTime = Optional.ofNullable(builder.startDateTime);</span>
<span class="fc" id="L30">        this.endDateTime = Optional.ofNullable(builder.endDateTime);</span>
<span class="fc" id="L31">    }</span>

    public String getDescription() {
<span class="fc" id="L34">        return description;</span>
    }

    public Optional&lt;LocalDateTime&gt; getStartDateTime() {
<span class="fc" id="L38">        return startDateTime;</span>
    }

    public Optional&lt;LocalDateTime&gt; getEndDateTime() {
<span class="fc" id="L42">        return endDateTime;</span>
    }

    public int getId() {
<span class="fc" id="L46">        return id;</span>
    }

<span class="fc" id="L49">    public static class Builder {</span>

        String description;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setDescription(String description) {
<span class="fc" id="L56">            this.description = description;</span>
<span class="fc" id="L57">            return this;</span>
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
<span class="fc" id="L61">            this.startDateTime = startDateTime;</span>
<span class="fc" id="L62">            return this;</span>
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
<span class="fc" id="L66">            this.endDateTime = endDateTime;</span>
<span class="fc" id="L67">            return this;</span>
        }

        public AddTaskCommand build() {
<span class="fc" id="L71">            return new AddTaskCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L78">        TaskAttributes task = new TaskAttributes();</span>
<span class="fc" id="L79">        task.setDescription(description);</span>
<span class="fc" id="L80">        startDateTime.ifPresent(task::setStartDateTime);</span>
<span class="fc" id="L81">        endDateTime.ifPresent(task::setEndDateTime);</span>
        try {
<span class="fc" id="L83">            task.save();</span>
<span class="fc" id="L84">            this.id = task.getId();</span>

<span class="fc" id="L86">            pushToUndoStack();</span>
<span class="fc" id="L87">            eventBus.post(new AddTaskDoneEvent(task));</span>
<span class="fc" id="L88">        } catch (InvalidTaskParametersException e) {</span>
<span class="fc" id="L89">            eventBus.post(new AddTaskFailedEvent(</span>
                AddTaskFailedEvent.Error.EMPTY_DESCRIPTION));
<span class="fc" id="L91">        } catch (DuplicateTaskException e) {</span>
<span class="fc" id="L92">            eventBus.post(new AddTaskFailedEvent(</span>
                AddTaskFailedEvent.Error.DUPLICATED_TASK));
<span class="nc" id="L94">        } catch (NoAttributesChangedException | InvalidIdException e) {</span>
            // Should not happen for creating tasks
<span class="nc bnc" id="L96" title="All 2 branches missed.">            assert false;</span>
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">    }</span>

    @Override
    public void undo() {
        try {
<span class="fc" id="L103">            taskDb.destroy(id);</span>

<span class="fc" id="L105">            pushToRedoStack();</span>
<span class="fc" id="L106">        } catch (InvalidIdException e) {</span>
            // Should not happen for creating tasks
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L109">        }</span>
<span class="fc" id="L110">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/AliasCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.AliasDoneEvent;
import jfdi.logic.events.AliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L16" title="1 of 2 branches missed.">public class AliasCommand extends Command {</span>

    private String command;
    private String alias;
    private boolean isValid;

<span class="fc" id="L22">    private AliasCommand(Builder builder) {</span>
<span class="fc" id="L23">        this.command = builder.command;</span>
<span class="fc" id="L24">        this.alias = builder.alias;</span>
<span class="fc" id="L25">        this.isValid = builder.isValid;</span>
<span class="fc" id="L26">    }</span>

    public String getCommand() {
<span class="fc" id="L29">        return command;</span>
    }

    public String getAlias() {
<span class="fc" id="L33">        return alias;</span>
    }

    public boolean isValid() {
<span class="fc" id="L37">        return isValid;</span>
    }

<span class="fc" id="L40">    public static class Builder {</span>

        String command;
        String alias;
        boolean isValid;

        public Builder setCommand(String command) {
<span class="fc" id="L47">            this.command = command;</span>
<span class="fc" id="L48">            return this;</span>
        }

        public Builder setAlias(String alias) {
<span class="fc" id="L52">            this.alias = alias;</span>
<span class="fc" id="L53">            return this;</span>
        }

        public Builder setIsValid(boolean isValid) {
<span class="fc" id="L57">            this.isValid = isValid;</span>
<span class="fc" id="L58">            return this;</span>
        }

        public AliasCommand build() {
<span class="fc" id="L62">            return new AliasCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L69">        AliasAttributes newAlias = new AliasAttributes(alias, command);</span>
        try {
<span class="fc" id="L71">            newAlias.save();</span>
<span class="fc" id="L72">            parser.setAliases(aliasDb.getAll());</span>

<span class="fc" id="L74">            pushToUndoStack();</span>
<span class="fc" id="L75">            eventBus.post(new AliasDoneEvent(command, alias));</span>
<span class="fc" id="L76">        } catch (InvalidAliasParametersException e) {</span>
<span class="fc" id="L77">            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.INVALID_PARAMETERS));</span>
<span class="fc" id="L78">        } catch (DuplicateAliasException e) {</span>
<span class="fc" id="L79">            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.DUPLICATED_ALIAS));</span>
<span class="fc" id="L80">        }</span>
<span class="fc" id="L81">    }</span>

    @Override
    public void undo() {
        try {
<span class="fc" id="L86">            aliasDb.destroy(alias);</span>
<span class="fc" id="L87">            parser.setAliases(aliasDb.getAll());</span>

<span class="fc" id="L89">            pushToRedoStack();</span>
<span class="fc" id="L90">        } catch (InvalidAliasException e) {</span>
            // Should not happen
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/DeleteTaskCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.logic.events.DeleteTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L19" title="1 of 2 branches missed.">public class DeleteTaskCommand extends Command {</span>

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;TaskAttributes&gt; deletedTasks;

<span class="fc" id="L24">    private DeleteTaskCommand(Builder builder) {</span>
<span class="fc" id="L25">        this.screenIds = builder.screenIds;</span>
<span class="fc" id="L26">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L29">        return screenIds;</span>
    }

    public ArrayList&lt;TaskAttributes&gt; getDeletedTasks() {
<span class="fc" id="L33">        return deletedTasks;</span>
    }

<span class="fc" id="L36">    public static class Builder {</span>

<span class="fc" id="L38">        ArrayList&lt;Integer&gt; screenIds = new ArrayList&lt;&gt;();</span>

        public Builder addId(int id) {
<span class="fc" id="L41">            screenIds.add(id);</span>
<span class="fc" id="L42">            return this;</span>
        }

        public Builder addIds(Collection&lt;Integer&gt; ids) {
<span class="fc" id="L46">            screenIds.addAll(ids);</span>
<span class="fc" id="L47">            return this;</span>
        }

        public DeleteTaskCommand build() {
<span class="fc" id="L51">            return new DeleteTaskCommand(this);</span>
        }

    }



    @Override
    public void execute() {
<span class="fc" id="L60">        ArrayList&lt;Integer&gt; taskIds = screenIds.stream().map(ui::getTaskId)</span>
<span class="fc" id="L61">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc" id="L63">        ArrayList&lt;Integer&gt; invalidIds = screenIds.stream()</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            .filter(id -&gt; !taskDb.hasId(ui.getTaskId(id)))</span>
<span class="fc" id="L65">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (invalidIds.isEmpty()) {</span>
<span class="fc" id="L68">            deletedTasks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L69">            taskIds.forEach(id -&gt; {</span>
                try {
<span class="fc" id="L71">                    deletedTasks.add(taskDb.getById(id));</span>
<span class="fc" id="L72">                    logger.info(&quot;Deleting task #&quot; + id);</span>
<span class="fc" id="L73">                    taskDb.destroy(id);</span>
<span class="fc" id="L74">                } catch (InvalidIdException e) {</span>
                    // Should not happen
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">                    assert false;</span>
<span class="fc" id="L77">                }</span>
<span class="fc" id="L78">            });</span>

<span class="fc" id="L80">            pushToUndoStack();</span>
<span class="fc" id="L81">            eventBus.post(new DeleteTaskDoneEvent(screenIds, deletedTasks));</span>
        } else {
<span class="fc" id="L83">            eventBus.post(new DeleteTaskFailedEvent(invalidIds));</span>
        }
<span class="fc" id="L85">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L89">        deletedTasks.stream().forEach(task -&gt; {</span>
            try {
<span class="fc" id="L91">                taskDb.undestroy(task.getId());</span>
<span class="fc" id="L92">            } catch (InvalidIdException | DuplicateTaskException e) {</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                assert false;</span>
<span class="fc" id="L94">            }</span>
<span class="fc" id="L95">        });</span>

<span class="fc" id="L97">        pushToRedoStack();</span>
<span class="fc" id="L98">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/DirectoryCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.ShowDirectoryEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L11" title="1 of 2 branches missed.">public class DirectoryCommand extends Command {</span>

<span class="fc" id="L13">    private DirectoryCommand(Builder builder) {}</span>

<span class="fc" id="L15">    public static class Builder {</span>

        public DirectoryCommand build() {
<span class="fc" id="L18">            return new DirectoryCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L25">        String pwd = mainStorage.getCurrentDirectory();</span>
<span class="fc" id="L26">        eventBus.post(new ShowDirectoryEvent(pwd));</span>
<span class="fc" id="L27">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L31" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L32">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/ExitCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.ExitCalledEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L11" title="1 of 2 branches missed.">public class ExitCommand extends Command {</span>

<span class="fc" id="L13">    private ExitCommand(Builder builder) {}</span>

<span class="fc" id="L15">    public static class Builder {</span>

        public ExitCommand build() {
<span class="fc" id="L18">            return new ExitCommand(this);</span>
        }

    }

    @Override
    public void execute() {
        // Nothing needs to be done.
        // Post an event to notify UI to exit.
<span class="fc" id="L27">        eventBus.post(new ExitCalledEvent());</span>
<span class="fc" id="L28">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L33">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/HelpCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.HelpRequestedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L11" title="1 of 2 branches missed.">public class HelpCommand extends Command {</span>

<span class="fc" id="L13">    private HelpCommand(Builder builder) {}</span>

<span class="fc" id="L15">    public static class Builder {</span>

        public HelpCommand build() {
<span class="fc" id="L18">            return new HelpCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L25">        eventBus.post(new HelpRequestedEvent());</span>
<span class="fc" id="L26">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L31">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/InvalidCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L12" title="1 of 2 branches missed.">public class InvalidCommand extends Command {</span>

    private String inputString;
    private CommandType commandType;

<span class="fc" id="L17">    private InvalidCommand(Builder builder) {</span>
<span class="fc" id="L18">        this.inputString = builder.inputString;</span>
<span class="fc" id="L19">        this.commandType = builder.commandType;</span>
<span class="fc" id="L20">    }</span>

<span class="fc" id="L22">    public static class Builder {</span>

<span class="fc" id="L24">        String inputString = &quot;&quot;;</span>
<span class="fc" id="L25">        CommandType commandType = null;</span>

        public Builder setInputString(String inputString) {
<span class="fc" id="L28">            this.inputString = inputString;</span>
<span class="fc" id="L29">            return this;</span>
        }

        public Builder setCommandType(CommandType commandType) {
<span class="fc" id="L33">            this.commandType = commandType;</span>
<span class="fc" id="L34">            return this;</span>
        }

        public InvalidCommand build() {
<span class="fc" id="L38">            return new InvalidCommand(this);</span>
        }

    }

    public String getInputString() {
<span class="fc" id="L44">        return inputString;</span>
    }

    public CommandType getCommandType() {
<span class="fc" id="L48">        return commandType;</span>
    }

    @Override
    public void execute() {
        // Invalid command always fail.
<span class="fc" id="L54">        eventBus.post(new InvalidCommandEvent(inputString, commandType));</span>
<span class="fc" id="L55">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L60">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/ListCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.ListDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L15" title="1 of 2 branches missed.">public class ListCommand extends Command {</span>

<span class="pc" id="L17">    public enum ListType {</span>
<span class="fc" id="L18">        ALL,</span>
<span class="fc" id="L19">        COMPLETED,</span>
<span class="fc" id="L20">        INCOMPLETE,</span>
<span class="fc" id="L21">        OVERDUE,</span>
<span class="fc" id="L22">        UPCOMING</span>
    }

    private ListType listType;

<span class="fc" id="L27">    private ListCommand(Builder builder) {</span>
<span class="fc" id="L28">        this.listType = builder.listType;</span>
<span class="fc" id="L29">    }</span>

<span class="fc" id="L31">    public static class Builder {</span>

        ListType listType;

        public Builder setListType(ListType listType) {
<span class="fc" id="L36">            this.listType = listType;</span>
<span class="fc" id="L37">            return this;</span>
        }

        public ListCommand build() {
<span class="fc" id="L41">            return new ListCommand(this);</span>
        }
    }

    public ListType getListType() {
<span class="fc" id="L46">        return this.listType;</span>
    }

    @Override
    public void execute() {
<span class="fc" id="L51">        ArrayList&lt;TaskAttributes&gt; tasks = taskDb.getAll().stream()</span>
<span class="fc" id="L52">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="pc bfc" id="L54" title="All 5 branches covered.">        switch (listType) {</span>
            case COMPLETED:
<span class="fc" id="L56">                tasks = tasks.stream()</span>
<span class="fc" id="L57">                    .filter(TaskAttributes::isCompleted)</span>
<span class="fc" id="L58">                    .collect(Collectors.toCollection(ArrayList::new));</span>
<span class="fc" id="L59">                break;</span>
            case INCOMPLETE:
<span class="fc" id="L61">                tasks = tasks.stream()</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                    .filter(task -&gt; !task.isCompleted())</span>
<span class="fc" id="L63">                    .collect(Collectors.toCollection(ArrayList::new));</span>
<span class="fc" id="L64">                break;</span>
            case OVERDUE:
<span class="fc" id="L66">                tasks = taskDb.getOverdue().stream()</span>
<span class="fc" id="L67">                    .sorted()</span>
<span class="fc" id="L68">                    .collect(Collectors.toCollection(ArrayList::new));</span>
<span class="fc" id="L69">                break;</span>
            case UPCOMING:
<span class="fc" id="L71">                tasks = taskDb.getUpcoming().stream()</span>
<span class="fc" id="L72">                    .sorted()</span>
<span class="fc" id="L73">                    .collect(Collectors.toCollection(ArrayList::new));</span>
<span class="fc" id="L74">                break;</span>
            default:
                break;
        }

<span class="fc" id="L79">        eventBus.post(new ListDoneEvent(listType, tasks));</span>
<span class="fc" id="L80">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L85">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/MarkTaskCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.logic.events.MarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">public class MarkTaskCommand extends Command {</span>

<span class="fc" id="L23">    private static final Logger logger = JfdiLogger.getLogger();</span>

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;Integer&gt; markedIds;

<span class="fc" id="L28">    private MarkTaskCommand(Builder builder) {</span>
<span class="fc" id="L29">        this.screenIds = builder.screenIds;</span>
<span class="fc" id="L30">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L33">        return screenIds;</span>
    }

    public ArrayList&lt;Integer&gt; getMarkedIds() {
<span class="fc" id="L37">        return markedIds;</span>
    }

<span class="fc" id="L40">    public static class Builder {</span>

<span class="fc" id="L42">        ArrayList&lt;Integer&gt; screenIds = new ArrayList&lt;&gt;();</span>

        public Builder addTaskId(int id) {
<span class="fc" id="L45">            screenIds.add(id);</span>
<span class="fc" id="L46">            return this;</span>
        }

        public Builder addTaskIds(Collection&lt;Integer&gt; ids) {
<span class="fc" id="L50">            screenIds.addAll(ids);</span>
<span class="fc" id="L51">            return this;</span>
        }

        public MarkTaskCommand build() {
<span class="fc" id="L55">            return new MarkTaskCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L62">        ArrayList&lt;Integer&gt; taskIds = screenIds.stream().map(ui::getTaskId)</span>
<span class="fc" id="L63">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc" id="L65">        ArrayList&lt;Integer&gt; invalidIds = screenIds.stream()</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            .filter(id -&gt; !taskDb.hasId(ui.getTaskId(id)))</span>
<span class="fc" id="L67">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (invalidIds.isEmpty()) {</span>
<span class="fc" id="L70">            ArrayList&lt;TaskAttributes&gt; markedTasks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L71">            markedIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L72">            taskIds.stream().forEach(id -&gt; {</span>
                try {
<span class="fc" id="L74">                    markedTasks.add(taskDb.getById(id));</span>
<span class="fc" id="L75">                    taskDb.markAsComplete(id);</span>
<span class="fc" id="L76">                    markedIds.add(id);</span>
<span class="fc" id="L77">                } catch (NoAttributesChangedException e) {</span>
<span class="fc" id="L78">                    logger.warning(&quot;Task &quot; + id + &quot; is already completed.&quot;);</span>
<span class="fc" id="L79">                } catch (InvalidIdException e) {</span>
                    // Should not happen!
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                    assert false;</span>
<span class="fc" id="L82">                }</span>
<span class="fc" id="L83">            });</span>

<span class="fc" id="L85">            pushToUndoStack();</span>
<span class="fc" id="L86">            eventBus.post(new MarkTaskDoneEvent(screenIds, markedTasks));</span>
<span class="fc" id="L87">        } else {</span>
<span class="fc" id="L88">            eventBus.post(new MarkTaskFailedEvent(screenIds, invalidIds));</span>
        }
<span class="fc" id="L90">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L94">        markedIds.stream().forEach(id -&gt; {</span>
            try {
<span class="fc" id="L96">                taskDb.markAsIncomplete(id);</span>
<span class="fc" id="L97">            } catch (NoAttributesChangedException | InvalidIdException e) {</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">                assert false;</span>
<span class="fc" id="L99">            }</span>
<span class="fc" id="L100">        });</span>

<span class="fc" id="L102">        pushToRedoStack();</span>
<span class="fc" id="L103">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/MoveDirectoryCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.MoveDirectoryDoneEvent;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L15" title="1 of 2 branches missed.">public class MoveDirectoryCommand extends Command {</span>

    private String oldDirectory;
    private String newDirectory;

<span class="fc" id="L20">    private MoveDirectoryCommand(Builder builder) {</span>
<span class="fc" id="L21">        this.newDirectory = builder.newDirectory;</span>
<span class="fc" id="L22">    }</span>

<span class="fc" id="L24">    public static class Builder {</span>

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
<span class="fc" id="L29">            this.newDirectory = newDirectory;</span>
<span class="fc" id="L30">            return this;</span>
        }

        public MoveDirectoryCommand build() {
<span class="fc" id="L34">            return new MoveDirectoryCommand(this);</span>
        }

    }

    public String getOldDirectory() {
<span class="fc" id="L40">        return oldDirectory;</span>
    }

    public String getNewDirectory() {
<span class="fc" id="L44">        return newDirectory;</span>
    }

    @Override
    public void execute() {
        try {
<span class="fc" id="L50">            oldDirectory = mainStorage.getCurrentDirectory();</span>

<span class="fc" id="L52">            mainStorage.changeDirectory(newDirectory);</span>

<span class="fc" id="L54">            pushToUndoStack();</span>
<span class="fc" id="L55">            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));</span>
<span class="fc" id="L56">        } catch (FilesReplacedException e) {</span>
<span class="fc" id="L57">            pushToUndoStack();</span>
<span class="fc" id="L58">            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));</span>
<span class="fc" id="L59">            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));</span>
<span class="fc" id="L60">        } catch (InvalidFilePathException e) {</span>
<span class="fc" id="L61">            eventBus.post(new MoveDirectoryFailedEvent(newDirectory, MoveDirectoryFailedEvent.Error.INVALID_PATH));</span>
<span class="fc" id="L62">        }</span>
<span class="fc" id="L63">    }</span>

    @Override
    public void undo() {
        try {
<span class="fc" id="L68">            mainStorage.changeDirectory(oldDirectory);</span>

<span class="fc" id="L70">            pushToRedoStack();</span>
<span class="fc" id="L71">        } catch (InvalidFilePathException e) {</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L73">        } catch (FilesReplacedException e) {</span>
<span class="fc" id="L74">            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));</span>
<span class="pc" id="L75">        }</span>
<span class="fc" id="L76">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/RenameTaskCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.logic.events.RenameTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L17" title="1 of 2 branches missed.">public class RenameTaskCommand extends Command {</span>

    private int screenId;
    private String description;
    private String oldDescription;

<span class="fc" id="L23">    private RenameTaskCommand(Builder builder) {</span>
<span class="fc" id="L24">        this.screenId = builder.screenId;</span>
<span class="fc" id="L25">        this.description = builder.description;</span>
<span class="fc" id="L26">    }</span>

    public int getScreenId() {
<span class="fc" id="L29">        return screenId;</span>
    }

    public String getDescription() {
<span class="fc" id="L33">        return description;</span>
    }

    public String getOldDescription() {
<span class="fc" id="L37">        return oldDescription;</span>
    }

<span class="fc" id="L40">    public static class Builder {</span>

<span class="fc" id="L42">        int screenId = -1;</span>
        String description;

        public Builder setId(int screenId) {
<span class="fc" id="L46">            this.screenId = screenId;</span>
<span class="fc" id="L47">            return this;</span>
        }

        public Builder setDescription(String description) {
<span class="fc" id="L51">            this.description = description;</span>
<span class="fc" id="L52">            return this;</span>
        }

        public RenameTaskCommand build() {
<span class="fc" id="L56">            return new RenameTaskCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L63">        int taskId = ui.getTaskId(screenId);</span>

        try {
<span class="fc" id="L66">            TaskAttributes task = taskDb.getById(taskId);</span>
<span class="fc" id="L67">            oldDescription = task.getDescription();</span>

<span class="fc" id="L69">            task.setDescription(description);</span>
<span class="fc" id="L70">            task.save();</span>

<span class="fc" id="L72">            pushToUndoStack();</span>
<span class="fc" id="L73">            eventBus.post(new RenameTaskDoneEvent(task));</span>
<span class="fc" id="L74">        } catch (InvalidIdException e) {</span>
<span class="fc" id="L75">            eventBus.post(new RenameTaskFailedEvent(screenId, description,</span>
                          RenameTaskFailedEvent.Error.NON_EXISTENT_ID));
<span class="fc" id="L77">        } catch (NoAttributesChangedException e) {</span>
<span class="fc" id="L78">            eventBus.post(new RenameTaskFailedEvent(screenId, description,</span>
                          RenameTaskFailedEvent.Error.NO_CHANGES));
<span class="fc" id="L80">        } catch (DuplicateTaskException e) {</span>
<span class="fc" id="L81">            eventBus.post(new RenameTaskFailedEvent(screenId, description,</span>
                          RenameTaskFailedEvent.Error.DUPLICATED_TASK));
<span class="fc" id="L83">        } catch (InvalidTaskParametersException e) {</span>
            // Should not happen
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L86">        }</span>
<span class="fc" id="L87">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L91">        int taskId = ui.getTaskId(screenId);</span>

        try {
<span class="fc" id="L94">            TaskAttributes task = taskDb.getById(taskId);</span>

<span class="fc" id="L96">            task.setDescription(oldDescription);</span>
<span class="fc" id="L97">            task.save();</span>

<span class="fc" id="L99">            pushToRedoStack();</span>
<span class="fc" id="L100">        } catch (InvalidIdException | NoAttributesChangedException | InvalidTaskParametersException</span>
               | DuplicateTaskException e) {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L103">        }</span>
<span class="fc" id="L104">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/RescheduleTaskCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.logic.events.RescheduleTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.Duration;
import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L20" title="1 of 2 branches missed.">public class RescheduleTaskCommand extends Command {</span>

    private int screenId;
    private boolean isShiftedDateSpecified;
    private boolean isShiftedTimeSpecified;
    private LocalDateTime shiftedDateTime;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime oldStartDateTime;
    private LocalDateTime oldEndDateTime;

<span class="fc" id="L31">    private RescheduleTaskCommand(Builder builder) {</span>
<span class="fc" id="L32">        this.screenId = builder.screenId;</span>
<span class="fc" id="L33">        this.isShiftedDateSpecified = builder.isShiftedDateSpecified;</span>
<span class="fc" id="L34">        this.isShiftedTimeSpecified = builder.isShiftedTimeSpecified;</span>
<span class="fc" id="L35">        this.shiftedDateTime = builder.shiftedDateTime;</span>
<span class="fc" id="L36">        this.startDateTime = builder.startDateTime;</span>
<span class="fc" id="L37">        this.endDateTime = builder.endDateTime;</span>
<span class="fc" id="L38">    }</span>

    public int getScreenId() {
<span class="fc" id="L41">        return screenId;</span>
    }

    public boolean isShiftedDateSpecified() {
<span class="fc" id="L45">        return isShiftedDateSpecified;</span>
    }

    public boolean isShiftedTimeSpecified() {
<span class="fc" id="L49">        return isShiftedTimeSpecified;</span>
    }

    public LocalDateTime getStartDateTime() {
<span class="fc" id="L53">        return startDateTime;</span>
    }

    public LocalDateTime getEndDateTime() {
<span class="fc" id="L57">        return endDateTime;</span>
    }

    public LocalDateTime getOldStartDateTime() {
<span class="fc" id="L61">        return oldStartDateTime;</span>
    }

    public LocalDateTime getOldEndDateTime() {
<span class="fc" id="L65">        return oldEndDateTime;</span>
    }

<span class="fc" id="L68">    public static class Builder {</span>

        int screenId;
<span class="fc" id="L71">        boolean isShiftedDateSpecified = false;</span>
<span class="fc" id="L72">        boolean isShiftedTimeSpecified = false;</span>
        LocalDateTime shiftedDateTime;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setId(int screenId) {
<span class="fc" id="L78">            this.screenId = screenId;</span>
<span class="fc" id="L79">            return this;</span>
        }

        public Builder setShiftedDateSpecified(boolean isShiftedDateSpecified) {
<span class="fc" id="L83">            this.isShiftedDateSpecified = isShiftedDateSpecified;</span>
<span class="fc" id="L84">            return this;</span>
        }

        public Builder setShiftedTimeSpecified(boolean isShiftedTimeSpecified) {
<span class="fc" id="L88">            this.isShiftedTimeSpecified = isShiftedTimeSpecified;</span>
<span class="fc" id="L89">            return this;</span>
        }

        public Builder setShiftedDateTime(LocalDateTime shiftedDateTime) {
<span class="fc" id="L93">            this.shiftedDateTime = shiftedDateTime;</span>
<span class="fc" id="L94">            return this;</span>
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
<span class="fc" id="L98">            this.startDateTime = startDateTime;</span>
<span class="fc" id="L99">            return this;</span>
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
<span class="fc" id="L103">            this.endDateTime = endDateTime;</span>
<span class="fc" id="L104">            return this;</span>
        }

        public RescheduleTaskCommand build() {
<span class="fc" id="L108">            return new RescheduleTaskCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L115">        int taskId = ui.getTaskId(screenId);</span>

        try {
<span class="fc" id="L118">            TaskAttributes task = taskDb.getById(taskId);</span>

<span class="fc" id="L120">            oldStartDateTime = task.getStartDateTime();</span>
<span class="fc" id="L121">            oldEndDateTime = task.getEndDateTime();</span>

<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (shiftedDateTime != null) {</span>
<span class="fc" id="L124">                shiftStartAndEndDateTimes(task);</span>
            }

<span class="fc" id="L127">            task.setStartDateTime(startDateTime);</span>
<span class="fc" id="L128">            task.setEndDateTime(endDateTime);</span>
<span class="fc" id="L129">            task.save();</span>

<span class="fc" id="L131">            pushToUndoStack();</span>
<span class="fc" id="L132">            eventBus.post(new RescheduleTaskDoneEvent(task));</span>
<span class="fc" id="L133">        } catch (InvalidIdException e) {</span>
<span class="fc" id="L134">            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,</span>
                RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID));
<span class="fc" id="L136">        } catch (InvalidTaskParametersException e) {</span>
            // Should not happen
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L139">        } catch (NoAttributesChangedException e) {</span>
<span class="fc" id="L140">            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,</span>
                RescheduleTaskFailedEvent.Error.NO_CHANGES));
<span class="fc" id="L142">        } catch (DuplicateTaskException e) {</span>
<span class="fc" id="L143">            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,</span>
                RescheduleTaskFailedEvent.Error.DUPLICATED_TASK));
<span class="pc" id="L145">        }</span>
<span class="fc" id="L146">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L150">        int taskId = ui.getTaskId(screenId);</span>

        try {
<span class="fc" id="L153">            TaskAttributes task = taskDb.getById(taskId);</span>

<span class="fc" id="L155">            task.setStartDateTime(oldStartDateTime);</span>
<span class="fc" id="L156">            task.setEndDateTime(oldEndDateTime);</span>
<span class="fc" id="L157">            task.save();</span>

<span class="fc" id="L159">            pushToRedoStack();</span>
<span class="fc" id="L160">        } catch (InvalidIdException | InvalidTaskParametersException | NoAttributesChangedException</span>
            | DuplicateTaskException e) {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">    }</span>

    private void shiftStartAndEndDateTimes(TaskAttributes task) {
<span class="pc bpc" id="L167" title="2 of 4 branches missed.">        assert shiftedDateTime != null;</span>
<span class="pc bpc" id="L168" title="2 of 6 branches missed.">        assert isShiftedDateSpecified || isShiftedTimeSpecified;</span>
<span class="fc" id="L169">        LocalDateTime taskStart = task.getStartDateTime();</span>
<span class="fc" id="L170">        LocalDateTime taskEnd = task.getEndDateTime();</span>

<span class="fc bfc" id="L172" title="All 4 branches covered.">        if (taskStart == null &amp;&amp; taskEnd == null) {</span>
            // Set floating task to point task
<span class="fc" id="L174">            startDateTime = shiftedDateTime;</span>
<span class="fc" id="L175">            endDateTime = null;</span>

<span class="fc bfc" id="L177" title="All 4 branches covered.">        } else if (taskStart != null &amp;&amp; taskEnd == null) {</span>
            // Shift point task
<span class="fc" id="L179">            startDateTime = getShiftedDateTime(task.getStartDateTime());</span>
<span class="fc" id="L180">            endDateTime = null;</span>

<span class="pc bpc" id="L182" title="1 of 4 branches missed.">        } else if (taskStart == null &amp;&amp; taskEnd != null) {</span>
            // Shift deadline task
<span class="fc" id="L184">            startDateTime = null;</span>
<span class="fc" id="L185">            endDateTime = getShiftedDateTime(task.getEndDateTime());</span>

        } else {
            // Shift event, preserving duration
<span class="fc" id="L189">            Duration eventDuration = Duration.between(taskStart, taskEnd);</span>
<span class="fc" id="L190">            startDateTime = getShiftedDateTime(task.getStartDateTime());</span>
<span class="fc" id="L191">            endDateTime = startDateTime.plus(eventDuration);</span>
        }
<span class="fc" id="L193">    }</span>

    public LocalDateTime getShiftedDateTime() {
<span class="fc" id="L196">        return shiftedDateTime;</span>
    }

    private LocalDateTime getShiftedDateTime(LocalDateTime dateTime) {
<span class="fc bfc" id="L200" title="All 4 branches covered.">        if (isShiftedDateSpecified &amp;&amp; !isShiftedTimeSpecified) {</span>
<span class="fc" id="L201">            return shiftDate(dateTime);</span>
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">        } else if (!isShiftedDateSpecified &amp;&amp; isShiftedTimeSpecified) {</span>
<span class="fc" id="L203">            return shiftTime(dateTime);</span>
        } else {
<span class="fc" id="L205">            return shiftedDateTime;</span>
        }
    }

    private LocalDateTime shiftTime(LocalDateTime originalDateTime) {
<span class="pc bpc" id="L210" title="3 of 6 branches missed.">        assert originalDateTime != null &amp;&amp; shiftedDateTime != null;</span>
<span class="fc" id="L211">        return LocalDateTime.of(originalDateTime.toLocalDate(), shiftedDateTime.toLocalTime());</span>
    }

    private LocalDateTime shiftDate(LocalDateTime originalDateTime) {
<span class="pc bpc" id="L215" title="3 of 6 branches missed.">        assert originalDateTime != null &amp;&amp; shiftedDateTime != null;</span>
<span class="fc" id="L216">        return LocalDateTime.of(shiftedDateTime.toLocalDate(), originalDateTime.toLocalTime());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/SearchCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L17" title="1 of 2 branches missed.">public class SearchCommand extends Command {</span>

    private HashSet&lt;String&gt; keywords;

    private ArrayList&lt;TaskAttributes&gt; results;

<span class="fc" id="L23">    private SearchCommand(Builder builder) {</span>
<span class="fc" id="L24">        this.keywords = builder.keywords;</span>
<span class="fc" id="L25">    }</span>

    public HashSet&lt;String&gt; getKeywords() {
<span class="fc" id="L28">        return keywords;</span>
    }

    public ArrayList&lt;TaskAttributes&gt; getResults() {
<span class="fc" id="L32">        return results;</span>
    }

<span class="fc" id="L35">    public static class Builder {</span>

<span class="fc" id="L37">        HashSet&lt;String&gt; keywords = new HashSet&lt;&gt;();</span>

        public Builder addKeyword(String keyword) {
<span class="fc" id="L40">            this.keywords.add(keyword);</span>
<span class="fc" id="L41">            return this;</span>
        }

        public Builder addKeywords(Collection&lt;String&gt; keywords) {
<span class="fc" id="L45">            this.keywords.addAll(keywords);</span>
<span class="fc" id="L46">            return this;</span>
        }

        public SearchCommand build() {
<span class="fc" id="L50">            return new SearchCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L57">        results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L58">        results.addAll(getFullMatches());</span>
<span class="fc" id="L59">        results.addAll(getPartialMatches());</span>

<span class="fc" id="L61">        eventBus.post(new SearchDoneEvent(results, keywords));</span>
<span class="fc" id="L62">    }</span>

    private ArrayList&lt;TaskAttributes&gt; getFullMatches() {
<span class="fc" id="L65">        return taskDb.getAll().stream().filter(task -&gt; {</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            for (String keyword : keywords) {</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">                if (!task.getDescription().matches(String.format(&quot;(?i:.*\\b%s\\b.*)&quot;, keyword))) {</span>
<span class="fc" id="L68">                    return false;</span>
                }
<span class="fc" id="L70">            }</span>
<span class="fc" id="L71">            return true;</span>
<span class="fc" id="L72">        }).collect(Collectors.toCollection(ArrayList::new));</span>
    }

    private ArrayList&lt;TaskAttributes&gt; getPartialMatches() {
<span class="fc" id="L76">        return taskDb.getAll().stream().filter(task -&gt; {</span>
<span class="fc" id="L77">            int matches = 0;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            for (String keyword : keywords) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                if (task.getDescription().matches(String.format(&quot;(?i:.*\\b%s\\b.*)&quot;, keyword))) {</span>
<span class="fc" id="L80">                    matches++;</span>
                }
<span class="fc" id="L82">            }</span>
<span class="fc bfc" id="L83" title="All 4 branches covered.">            return matches != 0 &amp;&amp; matches != keywords.size();</span>
<span class="fc" id="L84">        }).collect(Collectors.toCollection(ArrayList::new));</span>
    }

    @Override
    public void undo() {
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L90">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/UnaliasCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.UnaliasDoneEvent;
import jfdi.logic.events.UnaliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.InvalidAliasException;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L13" title="1 of 2 branches missed.">public class UnaliasCommand extends Command {</span>

    private String alias;

<span class="fc" id="L17">    private UnaliasCommand(Builder builder) {</span>
<span class="fc" id="L18">        this.alias = builder.alias;</span>
<span class="fc" id="L19">    }</span>

    public String getAlias() {
<span class="fc" id="L22">        return alias;</span>
    }

<span class="fc" id="L25">    public static class Builder {</span>

        String alias;

        public Builder setAlias(String alias) {
<span class="fc" id="L30">            this.alias = alias;</span>
<span class="fc" id="L31">            return this;</span>
        }

        public UnaliasCommand build() {
<span class="fc" id="L35">            return new UnaliasCommand(this);</span>
        }

    }

    @Override
    public void execute() {
        try {
<span class="fc" id="L43">            aliasDb.destroy(alias);</span>
<span class="fc" id="L44">            parser.setAliases(aliasDb.getAll());</span>

<span class="fc" id="L46">            pushToUndoStack();</span>
<span class="fc" id="L47">            eventBus.post(new UnaliasDoneEvent(alias));</span>
<span class="fc" id="L48">        } catch (InvalidAliasException e) {</span>
<span class="fc" id="L49">            eventBus.post(new UnaliasFailedEvent(alias, UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS));</span>
<span class="fc" id="L50">        }</span>
<span class="fc" id="L51">    }</span>

    @Override
    public void undo() {
        try {
<span class="fc" id="L56">            aliasDb.undestroy(alias);</span>
<span class="fc" id="L57">            parser.setAliases(aliasDb.getAll());</span>

<span class="fc" id="L59">            pushToRedoStack();</span>
<span class="fc" id="L60">        } catch (InvalidAliasException e) {</span>
<span class="pc bpc" id="L61" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L62">        }</span>
<span class="fc" id="L63">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/UndoCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.CommandUndoneEvent;
import jfdi.logic.events.UndoFailedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L12" title="1 of 2 branches missed.">public class UndoCommand extends Command {</span>

<span class="fc" id="L14">    private UndoCommand(Builder builder) {}</span>

<span class="fc" id="L16">    public static class Builder {</span>

        public UndoCommand build() {
<span class="fc" id="L19">            return new UndoCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc bfc" id="L26" title="All 2 branches covered.">        if (!undoStack.empty()) {</span>
<span class="fc" id="L27">            Command lastUndoableCommand = undoStack.pop();</span>
<span class="fc" id="L28">            lastUndoableCommand.undo();</span>

<span class="fc" id="L30">            eventBus.post(new CommandUndoneEvent(lastUndoableCommand.getClass()));</span>
<span class="fc" id="L31">        } else {</span>
<span class="fc" id="L32">            eventBus.post(new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO));</span>
        }
<span class="fc" id="L34">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L39">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/UnmarkTaskCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.logic.events.UnmarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">public class UnmarkTaskCommand extends Command {</span>

<span class="fc" id="L23">    private static final Logger LOGGER = JfdiLogger.getLogger();</span>

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;Integer&gt; unmarkedIds;

<span class="fc" id="L28">    private UnmarkTaskCommand(Builder builder) {</span>
<span class="fc" id="L29">        this.screenIds = builder.screenIds;</span>
<span class="fc" id="L30">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L33">        return screenIds;</span>
    }

    public ArrayList&lt;Integer&gt; getUnmarkedIds() {
<span class="fc" id="L37">        return unmarkedIds;</span>
    }

<span class="fc" id="L40">    public static class Builder {</span>

<span class="fc" id="L42">        ArrayList&lt;Integer&gt; screenIds = new ArrayList&lt;&gt;();</span>

        public Builder addTaskId(int id) {
<span class="fc" id="L45">            screenIds.add(id);</span>
<span class="fc" id="L46">            return this;</span>
        }

        public Builder addTaskIds(Collection&lt;Integer&gt; ids) {
<span class="fc" id="L50">            screenIds.addAll(ids);</span>
<span class="fc" id="L51">            return this;</span>
        }

        public UnmarkTaskCommand build() {
<span class="fc" id="L55">            return new UnmarkTaskCommand(this);</span>
        }

    }

    @Override
    public void execute() {
<span class="fc" id="L62">        ArrayList&lt;Integer&gt; taskIds = screenIds.stream().map(ui::getTaskId)</span>
<span class="fc" id="L63">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc" id="L65">        ArrayList&lt;Integer&gt; invalidIds = screenIds.stream()</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            .filter(id -&gt; !taskDb.hasId(ui.getTaskId(id)))</span>
<span class="fc" id="L67">            .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">        if (invalidIds.isEmpty()) {</span>
<span class="fc" id="L70">            ArrayList&lt;TaskAttributes&gt; unmarkedTasks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L71">            unmarkedIds = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L72">            taskIds.stream().forEach(id -&gt; {</span>
                try {
<span class="fc" id="L74">                    unmarkedTasks.add(taskDb.getById(id));</span>
<span class="fc" id="L75">                    taskDb.markAsIncomplete(id);</span>

<span class="fc" id="L77">                    unmarkedIds.add(id);</span>
<span class="fc" id="L78">                } catch (NoAttributesChangedException e) {</span>
<span class="fc" id="L79">                    LOGGER.warning(&quot;Task &quot; + id + &quot; was not completed.&quot;);</span>
<span class="fc" id="L80">                } catch (InvalidIdException e) {</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                    assert false;</span>
<span class="fc" id="L82">                }</span>
<span class="fc" id="L83">            });</span>

<span class="fc" id="L85">            pushToUndoStack();</span>
<span class="fc" id="L86">            eventBus.post(new UnmarkTaskDoneEvent(screenIds, unmarkedTasks));</span>
<span class="fc" id="L87">        } else {</span>
<span class="fc" id="L88">            eventBus.post(new UnmarkTaskFailedEvent(screenIds, invalidIds));</span>
        }
<span class="fc" id="L90">    }</span>

    @Override
    public void undo() {
<span class="fc" id="L94">        unmarkedIds.stream().forEach(id -&gt; {</span>
            try {
<span class="fc" id="L96">                taskDb.markAsComplete(id);</span>

<span class="fc" id="L98">                pushToRedoStack();</span>
<span class="fc" id="L99">            } catch (NoAttributesChangedException | InvalidIdException e) {</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">                assert false;</span>
<span class="fc" id="L101">            }</span>
<span class="fc" id="L102">        });</span>
<span class="fc" id="L103">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/UseDirectoryCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.logic.events.UseDirectoryDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L15" title="1 of 2 branches missed.">public class UseDirectoryCommand extends Command {</span>

    private String oldDirectory;
    private String newDirectory;

<span class="fc" id="L20">    private UseDirectoryCommand(Builder builder) {</span>
<span class="fc" id="L21">        this.newDirectory = builder.newDirectory;</span>
<span class="fc" id="L22">    }</span>

<span class="fc" id="L24">    public static class Builder {</span>

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
<span class="fc" id="L29">            this.newDirectory = newDirectory;</span>
<span class="fc" id="L30">            return this;</span>
        }

        public UseDirectoryCommand build() {
<span class="fc" id="L34">            return new UseDirectoryCommand(this);</span>
        }

    }

    public String getNewDirectory() {
<span class="fc" id="L40">        return newDirectory;</span>
    }

    public String getOldDirectory() {
<span class="fc" id="L44">        return oldDirectory;</span>
    }

    @Override
    public void execute() {
        try {
<span class="fc" id="L50">            oldDirectory = mainStorage.getCurrentDirectory();</span>

<span class="fc" id="L52">            mainStorage.use(newDirectory);</span>
<span class="fc" id="L53">            parser.setAliases(aliasDb.getAll());</span>

<span class="fc" id="L55">            pushToUndoStack();</span>
<span class="fc" id="L56">            eventBus.post(new UseDirectoryDoneEvent(newDirectory));</span>
<span class="fc" id="L57">        } catch (FilesReplacedException e) {</span>
<span class="fc" id="L58">            eventBus.post(new UseDirectoryDoneEvent(newDirectory));</span>
<span class="fc" id="L59">            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));</span>
<span class="fc" id="L60">        } catch (InvalidFilePathException e) {</span>
<span class="fc" id="L61">            eventBus.post(new MoveDirectoryFailedEvent(newDirectory, MoveDirectoryFailedEvent.Error.INVALID_PATH));</span>
<span class="fc" id="L62">        }</span>
<span class="fc" id="L63">    }</span>

    @Override
    public void undo() {
        try {
<span class="fc" id="L68">            mainStorage.use(oldDirectory);</span>
<span class="fc" id="L69">            parser.setAliases(aliasDb.getAll());</span>

<span class="fc" id="L71">            pushToRedoStack();</span>
<span class="fc" id="L72">        } catch (FilesReplacedException e) {</span>
<span class="fc" id="L73">            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));</span>
<span class="fc" id="L74">        } catch (InvalidFilePathException e) {</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">            assert false;</span>
<span class="fc" id="L76">        }</span>
<span class="fc" id="L77">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.commands/WildcardCommand.java.html
``` html

package jfdi.logic.commands;

import jfdi.logic.events.NoSurpriseEvent;
import jfdi.logic.events.SurpriseEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
<span class="pc bpc" id="L17" title="1 of 2 branches missed.">public class WildcardCommand extends Command {</span>

    private TaskAttributes lucky;

<span class="fc" id="L21">    private WildcardCommand(Builder builder) {}</span>

<span class="fc" id="L23">    public static class Builder {</span>

        public WildcardCommand build() {
<span class="fc" id="L26">            return new WildcardCommand(this);</span>
        }

    }

    public TaskAttributes getLucky() {
<span class="fc" id="L32">        return lucky;</span>
    }

    @Override
    public void execute() {
<span class="fc" id="L37">        ArrayList&lt;TaskAttributes&gt; incompleteTasks = taskDb.getAll().stream()</span>
<span class="pc bpc" id="L38" title="1 of 4 branches missed.">                .filter(task -&gt; !task.isCompleted() &amp;&amp; task.getStartDateTime() == null)</span>
<span class="fc" id="L39">                .collect(Collectors.toCollection(ArrayList::new));</span>

<span class="fc" id="L41">        SecureRandom random = new SecureRandom();</span>

<span class="fc bfc" id="L43" title="All 2 branches covered.">        if (!incompleteTasks.isEmpty()) {</span>
<span class="fc" id="L44">            lucky = incompleteTasks.get(random.nextInt(incompleteTasks.size()));</span>
<span class="fc" id="L45">            eventBus.post(new SurpriseEvent(lucky));</span>
        } else {
<span class="fc" id="L47">            eventBus.post(new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS));</span>
        }
<span class="fc" id="L49">    }</span>

    @Override
    public void undo() {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        assert false;</span>
<span class="nc" id="L54">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/AddTaskDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class AddTaskDoneEvent {

    private TaskAttributes task;

<span class="fc" id="L14">    public AddTaskDoneEvent(TaskAttributes task) {</span>
<span class="fc" id="L15">        this.task = task;</span>
<span class="fc" id="L16">    }</span>

    public TaskAttributes getTask() {
<span class="fc" id="L19">        return task;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/AddTaskFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AddTaskFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        EMPTY_DESCRIPTION, DUPLICATED_TASK</span>
    }

    private Error error;

<span class="fc" id="L16">    public AddTaskFailedEvent(Error error) {</span>
<span class="fc" id="L17">        this.error = error;</span>
<span class="fc" id="L18">    }</span>

    public Error getError() {
<span class="fc" id="L21">        return error;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/AliasDoneEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasDoneEvent {

    private String command;
    private String alias;

<span class="fc" id="L13">    public AliasDoneEvent(String command, String alias) {</span>
<span class="fc" id="L14">        this.command = command;</span>
<span class="fc" id="L15">        this.alias = alias;</span>
<span class="fc" id="L16">    }</span>

    public String getCommand() {
<span class="fc" id="L19">        return command;</span>
    }

    public String getAlias() {
<span class="fc" id="L23">        return alias;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/AliasFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        INVALID_PARAMETERS, DUPLICATED_ALIAS, UNKNOWN</span>
    }

    private String command;
    private String alias;
    private Error error;

<span class="fc" id="L18">    public AliasFailedEvent(String command, String alias, Error error) {</span>
<span class="fc" id="L19">        this.command = command;</span>
<span class="fc" id="L20">        this.alias = alias;</span>
<span class="fc" id="L21">        this.error = error;</span>
<span class="fc" id="L22">    }</span>

    public String getCommand() {
<span class="fc" id="L25">        return command;</span>
    }

    public String getAlias() {
<span class="fc" id="L29">        return alias;</span>
    }

    public Error getError() {
<span class="fc" id="L33">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/CommandRedoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandRedoneEvent {

    private Class&lt;? extends Command&gt; commandType;

<span class="fc" id="L14">    public CommandRedoneEvent(Class&lt;? extends Command&gt; commandType) {</span>
<span class="fc" id="L15">        this.commandType = commandType;</span>
<span class="fc" id="L16">    }</span>

    public Class&lt;? extends Command&gt; getCommandType() {
<span class="fc" id="L19">        return commandType;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/CommandUndoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEvent {

    private Class&lt;? extends Command&gt; commandType;

<span class="fc" id="L14">    public CommandUndoneEvent(Class&lt;? extends Command&gt; commandType) {</span>
<span class="fc" id="L15">        this.commandType = commandType;</span>
<span class="fc" id="L16">    }</span>

    public Class&lt;? extends Command&gt; getCommandType() {
<span class="fc" id="L19">        return commandType;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/DeleteTaskDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskDoneEvent {

    private ArrayList&lt;Integer&gt; deletedIds;
    private ArrayList&lt;TaskAttributes&gt; deletedTasks;

<span class="fc" id="L17">    public DeleteTaskDoneEvent(ArrayList&lt;Integer&gt; deletedIds, ArrayList&lt;TaskAttributes&gt; deletedTasks) {</span>
<span class="fc" id="L18">        this.deletedIds = deletedIds;</span>
<span class="fc" id="L19">        this.deletedTasks = deletedTasks;</span>
<span class="fc" id="L20">    }</span>

    public ArrayList&lt;Integer&gt; getDeletedIds() {
<span class="fc" id="L23">        return deletedIds;</span>
    }

    public ArrayList&lt;TaskAttributes&gt; getDeletedTasks() {
<span class="fc" id="L27">        return deletedTasks;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/DeleteTaskFailedEvent.java.html
``` html

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEvent {

<span class="fc" id="L12">    public enum Error {</span>
<span class="fc" id="L13">        NON_EXISTENT_ID</span>
    }

    private ArrayList&lt;Integer&gt; invalidIds;
    private Error error;

<span class="fc" id="L19">    public DeleteTaskFailedEvent(ArrayList&lt;Integer&gt; invalidIds) {</span>
<span class="fc" id="L20">        error = Error.NON_EXISTENT_ID;</span>
<span class="fc" id="L21">        this.invalidIds = invalidIds;</span>
<span class="fc" id="L22">    }</span>

    public ArrayList&lt;Integer&gt; getInvalidIds() {
<span class="fc" id="L25">        return invalidIds;</span>
    }

    public Error getError() {
<span class="fc" id="L29">        return error;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/ExitCalledEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
<span class="fc" id="L8">public class ExitCalledEvent {}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/FilesReplacedEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.exceptions.FilePathPair;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEvent {

<span class="fc" id="L14">    private String newDirectory = null;</span>
    private ArrayList&lt;FilePathPair&gt; filePathPairs;

<span class="fc" id="L17">    public FilesReplacedEvent(ArrayList&lt;FilePathPair&gt; filePathPairs) {</span>
<span class="fc" id="L18">        this.filePathPairs = filePathPairs;</span>
<span class="fc" id="L19">    }</span>

<span class="fc" id="L21">    public FilesReplacedEvent(String newDirectory, ArrayList&lt;FilePathPair&gt; filePathPairs) {</span>
<span class="fc" id="L22">        this.newDirectory = newDirectory;</span>
<span class="fc" id="L23">        this.filePathPairs = filePathPairs;</span>
<span class="fc" id="L24">    }</span>

    public ArrayList&lt;FilePathPair&gt; getFilePathPairs() {
<span class="fc" id="L27">        return filePathPairs;</span>
    }

    public String getNewDirectory() {
<span class="fc" id="L31">        return newDirectory;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/HelpRequestedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
<span class="fc" id="L8">public class HelpRequestedEvent {}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/InitializationFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        INVALID_PATH, UNKNOWN</span>
    }

    private Error error;
    private String path;

<span class="fc" id="L17">    public InitializationFailedEvent(Error error, String path) {</span>
<span class="fc" id="L18">        this.error = error;</span>
<span class="fc" id="L19">        this.path = path;</span>
<span class="fc" id="L20">    }</span>

    public Error getError() {
<span class="fc" id="L23">        return error;</span>
    }

    public String getPath() {
<span class="fc" id="L27">        return path;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/InvalidCommandEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEvent {

    private String inputString;
    private CommandType commandType;

<span class="fc" id="L15">    public InvalidCommandEvent(String inputString, CommandType commandType) {</span>
<span class="fc" id="L16">        this.inputString = inputString;</span>
<span class="fc" id="L17">        this.commandType = commandType;</span>
<span class="fc" id="L18">    }</span>

    public String getInputString() {
<span class="fc" id="L21">        return inputString;</span>
    }

    public CommandType getCommandType() {
<span class="fc" id="L25">        return commandType;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/ListDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.logic.commands.ListCommand.ListType;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class ListDoneEvent {

    private ListType listType;
    private ArrayList&lt;TaskAttributes&gt; items;

<span class="fc" id="L18">    public ListDoneEvent(ListType listType, ArrayList&lt;TaskAttributes&gt; items) {</span>
<span class="fc" id="L19">        this.listType = listType;</span>
<span class="fc" id="L20">        this.items = items;</span>
<span class="fc" id="L21">    }</span>

    public ArrayList&lt;TaskAttributes&gt; getItems() {
<span class="fc" id="L24">        return items;</span>
    }

    public ListType getListType() {
<span class="fc" id="L28">        return listType;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/MarkTaskDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEvent {

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;TaskAttributes&gt; markedTasks;

<span class="fc" id="L17">    public MarkTaskDoneEvent(ArrayList&lt;Integer&gt; screenIds, ArrayList&lt;TaskAttributes&gt; markedTasks) {</span>
<span class="fc" id="L18">        this.screenIds = screenIds;</span>
<span class="fc" id="L19">        this.markedTasks = markedTasks;</span>
<span class="fc" id="L20">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L23">        return screenIds;</span>
    }

    public ArrayList&lt;TaskAttributes&gt; getMarkedTasks() {
<span class="fc" id="L27">        return markedTasks;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/MarkTaskFailedEvent.java.html
``` html

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEvent {

<span class="fc" id="L12">    public enum Error {</span>
<span class="fc" id="L13">        NON_EXISTENT_ID</span>
    }

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;Integer&gt; invalidIds;
    private Error error;

<span class="fc" id="L20">    public MarkTaskFailedEvent(ArrayList&lt;Integer&gt; screenIds, ArrayList&lt;Integer&gt; invalidIds) {</span>
<span class="fc" id="L21">        this.screenIds = screenIds;</span>
<span class="fc" id="L22">        this.invalidIds = invalidIds;</span>
<span class="fc" id="L23">        this.error = Error.NON_EXISTENT_ID;</span>
<span class="fc" id="L24">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L27">        return screenIds;</span>
    }

    public ArrayList&lt;Integer&gt; getInvalidIds() {
<span class="fc" id="L31">        return invalidIds;</span>
    }

    public Error getError() {
<span class="fc" id="L35">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/MoveDirectoryDoneEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEvent {

    private String newDirectory;

<span class="fc" id="L12">    public MoveDirectoryDoneEvent(String newDirectory) {</span>
<span class="fc" id="L13">        this.newDirectory = newDirectory;</span>
<span class="fc" id="L14">    }</span>

    public String getNewDirectory() {
<span class="fc" id="L17">        return newDirectory;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/MoveDirectoryFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        INVALID_PATH, UNKNOWN</span>
    }

    private String newDirectory;
    private Error error;

<span class="fc" id="L17">    public MoveDirectoryFailedEvent(String newDirectory, Error error) {</span>
<span class="fc" id="L18">        this.newDirectory = newDirectory;</span>
<span class="fc" id="L19">        this.error = error;</span>
<span class="fc" id="L20">    }</span>

    public String getNewDirectory() {
<span class="fc" id="L23">        return newDirectory;</span>
    }

    public Error getError() {
<span class="fc" id="L27">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/NoSurpriseEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEvent {

<span class="pc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        NO_TASKS, UNKNOWN</span>
    }

    private Error error;

<span class="fc" id="L16">    public NoSurpriseEvent(Error error) {</span>
<span class="fc" id="L17">        this.error = error;</span>
<span class="fc" id="L18">    }</span>

    public Error getError() {
<span class="fc" id="L21">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/RedoFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class RedoFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        NONTHING_TO_REDO, UNKNOWN</span>
    }

    private Error error;

<span class="fc" id="L16">    public RedoFailedEvent(Error error) {</span>

<span class="fc" id="L18">        this.error = error;</span>
<span class="fc" id="L19">    }</span>

    public Error getError() {
<span class="fc" id="L22">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/RenameTaskDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEvent {

    private TaskAttributes task;

<span class="fc" id="L14">    public RenameTaskDoneEvent(TaskAttributes task) {</span>
<span class="fc" id="L15">        this.task = task;</span>
<span class="fc" id="L16">    }</span>

    public TaskAttributes getTask() {
<span class="fc" id="L19">        return task;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/RenameTaskFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        NON_EXISTENT_ID,</span>
<span class="fc" id="L12">        DUPLICATED_TASK,</span>
<span class="fc" id="L13">        NO_CHANGES,</span>
<span class="fc" id="L14">        UNKNOWN</span>
    }

    private int screenId;
    private String description;
    private Error error;

<span class="fc" id="L21">    public RenameTaskFailedEvent(int screenId, String description, Error error) {</span>
<span class="fc" id="L22">        this.screenId = screenId;</span>
<span class="fc" id="L23">        this.description = description;</span>
<span class="fc" id="L24">        this.error = error;</span>
<span class="fc" id="L25">    }</span>

    public int getScreenId() {
<span class="fc" id="L28">        return screenId;</span>
    }

    public String getDescription() {
<span class="fc" id="L32">        return description;</span>
    }

    public Error getError() {
<span class="fc" id="L36">        return error;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/RescheduleTaskDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEvent {

    private TaskAttributes task;

<span class="fc" id="L14">    public RescheduleTaskDoneEvent(TaskAttributes task) {</span>
<span class="fc" id="L15">        this.task = task;</span>
<span class="fc" id="L16">    }</span>

    public TaskAttributes getTask() {
<span class="fc" id="L19">        return task;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/RescheduleTaskFailedEvent.java.html
``` html

package jfdi.logic.events;

import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEvent {

<span class="fc" id="L12">    public enum Error {</span>
<span class="fc" id="L13">        NON_EXISTENT_ID,</span>
<span class="fc" id="L14">        DUPLICATED_TASK,</span>
<span class="fc" id="L15">        NO_CHANGES,</span>
<span class="fc" id="L16">        UNKNOWN</span>
    }

    private int screenId;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private Error error;

    public RescheduleTaskFailedEvent(int screenId, LocalDateTime startDateTime, LocalDateTime endDateTime,
<span class="fc" id="L25">                                     Error error) {</span>
<span class="fc" id="L26">        this.screenId = screenId;</span>
<span class="fc" id="L27">        this.startDateTime = startDateTime;</span>
<span class="fc" id="L28">        this.endDateTime = endDateTime;</span>
<span class="fc" id="L29">        this.error = error;</span>
<span class="fc" id="L30">    }</span>

    public int getScreenId() {
<span class="fc" id="L33">        return screenId;</span>
    }

    public LocalDateTime getStartDateTime() {
<span class="fc" id="L37">        return startDateTime;</span>
    }

    public LocalDateTime getEndDateTime() {
<span class="fc" id="L41">        return endDateTime;</span>
    }

    public Error getError() {
<span class="fc" id="L45">        return error;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/SearchDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.HashSet;

/**
 * @author Liu Xinan
 */
public class SearchDoneEvent {

    private ArrayList&lt;TaskAttributes&gt; results;
    private HashSet&lt;String&gt; keywords;

<span class="fc" id="L18">    public SearchDoneEvent(ArrayList&lt;TaskAttributes&gt; results, HashSet&lt;String&gt; keywords) {</span>
<span class="fc" id="L19">        this.results = results;</span>
<span class="fc" id="L20">        this.keywords = keywords;</span>
<span class="fc" id="L21">    }</span>

    public ArrayList&lt;TaskAttributes&gt; getResults() {
<span class="fc" id="L24">        return results;</span>
    }

    public HashSet&lt;String&gt; getKeywords() {
<span class="fc" id="L28">        return keywords;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/ShowDirectoryEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEvent {

    private String pwd;

<span class="fc" id="L12">    public ShowDirectoryEvent(String pwd) {</span>
<span class="fc" id="L13">        this.pwd = pwd;</span>
<span class="fc" id="L14">    }</span>

    public String getPwd() {
<span class="fc" id="L17">        return pwd;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/SurpriseEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class SurpriseEvent {

    private TaskAttributes task;

<span class="fc" id="L14">    public SurpriseEvent(TaskAttributes task) {</span>
<span class="fc" id="L15">        this.task = task;</span>
<span class="fc" id="L16">    }</span>

    public TaskAttributes getTask() {
<span class="fc" id="L19">        return task;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UnaliasDoneEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEvent {

    private String alias;

<span class="fc" id="L12">    public UnaliasDoneEvent(String alias) {</span>
<span class="fc" id="L13">        this.alias = alias;</span>
<span class="fc" id="L14">    }</span>

    public String getAlias() {
<span class="fc" id="L17">        return alias;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UnaliasFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        NON_EXISTENT_ALIAS,</span>
<span class="fc" id="L12">        UNKNOWN</span>
    }

    private String alias;
    private Error error;

<span class="fc" id="L18">    public UnaliasFailedEvent(String alias, Error error) {</span>
<span class="fc" id="L19">        this.alias = alias;</span>
<span class="fc" id="L20">        this.error = error;</span>
<span class="fc" id="L21">    }</span>

    public String getAlias() {
<span class="fc" id="L24">        return alias;</span>
    }

    public Error getError() {
<span class="fc" id="L28">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UndoFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UndoFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        NONTHING_TO_UNDO, UNKNOWN</span>
    }

    private Error error;

<span class="fc" id="L16">    public UndoFailedEvent(Error error) {</span>
<span class="fc" id="L17">        this.error = error;</span>
<span class="fc" id="L18">    }</span>

    public Error getError() {
<span class="fc" id="L21">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UnmarkTaskDoneEvent.java.html
``` html

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEvent {

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;TaskAttributes&gt; unmarkedTasks;

<span class="fc" id="L17">    public UnmarkTaskDoneEvent(ArrayList&lt;Integer&gt; screenIds, ArrayList&lt;TaskAttributes&gt; unmarkedTasks) {</span>
<span class="fc" id="L18">        this.screenIds = screenIds;</span>
<span class="fc" id="L19">        this.unmarkedTasks = unmarkedTasks;</span>
<span class="fc" id="L20">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L23">        return screenIds;</span>
    }

    public ArrayList&lt;TaskAttributes&gt; getUnmarkedTasks() {
<span class="fc" id="L27">        return unmarkedTasks;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UnmarkTaskFailedEvent.java.html
``` html

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEvent {

<span class="fc" id="L12">    public enum Error {</span>
<span class="fc" id="L13">        NON_EXISTENT_ID</span>
    }

    private ArrayList&lt;Integer&gt; screenIds;
    private ArrayList&lt;Integer&gt; invalidIds;
    private Error error;

<span class="fc" id="L20">    public UnmarkTaskFailedEvent(ArrayList&lt;Integer&gt; screenIds, ArrayList&lt;Integer&gt; invalidIds) {</span>
<span class="fc" id="L21">        this.screenIds = screenIds;</span>
<span class="fc" id="L22">        this.invalidIds = invalidIds;</span>
<span class="fc" id="L23">        this.error = Error.NON_EXISTENT_ID;</span>
<span class="fc" id="L24">    }</span>

    public ArrayList&lt;Integer&gt; getScreenIds() {
<span class="fc" id="L27">        return screenIds;</span>
    }

    public ArrayList&lt;Integer&gt; getInvalidIds() {
<span class="fc" id="L31">        return invalidIds;</span>
    }

    public Error getError() {
<span class="fc" id="L35">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UseDirectoryDoneEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEvent {

    private String newDirectory;

<span class="fc" id="L12">    public UseDirectoryDoneEvent(String newDirectory) {</span>
<span class="fc" id="L13">        this.newDirectory = newDirectory;</span>
<span class="fc" id="L14">    }</span>

    public String getNewDirectory() {
<span class="fc" id="L17">        return newDirectory;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.events/UseDirectoryFailedEvent.java.html
``` html

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEvent {

<span class="fc" id="L10">    public enum Error {</span>
<span class="fc" id="L11">        INVALID_PATH, UNKNOWN</span>
    }

    private String newDirectory;
    private Error error;

<span class="fc" id="L17">    public UseDirectoryFailedEvent(String newDirectory, Error error) {</span>
<span class="fc" id="L18">        this.newDirectory = newDirectory;</span>
<span class="fc" id="L19">        this.error = error;</span>
<span class="fc" id="L20">    }</span>

    public String getNewDirectory() {
<span class="fc" id="L23">        return newDirectory;</span>
    }

    public Error getError() {
<span class="fc" id="L27">        return error;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.logic.interfaces/Command.java.html
``` html

package jfdi.logic.interfaces;

import com.google.common.eventbus.EventBus;
import jfdi.common.utilities.JfdiLogger;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;

import java.util.Optional;
import java.util.Stack;
import java.util.logging.Logger;

/**
 * @author Liu Xinan
 */
<span class="fc" id="L20">public abstract class Command {</span>

<span class="fc" id="L22">    protected static final Logger logger = JfdiLogger.getLogger();</span>
<span class="fc" id="L23">    protected static EventBus eventBus = UI.getEventBus();</span>

<span class="fc" id="L25">    protected static final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L26">    protected static final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();</span>

<span class="fc" id="L28">    protected static UI ui = UI.getInstance();</span>
<span class="fc" id="L29">    protected static InputParser parser = InputParser.getInstance();</span>
<span class="fc" id="L30">    protected static MainStorage mainStorage = MainStorage.getInstance();</span>
<span class="fc" id="L31">    protected static TaskDb taskDb = TaskDb.getInstance();</span>
<span class="fc" id="L32">    protected static AliasDb aliasDb = AliasDb.getInstance();</span>

<span class="fc" id="L34">    private static boolean redoing = false;</span>
<span class="fc" id="L35">    private static Optional&lt;String&gt; lastSuggestion = Optional.empty();</span>

    /**
     * Executes the command.
     */
    public abstract void execute();

    /**
     * Undoes the command.
     */
    public abstract void undo();

    public static void setRedoing(boolean redo) {
<span class="fc" id="L48">        redoing = redo;</span>
<span class="fc" id="L49">    }</span>

    public void pushToUndoStack() {
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">        if (!redoing) {</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">            while (!redoStack.empty()) {</span>
<span class="fc" id="L54">                undoStack.push(redoStack.pop());</span>
            }
        }

<span class="fc" id="L58">        undoStack.push(this);</span>
<span class="fc" id="L59">    }</span>

    public void pushToRedoStack() {
<span class="fc" id="L62">        redoStack.push(this);</span>
<span class="fc" id="L63">    }</span>

    //================================================================
    // List of setters and getters for testing.
    //================================================================


    public static void setUi(UI ui) {
<span class="fc" id="L71">        Command.ui = ui;</span>
<span class="fc" id="L72">    }</span>

    public static void setParser(InputParser parser) {
<span class="fc" id="L75">        Command.parser = parser;</span>
<span class="fc" id="L76">    }</span>

    public static void setMainStorage(MainStorage mainStorage) {
<span class="fc" id="L79">        Command.mainStorage = mainStorage;</span>
<span class="fc" id="L80">    }</span>

    public static void setTaskDb(TaskDb taskDb) {
<span class="fc" id="L83">        Command.taskDb = taskDb;</span>
<span class="fc" id="L84">    }</span>

    public static void setAliasDb(AliasDb aliasDb) {
<span class="fc" id="L87">        Command.aliasDb = aliasDb;</span>
<span class="fc" id="L88">    }</span>

    public static void setEventBus(EventBus eventBus) {
<span class="fc" id="L91">        Command.eventBus = eventBus;</span>
<span class="fc" id="L92">    }</span>

    public static Stack&lt;Command&gt; getUndoStack() {
<span class="fc" id="L95">        return undoStack;</span>
    }

    public static Stack&lt;Command&gt; getRedoStack() {
<span class="fc" id="L99">        return redoStack;</span>
    }

    public static UI getUI() {
<span class="fc" id="L103">        return ui;</span>
    }

    public static InputParser getParser() {
<span class="fc" id="L107">        return parser;</span>
    }

    public static MainStorage getMainStorage() {
<span class="fc" id="L111">        return mainStorage;</span>
    }

    public static TaskDb getTaskDb() {
<span class="fc" id="L115">        return taskDb;</span>
    }

    public static AliasDb getAliasDb() {
<span class="fc" id="L119">        return aliasDb;</span>
    }

    public static EventBus getEventBus() {
<span class="fc" id="L123">        return eventBus;</span>
    }

    public static boolean isRedoing() {
<span class="fc" id="L127">        return redoing;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./build/reports/jacoco/test/html/jfdi.ui/AutoCompleteTextField.java.html
``` html

package jfdi.ui;

import javafx.geometry.Side;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

import java.util.LinkedList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class AutoCompleteTextField extends TextField {

    private SortedSet&lt;String&gt; keywords;
    private LinkedList&lt;String&gt; results;

    private ContextMenu popup;

    public AutoCompleteTextField() {
<span class="fc" id="L30">        super();</span>
<span class="fc" id="L31">        keywords = new TreeSet&lt;&gt;(String::compareToIgnoreCase);</span>
<span class="fc" id="L32">        results = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L33">        popup = new ContextMenu();</span>

<span class="fc" id="L35">        textProperty().addListener((observable, oldValue, newValue) -&gt; {</span>
<span class="fc bfc" id="L36" title="All 2 branches covered.">            if (getText().isEmpty()) {</span>
<span class="fc" id="L37">                popup.hide();</span>
<span class="fc" id="L38">                return;</span>
            }
<span class="fc" id="L40">            results.clear();</span>
<span class="fc" id="L41">            results.addAll(keywords.subSet(getText(), getText() + Character.MAX_VALUE));</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">            if (results.isEmpty()) {</span>
<span class="fc" id="L43">                popup.hide();</span>
            } else {
<span class="fc" id="L45">                populatePopup(results);</span>
            }
<span class="fc" id="L47">        });</span>

<span class="fc" id="L49">        focusedProperty().addListener((observable, oldValue, newValue) -&gt; popup.hide());</span>

<span class="fc" id="L51">        popup.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -&gt; {</span>
            @SuppressWarnings(&quot;deprecation&quot;)
<span class="fc" id="L53">            boolean isAnyItemSelected = popup.getItems().stream().map(item -&gt; item.impl_styleableGetNode())</span>
<span class="fc" id="L54">                    .anyMatch(node -&gt; node.isFocused());</span>
<span class="pc bpc" id="L55" title="1 of 4 branches missed.">            if (event.getCode() == KeyCode.ENTER &amp;&amp; !isAnyItemSelected) {</span>
<span class="fc" id="L56">                UI.getInstance().triggerEnter();</span>
<span class="fc" id="L57">                results.clear();</span>
            }
<span class="fc" id="L59">        });</span>
<span class="fc" id="L60">    }</span>

    public void setKeywords(SortedSet&lt;String&gt; keywords) {
<span class="fc" id="L63">        this.keywords.clear();</span>
<span class="fc" id="L64">        this.keywords.addAll(keywords);</span>
<span class="fc" id="L65">    }</span>

    public void hidePopup() {
<span class="fc" id="L68">        popup.hide();</span>
<span class="fc" id="L69">    }</span>

    public void selectFirst() {
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if (!results.isEmpty()) {</span>
<span class="nc" id="L73">            select(results.get(0));</span>
<span class="nc" id="L74">            popup.hide();</span>
        }
<span class="nc" id="L76">    }</span>

    private void select(String suggestion) {
<span class="nc" id="L79">        setText(suggestion + &quot; &quot;);</span>
<span class="nc" id="L80">        this.positionCaret(this.getText().length());</span>
<span class="nc" id="L81">    }</span>

    private void populatePopup(LinkedList&lt;String&gt; results) {
<span class="fc" id="L84">        List&lt;CustomMenuItem&gt; menuItems = results.stream()</span>
<span class="fc" id="L85">            .map(Label::new)</span>
<span class="fc" id="L86">            .map(label -&gt; {</span>
<span class="fc" id="L87">                CustomMenuItem menuItem = new CustomMenuItem(label, true);</span>
<span class="fc" id="L88">                menuItem.setOnAction(action -&gt; {</span>
<span class="nc" id="L89">                    select(label.getText());</span>
<span class="nc" id="L90">                    popup.hide();</span>
<span class="nc" id="L91">                });</span>
<span class="fc" id="L92">                return menuItem;</span>
            })
<span class="fc" id="L94">            .collect(Collectors.toCollection(LinkedList::new));</span>

<span class="fc" id="L96">        popup.getItems().setAll(menuItems);</span>

<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (!popup.isShowing()) {</span>
<span class="fc" id="L99">            popup.show(this, Side.BOTTOM, 0, 0);</span>
        }
<span class="fc" id="L101">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
```
###### ./config/checkstyle/checkstyle.xml
``` xml
<!DOCTYPE module PUBLIC
  "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
  "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">

<module name="Checker">
  <property name="localeCountry" value="SG" />
  <property name="localeLanguage" value="en" />
  <property name="charset" value="UTF-8" />

  <module name="FileTabCharacter">
    <property name="eachLine" value="true" />
  </module>
  <module name="NewlineAtEndOfFile" />
  <module name="RegexpSingleline">
    <property name="format" value="\s+$"/>
    <property name="message" value="Trailing whitespace"/>
  </module>
  <module name="RegexpSingleline">
    <property name="format" value="/\*\* +\p{javaLowerCase}"/>
    <property name="fileExtensions" value="java"/>
    <property name="message" value="First sentence in a comment should start with a capital letter"/>
  </module>
  <module name="RegexpMultiline">
    <property name="format" value="/\*\*\W+\* +\p{javaLowerCase}"/>
    <property name="fileExtensions" value="java"/>
    <property name="message" value="First sentence in a comment should start with a capital letter"/>
  </module>

  <module name="TreeWalker">
    <module name="OuterTypeFilename" />
    <module name="IllegalTokenText">
      <property name="tokens" value="STRING_LITERAL, CHAR_LITERAL" />
      <property name="format" value="\\u00(08|09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)" />
      <property name="message" value="Avoid using corresponding octal or unicode escape for characters that have special escape sequences." />
    </module>
    <module name="AvoidEscapedUnicodeCharacters">
      <property name="allowEscapesForControlCharacters" value="true" />
      <property name="allowByTailComment" value="true" />
      <property name="allowNonPrintableEscapes" value="true" />
    </module>
    <module name="EmptyLineSeparator">
      <property name="allowNoEmptyLineBetweenFields" value="true" />
    </module>
    <module name="LineLength">
      <property name="max" value="120" />
      <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://" />
    </module>
    <module name="NoLineWrap" />
    <module name="OneTopLevelClass" />
    <module name="DeclarationOrder" />
    <module name="OverloadMethodsDeclarationOrder" />
    <module name="AvoidNestedBlocks" />
    <module name="NeedBraces" />
    <module name="LeftCurly" />
    <module name="RightCurly" />
    <module name="DefaultComesLast" />
    <module name="EmptyStatement" />
    <module name="EqualsHashCode" />
    <module name="EmptyBlock">
      <property name="option" value="TEXT" />
      <property name="tokens" value="LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH" />
    </module>
    <module name="EmptyCatchBlock">
      <property name="commentFormat" value="Excepted" />
    </module>
    <module name="Indentation" />
    <module name="OneStatementPerLine" />
    <module name="OperatorWrap">
      <property name="tokens" value="BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR" />
    </module>
    <module name="SeparatorWrap">
      <property name="tokens" value="DOT" />
      <property name="option" value="nl" />
    </module>
    <module name="SeparatorWrap">
      <property name="tokens" value="COMMA" />
      <property name="option" value="eol" />
    </module>
    <module name="NoWhitespaceAfter" />
    <module name="NoWhitespaceBefore" />
    <module name="ParenPad" />
    <module name="WhitespaceAfter" />
    <module name="WhitespaceAround">
      <property name="allowEmptyConstructors" value="true" />
      <property name="allowEmptyMethods" value="true" />
      <property name="allowEmptyTypes" value="true" />
      <property name="allowEmptyLoops" value="true" />
      <message key="ws.notFollowed"
               value="WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement." />
      <message key="ws.notPreceded"
               value="WhitespaceAround: ''{0}'' is not preceded with whitespace." />
    </module>
    <module name="GenericWhitespace">
      <message key="ws.followed"
               value="GenericWhitespace ''{0}'' is followed by whitespace." />
      <message key="ws.preceded"
               value="GenericWhitespace ''{0}'' is preceded with whitespace." />
      <message key="ws.illegalFollow"
               value="GenericWhitespace ''{0}'' should followed by whitespace." />
      <message key="ws.notPreceded"
               value="GenericWhitespace ''{0}'' is not preceded with whitespace." />
    </module>
    <module name="MethodParamPad" />
    <module name="MultipleVariableDeclarations" />
    <module name="ArrayTypeStyle" />
    <module name="FallThrough" />
    <module name="MissingSwitchDefault" />
    <module name="NoClone" />
    <module name="SimplifyBooleanExpression" />
    <module name="SimplifyBooleanReturn" />
    <module name="StringLiteralEquality" />
    <module name="UnnecessaryParentheses" />
    <module name="RedundantImport" />
    <module name="UnusedImports" />
    <module name="TodoComment">
      <property name="format" value="(TODO)|(FIXME)" />
      <property name="severity" value="warning" />
    </module>
    <module name="RedundantModifier" />
    <module name="AnnotationLocation">
      <property name="tokens" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF" />
    </module>
    <module name="AnnotationLocation">
      <property name="tokens" value="VARIABLE_DEF" />
      <property name="allowSamelineMultipleAnnotations" value="true" />
    </module>
    <module name="ModifierOrder" />
    <module name="UpperEll" />
    <module name="PackageName">
      <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$" />
      <message key="name.invalidPattern"
               value="Package name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="TypeName">
      <message key="name.invalidPattern"
               value="Type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="MemberName">
      <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$" />
      <message key="name.invalidPattern"
               value="Member name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="LocalVariableName">
      <property name="tokens" value="VARIABLE_DEF" />
      <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$" />
      <property name="allowOneCharVarInForLoop" value="true" />
      <message key="name.invalidPattern"
               value="Local variable name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="ClassTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Class type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="MethodTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Method type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="InterfaceTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Interface type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="AbbreviationAsWordInName">
      <property name="ignoreFinal" value="false" />
      <property name="allowedAbbreviationLength" value="3" />
    </module>
    <module name="ConstantName">
      <property name="applyToProtected" value="false" />
      <property name="applyToPrivate" value="false" />
      <property name="applyToPackage" value="false" />
    </module>
    <module name="NoFinalizer" />
    <module name="SingleLineJavadoc" />
    <module name="JavadocParagraph" />
    <module name="AtclauseOrder">
      <property name="tagOrder" value="@param, @return, @throws, @deprecated" />
      <property name="target" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF" />
    </module>
    <module name="JavadocTagContinuationIndentation" />
    <module name="NonEmptyAtclauseDescription" />
  </module>
</module>
```
###### ./src/main/java/jfdi/logic/commands/AddTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.logic.events.AddTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.LocalDateTime;
import java.util.Optional;

/**
 * @author Liu Xinan
 */
public class AddTaskCommand extends Command {

    private String description;
    private Optional<LocalDateTime> startDateTime;
    private Optional<LocalDateTime> endDateTime;
    private int id = -1;

    private AddTaskCommand(Builder builder) {
        this.description = builder.description;
        this.startDateTime = Optional.ofNullable(builder.startDateTime);
        this.endDateTime = Optional.ofNullable(builder.endDateTime);
    }

    public String getDescription() {
        return description;
    }

    public Optional<LocalDateTime> getStartDateTime() {
        return startDateTime;
    }

    public Optional<LocalDateTime> getEndDateTime() {
        return endDateTime;
    }

    public int getId() {
        return id;
    }

    public static class Builder {

        String description;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
            this.startDateTime = startDateTime;
            return this;
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
            this.endDateTime = endDateTime;
            return this;
        }

        public AddTaskCommand build() {
            return new AddTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        TaskAttributes task = new TaskAttributes();
        task.setDescription(description);
        startDateTime.ifPresent(task::setStartDateTime);
        endDateTime.ifPresent(task::setEndDateTime);
        try {
            task.save();
            this.id = task.getId();

            pushToUndoStack();
            eventBus.post(new AddTaskDoneEvent(task));
            logger.info("Task added: #" + this.id + task.getDescription());
        } catch (InvalidTaskParametersException e) {
            eventBus.post(new AddTaskFailedEvent(
                AddTaskFailedEvent.Error.EMPTY_DESCRIPTION));
            logger.warning("Adding task failed: Description empty");
        } catch (DuplicateTaskException e) {
            eventBus.post(new AddTaskFailedEvent(
                AddTaskFailedEvent.Error.DUPLICATED_TASK));
            logger.warning("Adding task failed: Duplicate task");
        } catch (NoAttributesChangedException | InvalidIdException e) {
            // Should not happen for creating tasks
            assert false;
        }
    }

    @Override
    public void undo() {
        try {
            taskDb.destroy(id);

            logger.info("Undo add task: Deleting task #" + id);
        } catch (InvalidIdException e) {
            // Should not happen for creating tasks
            assert false;
        }
    }

}
```
###### ./src/main/java/jfdi/logic/commands/AliasCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.AliasDoneEvent;
import jfdi.logic.events.AliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

/**
 * @author Liu Xinan
 */
public class AliasCommand extends Command {

    private String command;
    private String alias;
    private boolean isValid;

    private AliasCommand(Builder builder) {
        this.command = builder.command;
        this.alias = builder.alias;
        this.isValid = builder.isValid;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

    public boolean isValid() {
        return isValid;
    }

    public static class Builder {

        String command;
        String alias;
        boolean isValid;

        public Builder setCommand(String command) {
            this.command = command;
            return this;
        }

        public Builder setAlias(String alias) {
            this.alias = alias;
            return this;
        }

        public Builder setIsValid(boolean isValid) {
            this.isValid = isValid;
            return this;
        }

        public AliasCommand build() {
            return new AliasCommand(this);
        }

    }

    @Override
    public void execute() {
        AliasAttributes newAlias = new AliasAttributes(alias, command);
        try {
            newAlias.save();
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new AliasDoneEvent(command, alias));
            logger.info("Aliased " + command + " to " + alias);
        } catch (InvalidAliasParametersException e) {
            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.INVALID_PARAMETERS));
            logger.warning("Alias not saved: Invalid alias");
        } catch (DuplicateAliasException e) {
            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.DUPLICATED_ALIAS));
            logger.warning("Alias not saved: Duplicate alias");
        }
    }

    @Override
    public void undo() {
        try {
            aliasDb.destroy(alias);
            parser.setAliases(aliasDb.getAll());

            logger.info("Undo add alias: Deleting alias:" + alias);
        } catch (InvalidAliasException e) {
            // Should not happen
            assert false;
        }
    }

}
```
###### ./src/main/java/jfdi/logic/commands/DeleteTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.logic.events.DeleteTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class DeleteTaskCommand extends Command {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> deletedTasks;

    private DeleteTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getDeletedTasks() {
        return deletedTasks;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public DeleteTaskCommand build() {
            return new DeleteTaskCommand(this);
        }

    }



    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            deletedTasks = new ArrayList<>();
            taskIds.forEach(id -> {
                try {
                    deletedTasks.add(taskDb.getById(id));
                    taskDb.destroy(id);
                    logger.info("Task deleted: #" + id);
                } catch (InvalidIdException e) {
                    // Should not happen
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new DeleteTaskDoneEvent(screenIds, deletedTasks));
        } else {
            eventBus.post(new DeleteTaskFailedEvent(invalidIds));
        }
    }

    @Override
    public void undo() {
        deletedTasks.stream().forEach(task -> {
            try {
                taskDb.undestroy(task.getId());

                logger.info("Undo deleting task: #" + task.getId());
            } catch (InvalidIdException | DuplicateTaskException e) {
                assert false;
            }
        });
    }
}
```
###### ./src/main/java/jfdi/logic/commands/DirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ShowDirectoryEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class DirectoryCommand extends Command {

    private DirectoryCommand(Builder builder) {}

    public static class Builder {

        public DirectoryCommand build() {
            return new DirectoryCommand(this);
        }

    }

    @Override
    public void execute() {
        String pwd = mainStorage.getCurrentDirectory();
        eventBus.post(new ShowDirectoryEvent(pwd));
        logger.info("Showing current directory: " + pwd);
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/ExitCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ExitCalledEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class ExitCommand extends Command {

    private ExitCommand(Builder builder) {}

    public static class Builder {

        public ExitCommand build() {
            return new ExitCommand(this);
        }

    }

    @Override
    public void execute() {
        // Nothing needs to be done.
        // Post an event to notify UI to exit.
        eventBus.post(new ExitCalledEvent());

        logger.info("Exiting the program...");
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/HelpCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.HelpRequestedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class HelpCommand extends Command {

    private HelpCommand(Builder builder) {}

    public static class Builder {

        public HelpCommand build() {
            return new HelpCommand(this);
        }

    }

    @Override
    public void execute() {
        eventBus.post(new HelpRequestedEvent());

        logger.info("User requested for help");
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/InvalidCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
public class InvalidCommand extends Command {

    private String inputString;
    private CommandType commandType;

    private InvalidCommand(Builder builder) {
        this.inputString = builder.inputString;
        this.commandType = builder.commandType;
    }

    public static class Builder {

        String inputString = "";
        CommandType commandType = null;

        public Builder setInputString(String inputString) {
            this.inputString = inputString;
            return this;
        }

        public Builder setCommandType(CommandType commandType) {
            this.commandType = commandType;
            return this;
        }

        public InvalidCommand build() {
            return new InvalidCommand(this);
        }

    }

    public String getInputString() {
        return inputString;
    }

    public CommandType getCommandType() {
        return commandType;
    }

    @Override
    public void execute() {
        // Invalid command always fail.
        eventBus.post(new InvalidCommandEvent(inputString, commandType));

        logger.warning("Invalid command received: " + inputString);
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/ListCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ListDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ListCommand extends Command {

    public enum ListType {
        ALL,
        COMPLETED,
        INCOMPLETE,
        OVERDUE,
        UPCOMING
    }

    private ListType listType;

    private ListCommand(Builder builder) {
        this.listType = builder.listType;
    }

    public static class Builder {

        ListType listType;

        public Builder setListType(ListType listType) {
            this.listType = listType;
            return this;
        }

        public ListCommand build() {
            return new ListCommand(this);
        }
    }

    public ListType getListType() {
        return this.listType;
    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> tasks = taskDb.getAll().stream()
            .collect(Collectors.toCollection(ArrayList::new));

        switch (listType) {
            case COMPLETED:
                tasks = tasks.stream()
                    .filter(TaskAttributes::isCompleted)
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of completed tasks requested.");
                break;
            case INCOMPLETE:
                tasks = tasks.stream()
                    .filter(task -> !task.isCompleted())
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of incomplete tasks requested.");
                break;
            case OVERDUE:
                tasks = taskDb.getOverdue().stream()
                    .sorted()
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of overdue tasks requested.");
                break;
            case UPCOMING:
                tasks = taskDb.getUpcoming().stream()
                    .sorted()
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of upcoming tasks requested.");
                break;
            default:
                break;
        }

        eventBus.post(new ListDoneEvent(listType, tasks));
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/MarkTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.logic.events.MarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class MarkTaskCommand extends Command {

    private static final Logger logger = JfdiLogger.getLogger();

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> markedIds;

    private MarkTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getMarkedIds() {
        return markedIds;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addTaskId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addTaskIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public MarkTaskCommand build() {
            return new MarkTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            ArrayList<TaskAttributes> markedTasks = new ArrayList<>();
            markedIds = new ArrayList<>();
            taskIds.stream().forEach(id -> {
                try {
                    markedTasks.add(taskDb.getById(id));
                    taskDb.markAsComplete(id);
                    markedIds.add(id);

                    logger.info("Task marked: #" + id);
                } catch (NoAttributesChangedException e) {
                    logger.warning("Task " + id + " is already completed.");
                } catch (InvalidIdException e) {
                    // Should not happen!
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new MarkTaskDoneEvent(screenIds, markedTasks));
        } else {
            eventBus.post(new MarkTaskFailedEvent(screenIds, invalidIds));

            logger.warning("Some invalid id(s) supplied. Not marking any tasks as done.");
        }
    }

    @Override
    public void undo() {
        markedIds.stream().forEach(id -> {
            try {
                taskDb.markAsIncomplete(id);

                logger.info("Undo marking task: #" + id);
            } catch (NoAttributesChangedException | InvalidIdException e) {
                assert false;
            }
        });
    }
}
```
###### ./src/main/java/jfdi/logic/commands/MoveDirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.MoveDirectoryDoneEvent;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryCommand extends Command {

    private String oldDirectory;
    private String newDirectory;

    private MoveDirectoryCommand(Builder builder) {
        this.newDirectory = builder.newDirectory;
    }

    public static class Builder {

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
            this.newDirectory = newDirectory;
            return this;
        }

        public MoveDirectoryCommand build() {
            return new MoveDirectoryCommand(this);
        }

    }

    public String getOldDirectory() {
        return oldDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    @Override
    public void execute() {
        try {
            oldDirectory = mainStorage.getCurrentDirectory();

            mainStorage.changeDirectory(newDirectory);

            pushToUndoStack();
            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));

            logger.info("Program data moved to " + newDirectory);
        } catch (FilesReplacedException e) {
            pushToUndoStack();
            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));
            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));

            logger.warning("Destination files replaced.");
        } catch (InvalidFilePathException e) {
            eventBus.post(new MoveDirectoryFailedEvent(newDirectory, MoveDirectoryFailedEvent.Error.INVALID_PATH));

            logger.warning("Invalid file path specified.");
        }
    }

    @Override
    public void undo() {
        try {
            mainStorage.changeDirectory(oldDirectory);

            logger.info("Undo moving directory: Moving back to " + oldDirectory);
        } catch (InvalidFilePathException e) {
            assert false;
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));
        }
    }
}
```
###### ./src/main/java/jfdi/logic/commands/RenameTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.logic.events.RenameTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

/**
 * @author Liu Xinan
 */
public class RenameTaskCommand extends Command {

    private int screenId;
    private String description;
    private String oldDescription;

    private RenameTaskCommand(Builder builder) {
        this.screenId = builder.screenId;
        this.description = builder.description;
    }

    public int getScreenId() {
        return screenId;
    }

    public String getDescription() {
        return description;
    }

    public String getOldDescription() {
        return oldDescription;
    }

    public static class Builder {

        int screenId = -1;
        String description;

        public Builder setId(int screenId) {
            this.screenId = screenId;
            return this;
        }

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public RenameTaskCommand build() {
            return new RenameTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);
            oldDescription = task.getDescription();

            task.setDescription(description);
            task.save();

            pushToUndoStack();
            eventBus.post(new RenameTaskDoneEvent(task));

            logger.info("Task #" + taskId + " renamed to " + description);
        } catch (InvalidIdException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description,
                          RenameTaskFailedEvent.Error.NON_EXISTENT_ID));

            logger.warning("Rename task failed: Invalid task id");
        } catch (NoAttributesChangedException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description,
                          RenameTaskFailedEvent.Error.NO_CHANGES));

            logger.warning("Rename task failed: Task description not changed");
        } catch (DuplicateTaskException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description,
                          RenameTaskFailedEvent.Error.DUPLICATED_TASK));

            logger.warning("Rename task failed: Duplicate task");
        } catch (InvalidTaskParametersException e) {
            // Should not happen
            assert false;
        }
    }

    @Override
    public void undo() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            task.setDescription(oldDescription);
            task.save();

            logger.info("Undo renaming: renaming task #" + taskId + " back to " + oldDescription);
        } catch (InvalidIdException | NoAttributesChangedException | InvalidTaskParametersException
               | DuplicateTaskException e) {
            assert false;
        }
    }
}
```
###### ./src/main/java/jfdi/logic/commands/RescheduleTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.logic.events.RescheduleTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.Duration;
import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskCommand extends Command {

    private int screenId;
    private boolean isShiftedDateSpecified;
    private boolean isShiftedTimeSpecified;
    private LocalDateTime shiftedDateTime;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime oldStartDateTime;
    private LocalDateTime oldEndDateTime;

    private RescheduleTaskCommand(Builder builder) {
        this.screenId = builder.screenId;
        this.isShiftedDateSpecified = builder.isShiftedDateSpecified;
        this.isShiftedTimeSpecified = builder.isShiftedTimeSpecified;
        this.shiftedDateTime = builder.shiftedDateTime;
        this.startDateTime = builder.startDateTime;
        this.endDateTime = builder.endDateTime;
    }

    public int getScreenId() {
        return screenId;
    }

    public boolean isShiftedDateSpecified() {
        return isShiftedDateSpecified;
    }

    public boolean isShiftedTimeSpecified() {
        return isShiftedTimeSpecified;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public LocalDateTime getOldStartDateTime() {
        return oldStartDateTime;
    }

    public LocalDateTime getOldEndDateTime() {
        return oldEndDateTime;
    }

    public static class Builder {

        int screenId;
        boolean isShiftedDateSpecified = false;
        boolean isShiftedTimeSpecified = false;
        LocalDateTime shiftedDateTime;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setId(int screenId) {
            this.screenId = screenId;
            return this;
        }

        public Builder setShiftedDateSpecified(boolean isShiftedDateSpecified) {
            this.isShiftedDateSpecified = isShiftedDateSpecified;
            return this;
        }

        public Builder setShiftedTimeSpecified(boolean isShiftedTimeSpecified) {
            this.isShiftedTimeSpecified = isShiftedTimeSpecified;
            return this;
        }

        public Builder setShiftedDateTime(LocalDateTime shiftedDateTime) {
            this.shiftedDateTime = shiftedDateTime;
            return this;
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
            this.startDateTime = startDateTime;
            return this;
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
            this.endDateTime = endDateTime;
            return this;
        }

        public RescheduleTaskCommand build() {
            return new RescheduleTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            oldStartDateTime = task.getStartDateTime();
            oldEndDateTime = task.getEndDateTime();

            if (shiftedDateTime != null) {
                shiftStartAndEndDateTimes(task);
            }

            task.setStartDateTime(startDateTime);
            task.setEndDateTime(endDateTime);
            task.save();

            pushToUndoStack();
            eventBus.post(new RescheduleTaskDoneEvent(task));

            logger.info("Task #" + taskId + " rescheduled.");
        } catch (InvalidIdException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID));

            logger.warning("Reschedule failed: Invalid id");
        } catch (InvalidTaskParametersException e) {
            // Should not happen
            assert false;
        } catch (NoAttributesChangedException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.NO_CHANGES));

            logger.warning("Reschedule failed: Date time not changed");
        } catch (DuplicateTaskException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.DUPLICATED_TASK));

            logger.warning("Reschedule failed: Duplicate task");
        }
    }

    @Override
    public void undo() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            task.setStartDateTime(oldStartDateTime);
            task.setEndDateTime(oldEndDateTime);
            task.save();

            logger.info("Undo rescheduling: rescheduled back #" + taskId);
        } catch (InvalidIdException | InvalidTaskParametersException | NoAttributesChangedException
            | DuplicateTaskException e) {
            assert false;
        }
    }

    private void shiftStartAndEndDateTimes(TaskAttributes task) {
        LocalDateTime taskStart = task.getStartDateTime();
        LocalDateTime taskEnd = task.getEndDateTime();

        if (taskStart == null && taskEnd == null) {
            startDateTime = shiftedDateTime;
            endDateTime = null;

            logger.info("Shifting a floating task to a point task.");
        } else if (taskStart != null && taskEnd == null) {
            startDateTime = getShiftedDateTime(task.getStartDateTime());
            endDateTime = null;

            logger.info("Shifting point task.");
        } else if (taskStart == null) {
            startDateTime = null;
            endDateTime = getShiftedDateTime(task.getEndDateTime());

            logger.info("Shifting deadline task.");
        } else {
            Duration eventDuration = Duration.between(taskStart, taskEnd);
            startDateTime = getShiftedDateTime(task.getStartDateTime());
            endDateTime = startDateTime.plus(eventDuration);

            logger.info("Shifting event task.");
        }
    }

    public LocalDateTime getShiftedDateTime() {
        return shiftedDateTime;
    }

    private LocalDateTime getShiftedDateTime(LocalDateTime dateTime) {
        // At least one of them must be true
        if (!isShiftedTimeSpecified) {
            return shiftDate(dateTime);
        } else if (!isShiftedDateSpecified) {
            return shiftTime(dateTime);
        } else {
            return shiftedDateTime;
        }
    }

    private LocalDateTime shiftTime(LocalDateTime originalDateTime) {
        return LocalDateTime.of(originalDateTime.toLocalDate(), shiftedDateTime.toLocalTime());
    }

    private LocalDateTime shiftDate(LocalDateTime originalDateTime) {
        return LocalDateTime.of(shiftedDateTime.toLocalDate(), originalDateTime.toLocalTime());
    }

}
```
###### ./src/main/java/jfdi/logic/commands/SearchCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import opennlp.tools.stemmer.PorterStemmer;
import org.apache.commons.lang3.tuple.ImmutableTriple;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class SearchCommand extends Command {

    private static final PorterStemmer stemmer = new PorterStemmer();

    private HashSet<String> keywords;

    private ArrayList<TaskAttributes> results;

    private SearchCommand(Builder builder) {
        this.keywords = builder.keywords;
    }

    public HashSet<String> getKeywords() {
        return keywords;
    }

    public ArrayList<TaskAttributes> getResults() {
        return results;
    }

    public static class Builder {

        HashSet<String> keywords = new HashSet<>();

        public Builder addKeyword(String keyword) {
            this.keywords.add(keyword);
            return this;
        }

        public Builder addKeywords(Collection<String> keywords) {
            this.keywords.addAll(keywords);
            return this;
        }

        public SearchCommand build() {
            return new SearchCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> fullMatches = taskDb.getAll().stream()
                .map(this::constructFullMatchCancidate)
                .filter(this::isValidCandidate)
                .sorted(this::candidateCompare)
                .map(ImmutableTriple::getRight)
                .collect(Collectors.toCollection(ArrayList::new));

        results = new ArrayList<>(fullMatches);

        results.addAll(taskDb.getAll().stream()
                .map(this::constructStemMatchCandidate)
                .filter(this::isValidCandidate)
                .sorted(this::candidateCompare)
                .map(ImmutableTriple::getRight)
                .filter(task -> !fullMatches.contains(task))
                .collect(Collectors.toCollection(ArrayList::new)));

        logger.info(String.format("Search completed. %d results found.", results.size()));

        eventBus.post(new SearchDoneEvent(results, keywords));
    }

    private ImmutableTriple<Long, Integer, TaskAttributes> constructFullMatchCancidate(TaskAttributes task) {
        String[] parts = task.getDescription().split("\\s+");
        int wordCount = parts.length;

        long rank = Arrays.stream(parts)
            .filter(this::isFullMatch)
            .count();

        return new ImmutableTriple<Long, Integer, TaskAttributes>(rank, wordCount, task);
    }

    private ImmutableTriple<Long, Integer, TaskAttributes> constructStemMatchCandidate(TaskAttributes task) {
        String[] parts = task.getDescription().split("\\s+");
        int wordCount = parts.length;

        long rank = Arrays.stream(parts)
                .map(stemmer::stem)
                .filter(this::isStemMatch)
                .count();

        return new ImmutableTriple<Long, Integer, TaskAttributes>(rank, wordCount, task);
    }

    private boolean isValidCandidate(ImmutableTriple<Long, Integer, TaskAttributes> candidate) {
        return candidate.getLeft() > 0;
    }

    private boolean isFullMatch(String word) {
        return keywords.stream()
                .reduce(
                    false,
                    (isMatched, keyword) -> isMatched || word.equalsIgnoreCase(keyword),
                    (isPreviouslyMatched, isNowMatched) -> isPreviouslyMatched || isNowMatched
                );
    }

    private boolean isStemMatch(String word) {
        return keywords.stream()
                .map(stemmer::stem)
                .reduce(
                        false,
                        (isMatched, keyword) -> isMatched || word.equalsIgnoreCase(keyword),
                        (isPreviouslyMatched, isNowMatched) -> isPreviouslyMatched || isNowMatched
                );
    }

    private int candidateCompare(ImmutableTriple<Long, Integer, TaskAttributes> left,
                                 ImmutableTriple<Long, Integer, TaskAttributes> right) {

        if (left.getLeft() > right.getLeft()) {
            return -1;
        } else if (left.getLeft() < right.getLeft()) {
            return 1;
        } else {
            return left.getMiddle() - right.getMiddle();
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/UnaliasCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.UnaliasDoneEvent;
import jfdi.logic.events.UnaliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.InvalidAliasException;

/**
 * @author Liu Xinan
 */
public class UnaliasCommand extends Command {

    private String alias;

    private UnaliasCommand(Builder builder) {
        this.alias = builder.alias;
    }

    public String getAlias() {
        return alias;
    }

    public static class Builder {

        String alias;

        public Builder setAlias(String alias) {
            this.alias = alias;
            return this;
        }

        public UnaliasCommand build() {
            return new UnaliasCommand(this);
        }

    }

    @Override
    public void execute() {
        try {
            aliasDb.destroy(alias);
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new UnaliasDoneEvent(alias));

            logger.info("Alias deleted: " + alias);
        } catch (InvalidAliasException e) {
            eventBus.post(new UnaliasFailedEvent(alias, UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS));

            logger.info("Delete alias failed: Invalid alias");
        }
    }

    @Override
    public void undo() {
        try {
            aliasDb.undestroy(alias);
            parser.setAliases(aliasDb.getAll());

            logger.info("Undo deleting alias: Adding alias " + alias + " back");
        } catch (InvalidAliasException e) {
            assert false;
        }
    }

}
```
###### ./src/main/java/jfdi/logic/commands/UndoCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.CommandUndoneEvent;
import jfdi.logic.events.UndoFailedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class UndoCommand extends Command {

    private UndoCommand(Builder builder) {}

    public static class Builder {

        public UndoCommand build() {
            return new UndoCommand(this);
        }

    }

    @Override
    public void execute() {
        if (!undoStack.empty()) {
            Command lastUndoableCommand = undoStack.pop();
            lastUndoableCommand.undo();

            eventBus.post(new CommandUndoneEvent(lastUndoableCommand.getClass()));

            logger.info("Undoing previous " + lastUndoableCommand.getClass());
        } else {
            eventBus.post(new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO));

            logger.warning("Undo failed: Nothing to undo");
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/commands/UnmarkTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.logic.events.UnmarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskCommand extends Command {

    private static final Logger LOGGER = JfdiLogger.getLogger();

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> unmarkedIds;

    private UnmarkTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getUnmarkedIds() {
        return unmarkedIds;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addTaskId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addTaskIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public UnmarkTaskCommand build() {
            return new UnmarkTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            ArrayList<TaskAttributes> unmarkedTasks = new ArrayList<>();
            unmarkedIds = new ArrayList<>();
            taskIds.stream().forEach(id -> {
                try {
                    unmarkedTasks.add(taskDb.getById(id));
                    taskDb.markAsIncomplete(id);

                    unmarkedIds.add(id);

                    logger.info("Task unmarked: #" + id);
                } catch (NoAttributesChangedException e) {
                    LOGGER.warning("Task " + id + " was not completed.");
                } catch (InvalidIdException e) {
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new UnmarkTaskDoneEvent(screenIds, unmarkedTasks));
        } else {
            eventBus.post(new UnmarkTaskFailedEvent(screenIds, invalidIds));

            logger.warning("Some invalid id(s) supplied. Not marking any tasks as incomplete.");
        }
    }

    @Override
    public void undo() {
        unmarkedIds.stream().forEach(id -> {
            try {
                taskDb.markAsComplete(id);

                logger.info("Undo unmarking task: #" + id);
            } catch (NoAttributesChangedException | InvalidIdException e) {
                assert false;
            }
        });
    }

}
```
###### ./src/main/java/jfdi/logic/commands/UseDirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.UseDirectoryDoneEvent;
import jfdi.logic.events.UseDirectoryFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
public class UseDirectoryCommand extends Command {

    private String oldDirectory;
    private String newDirectory;

    private UseDirectoryCommand(Builder builder) {
        this.newDirectory = builder.newDirectory;
    }

    public static class Builder {

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
            this.newDirectory = newDirectory;
            return this;
        }

        public UseDirectoryCommand build() {
            return new UseDirectoryCommand(this);
        }

    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public String getOldDirectory() {
        return oldDirectory;
    }

    @Override
    public void execute() {
        try {
            oldDirectory = mainStorage.getCurrentDirectory();

            mainStorage.use(newDirectory);
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new UseDirectoryDoneEvent(newDirectory));

            logger.info("Direcroty switched to: " + newDirectory);
        } catch (FilesReplacedException e) {
            eventBus.post(new UseDirectoryDoneEvent(newDirectory));
            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));

            logger.warning("Destination files replaced.");
        } catch (InvalidFilePathException e) {
            eventBus.post(new UseDirectoryFailedEvent(newDirectory, UseDirectoryFailedEvent.Error.INVALID_PATH));

            logger.warning("Invalid file path specified.");
        }
    }

    @Override
    public void undo() {
        try {
            mainStorage.use(oldDirectory);
            parser.setAliases(aliasDb.getAll());

            logger.info("Undo switching directory: Switching back to " + oldDirectory);
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            assert false;
        }
    }
}
```
###### ./src/main/java/jfdi/logic/commands/WildcardCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.NoSurpriseEvent;
import jfdi.logic.events.SurpriseEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class WildcardCommand extends Command {

    private TaskAttributes lucky;

    private WildcardCommand(Builder builder) {}

    public static class Builder {

        public WildcardCommand build() {
            return new WildcardCommand(this);
        }

    }

    public TaskAttributes getLucky() {
        return lucky;
    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> incompleteTasks = taskDb.getAll().stream()
                .filter(task -> !task.isCompleted() && task.getStartDateTime() == null)
                .collect(Collectors.toCollection(ArrayList::new));

        SecureRandom random = new SecureRandom();

        if (!incompleteTasks.isEmpty()) {
            lucky = incompleteTasks.get(random.nextInt(incompleteTasks.size()));
            eventBus.post(new SurpriseEvent(lucky));

            logger.info("Lucky task chosen: " + lucky.getDescription());
        } else {
            eventBus.post(new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS));

            logger.warning("No surprise for everybody!");
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### ./src/main/java/jfdi/logic/ControlCenter.java
``` java

package jfdi.logic;

import com.google.common.eventbus.EventBus;
import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.InitializationFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.logic.interfaces.ILogic;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.*;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import jfdi.ui.UI;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ControlCenter implements ILogic {

    private static final Logger logger = JfdiLogger.getLogger();

    private static ControlCenter ourInstance;

    private static EventBus eventBus = UI.getEventBus();

    private static MainStorage mainStorage = MainStorage.getInstance();
    private static TaskDb taskDb = TaskDb.getInstance();
    private static AliasDb aliasDb = AliasDb.getInstance();

    private static InputParser parser = InputParser.getInstance();

    private ControlCenter() {
        initStorage();
        initParser();
    }

    public static ControlCenter getInstance() {
        if (ourInstance == null) {
            ourInstance = new ControlCenter();
        }
        return ourInstance;
    }

    @Override
    public void handleInput(String input) {
        logger.info("Handling input: " + input);

        Command command;
        try {
            command = parser.parse(input);
        } catch (InvalidInputException e) {
            command = new InvalidCommand.Builder().build();
        }
        command.execute();
    }

    @Override
    public TreeSet<String> getKeywords() {
        TreeSet<String> keywords = Arrays.stream(InputParser.getInstance()
            .getAllCommandRegexes()
            .replaceAll("\\W+", " ").split("\\s+"))
            .filter(part -> part.length() > 1)
            .collect(Collectors.toCollection(TreeSet::new));

        AliasDb.getInstance()
            .getAll().stream()
            .map(AliasAttributes::getAlias)
            .forEach(keywords::add);

        return keywords;
    }

    @Override
    public ArrayList<TaskAttributes> getIncompleteTasks() {
        return taskDb.getAll().stream()
            .filter(task -> !task.isCompleted())
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getCompletedTasks() {
        return taskDb.getAll().stream()
            .filter(TaskAttributes::isCompleted)
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getAllTasks() {
        return taskDb.getAll().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getUpcomingTasks() {
        return taskDb.getUpcoming().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getOverdueTasks() {
        return taskDb.getOverdue().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    private void initStorage() {
        logger.info("Initializing Storage...");

        // Set a list of permitted commands that can be aliased
        AliasAttributes.setCommandRegex(parser.getAllCommandRegexes());
        try {
            mainStorage.initialize();
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            eventBus.post(new InitializationFailedEvent(InitializationFailedEvent.Error.INVALID_PATH,
                e.getPath()));
        }

        logger.info("Storage initialized successfully!");
    }

    private void initParser() {
        logger.info("Initializing Parser...");

        parser.setAliases(aliasDb.getAll());

        logger.info("Parser initialized successfully!");
    }

    //================================================================
    // Methods for testing.
    //================================================================

    public static void removeInstance() {
        ourInstance = null;
    }

    public static void setParser(InputParser parser) {
        ControlCenter.parser = parser;
    }

    public static void setMainStorage(MainStorage mainStorage) {
        ControlCenter.mainStorage = mainStorage;
    }

    public static void setTaskDb(TaskDb taskDb) {
        ControlCenter.taskDb = taskDb;
    }

    public static void setAliasDb(AliasDb aliasDb) {
        ControlCenter.aliasDb = aliasDb;
    }

    public static void setEventBus(EventBus eventBus) {
        ControlCenter.eventBus = eventBus;
    }

}
```
###### ./src/main/java/jfdi/logic/events/AddTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class AddTaskDoneEvent {

    private TaskAttributes task;

    public AddTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }
}
```
###### ./src/main/java/jfdi/logic/events/AddTaskFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AddTaskFailedEvent {

    public enum Error {
        EMPTY_DESCRIPTION, DUPLICATED_TASK
    }

    private Error error;

    public AddTaskFailedEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }
}
```
###### ./src/main/java/jfdi/logic/events/AliasDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasDoneEvent {

    private String command;
    private String alias;

    public AliasDoneEvent(String command, String alias) {
        this.command = command;
        this.alias = alias;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### ./src/main/java/jfdi/logic/events/AliasFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasFailedEvent {

    public enum Error {
        INVALID_PARAMETERS, DUPLICATED_ALIAS, UNKNOWN
    }

    private String command;
    private String alias;
    private Error error;

    public AliasFailedEvent(String command, String alias, Error error) {
        this.command = command;
        this.alias = alias;
        this.error = error;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/CommandRedoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandRedoneEvent {

    private Class<? extends Command> commandType;

    public CommandRedoneEvent(Class<? extends Command> commandType) {
        this.commandType = commandType;
    }

    public Class<? extends Command> getCommandType() {
        return commandType;
    }

}
```
###### ./src/main/java/jfdi/logic/events/CommandUndoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEvent {

    private Class<? extends Command> commandType;

    public CommandUndoneEvent(Class<? extends Command> commandType) {
        this.commandType = commandType;
    }

    public Class<? extends Command> getCommandType() {
        return commandType;
    }

}
```
###### ./src/main/java/jfdi/logic/events/DeleteTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskDoneEvent {

    private ArrayList<Integer> deletedIds;
    private ArrayList<TaskAttributes> deletedTasks;

    public DeleteTaskDoneEvent(ArrayList<Integer> deletedIds, ArrayList<TaskAttributes> deletedTasks) {
        this.deletedIds = deletedIds;
        this.deletedTasks = deletedTasks;
    }

    public ArrayList<Integer> getDeletedIds() {
        return deletedIds;
    }

    public ArrayList<TaskAttributes> getDeletedTasks() {
        return deletedTasks;
    }
}
```
###### ./src/main/java/jfdi/logic/events/DeleteTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> invalidIds;
    private Error error;

    public DeleteTaskFailedEvent(ArrayList<Integer> invalidIds) {
        error = Error.NON_EXISTENT_ID;
        this.invalidIds = invalidIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }
}
```
###### ./src/main/java/jfdi/logic/events/ExitCalledEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ExitCalledEvent {}
```
###### ./src/main/java/jfdi/logic/events/FilesReplacedEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.exceptions.FilePathPair;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEvent {

    private String newDirectory = null;
    private ArrayList<FilePathPair> filePathPairs;

    public FilesReplacedEvent(ArrayList<FilePathPair> filePathPairs) {
        this.filePathPairs = filePathPairs;
    }

    public FilesReplacedEvent(String newDirectory, ArrayList<FilePathPair> filePathPairs) {
        this.newDirectory = newDirectory;
        this.filePathPairs = filePathPairs;
    }

    public ArrayList<FilePathPair> getFilePathPairs() {
        return filePathPairs;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### ./src/main/java/jfdi/logic/events/HelpRequestedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class HelpRequestedEvent {}
```
###### ./src/main/java/jfdi/logic/events/InitializationFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private Error error;
    private String path;

    public InitializationFailedEvent(Error error, String path) {
        this.error = error;
        this.path = path;
    }

    public Error getError() {
        return error;
    }

    public String getPath() {
        return path;
    }

}
```
###### ./src/main/java/jfdi/logic/events/InvalidCommandEvent.java
``` java

package jfdi.logic.events;

import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEvent {

    private String inputString;
    private CommandType commandType;

    public InvalidCommandEvent(String inputString, CommandType commandType) {
        this.inputString = inputString;
        this.commandType = commandType;
    }

    public String getInputString() {
        return inputString;
    }

    public CommandType getCommandType() {
        return commandType;
    }

}
```
###### ./src/main/java/jfdi/logic/events/ListDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.commands.ListCommand.ListType;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class ListDoneEvent {

    private ListType listType;
    private ArrayList<TaskAttributes> items;

    public ListDoneEvent(ListType listType, ArrayList<TaskAttributes> items) {
        this.listType = listType;
        this.items = items;
    }

    public ArrayList<TaskAttributes> getItems() {
        return items;
    }

    public ListType getListType() {
        return listType;
    }
}
```
###### ./src/main/java/jfdi/logic/events/MarkTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEvent {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> markedTasks;

    public MarkTaskDoneEvent(ArrayList<Integer> screenIds, ArrayList<TaskAttributes> markedTasks) {
        this.screenIds = screenIds;
        this.markedTasks = markedTasks;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getMarkedTasks() {
        return markedTasks;
    }

}
```
###### ./src/main/java/jfdi/logic/events/MarkTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> invalidIds;
    private Error error;

    public MarkTaskFailedEvent(ArrayList<Integer> screenIds, ArrayList<Integer> invalidIds) {
        this.screenIds = screenIds;
        this.invalidIds = invalidIds;
        this.error = Error.NON_EXISTENT_ID;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/MoveDirectoryDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEvent {

    private String newDirectory;

    public MoveDirectoryDoneEvent(String newDirectory) {
        this.newDirectory = newDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### ./src/main/java/jfdi/logic/events/MoveDirectoryFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private String newDirectory;
    private Error error;

    public MoveDirectoryFailedEvent(String newDirectory, Error error) {
        this.newDirectory = newDirectory;
        this.error = error;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/NoSurpriseEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEvent {

    public enum Error {
        NO_TASKS, UNKNOWN
    }

    private Error error;

    public NoSurpriseEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/RenameTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEvent {

    private TaskAttributes task;

    public RenameTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }
}
```
###### ./src/main/java/jfdi/logic/events/RenameTaskFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID,
        DUPLICATED_TASK,
        NO_CHANGES,
        UNKNOWN
    }

    private int screenId;
    private String description;
    private Error error;

    public RenameTaskFailedEvent(int screenId, String description, Error error) {
        this.screenId = screenId;
        this.description = description;
        this.error = error;
    }

    public int getScreenId() {
        return screenId;
    }

    public String getDescription() {
        return description;
    }

    public Error getError() {
        return error;
    }
}
```
###### ./src/main/java/jfdi/logic/events/RescheduleTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEvent {

    private TaskAttributes task;

    public RescheduleTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }

}
```
###### ./src/main/java/jfdi/logic/events/RescheduleTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID,
        DUPLICATED_TASK,
        NO_CHANGES,
        UNKNOWN
    }

    private int screenId;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private Error error;

    public RescheduleTaskFailedEvent(int screenId, LocalDateTime startDateTime, LocalDateTime endDateTime,
                                     Error error) {
        this.screenId = screenId;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.error = error;
    }

    public int getScreenId() {
        return screenId;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public Error getError() {
        return error;
    }
}
```
###### ./src/main/java/jfdi/logic/events/SearchDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.HashSet;

/**
 * @author Liu Xinan
 */
public class SearchDoneEvent {

    private ArrayList<TaskAttributes> results;
    private HashSet<String> keywords;

    public SearchDoneEvent(ArrayList<TaskAttributes> results, HashSet<String> keywords) {
        this.results = results;
        this.keywords = keywords;
    }

    public ArrayList<TaskAttributes> getResults() {
        return results;
    }

    public HashSet<String> getKeywords() {
        return keywords;
    }

}
```
###### ./src/main/java/jfdi/logic/events/ShowDirectoryEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEvent {

    private String pwd;

    public ShowDirectoryEvent(String pwd) {
        this.pwd = pwd;
    }

    public String getPwd() {
        return pwd;
    }

}
```
###### ./src/main/java/jfdi/logic/events/SurpriseEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class SurpriseEvent {

    private TaskAttributes task;

    public SurpriseEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UnaliasDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEvent {

    private String alias;

    public UnaliasDoneEvent(String alias) {
        this.alias = alias;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UnaliasFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEvent {

    public enum Error {
        NON_EXISTENT_ALIAS,
        UNKNOWN
    }

    private String alias;
    private Error error;

    public UnaliasFailedEvent(String alias, Error error) {
        this.alias = alias;
        this.error = error;
    }

    public String getAlias() {
        return alias;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UndoFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UndoFailedEvent {

    public enum Error {
        NONTHING_TO_UNDO, UNKNOWN
    }

    private Error error;

    public UndoFailedEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UnmarkTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEvent {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> unmarkedTasks;

    public UnmarkTaskDoneEvent(ArrayList<Integer> screenIds, ArrayList<TaskAttributes> unmarkedTasks) {
        this.screenIds = screenIds;
        this.unmarkedTasks = unmarkedTasks;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getUnmarkedTasks() {
        return unmarkedTasks;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UnmarkTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> invalidIds;
    private Error error;

    public UnmarkTaskFailedEvent(ArrayList<Integer> screenIds, ArrayList<Integer> invalidIds) {
        this.screenIds = screenIds;
        this.invalidIds = invalidIds;
        this.error = Error.NON_EXISTENT_ID;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UseDirectoryDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEvent {

    private String newDirectory;

    public UseDirectoryDoneEvent(String newDirectory) {
        this.newDirectory = newDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### ./src/main/java/jfdi/logic/events/UseDirectoryFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private String newDirectory;
    private Error error;

    public UseDirectoryFailedEvent(String newDirectory, Error error) {
        this.newDirectory = newDirectory;
        this.error = error;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public Error getError() {
        return error;
    }

}
```
###### ./src/main/java/jfdi/logic/interfaces/Command.java
``` java

package jfdi.logic.interfaces;

import java.util.Stack;
import java.util.logging.Logger;

import com.google.common.eventbus.EventBus;

import jfdi.common.utilities.JfdiLogger;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;

/**
 * @author Liu Xinan
 */
public abstract class Command {

    protected static final Logger logger = JfdiLogger.getLogger();
    protected static EventBus eventBus = UI.getEventBus();

    protected static final Stack<Command> undoStack = new Stack<>();

    protected static UI ui = UI.getInstance();
    protected static InputParser parser = InputParser.getInstance();
    protected static MainStorage mainStorage = MainStorage.getInstance();
    protected static TaskDb taskDb = TaskDb.getInstance();
    protected static AliasDb aliasDb = AliasDb.getInstance();

    /**
     * Executes the command.
     */
    public abstract void execute();

    /**
     * Undoes the command.
     */
    public abstract void undo();

    public void pushToUndoStack() {
        undoStack.push(this);
    }

    //================================================================
    // List of setters and getters for testing.
    //================================================================


    public static void setUi(UI ui) {
        Command.ui = ui;
    }

    public static void setParser(InputParser parser) {
        Command.parser = parser;
    }

    public static void setMainStorage(MainStorage mainStorage) {
        Command.mainStorage = mainStorage;
    }

    public static void setTaskDb(TaskDb taskDb) {
        Command.taskDb = taskDb;
    }

    public static void setAliasDb(AliasDb aliasDb) {
        Command.aliasDb = aliasDb;
    }

    public static void setEventBus(EventBus eventBus) {
        Command.eventBus = eventBus;
    }

    public static Stack<Command> getUndoStack() {
        return undoStack;
    }

    public static void clearUndoStack() {
        undoStack.clear();
    }

    public static UI getUI() {
        return ui;
    }

    public static InputParser getParser() {
        return parser;
    }

    public static MainStorage getMainStorage() {
        return mainStorage;
    }

    public static TaskDb getTaskDb() {
        return taskDb;
    }

    public static AliasDb getAliasDb() {
        return aliasDb;
    }

    public static EventBus getEventBus() {
        return eventBus;
    }

}
```
###### ./src/main/java/jfdi/logic/interfaces/ILogic.java
``` java

package jfdi.logic.interfaces;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.TreeSet;

/**
 * @author Liu Xinan
 */
public interface ILogic {

    /**
     * Handles user's input.
     * Called by UI whenever the user inputs a text command.
     *
     * @param input Input from user
     */
    void handleInput(String input);

    /**
     * Gets the list of command keywords.
     * Called by UI for populating auto-completion suggestion list.
     *
     * @return a {@code TreeSet} of {@code String}
     */
    TreeSet<String> getKeywords();

    /**
     * Gets the list of incomplete tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getIncompleteTasks();

    /**
     * Gets the list of completed tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getCompletedTasks();

    /**
     * Gets the list of all tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getAllTasks();

    /**
     * Gets the list of upcoming tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getUpcomingTasks();

    /**
     * Gets the list of overdue tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getOverdueTasks();
}
```
###### ./src/main/java/jfdi/ui/items/AutoCompleteTextField.java
``` java

package jfdi.ui.items;

import javafx.geometry.Side;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import jfdi.ui.UI;

import java.util.LinkedList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class AutoCompleteTextField extends TextField {

    private SortedSet<String> keywords;
    private LinkedList<String> results;

    private ContextMenu popup;

    public AutoCompleteTextField() {
        super();
        keywords = new TreeSet<>(String::compareToIgnoreCase);
        results = new LinkedList<>();
        popup = new ContextMenu();

        textProperty().addListener((observable, oldValue, newValue) -> {
            if (getText().isEmpty()) {
                popup.hide();
                return;
            }
            results.clear();
            results.addAll(keywords.subSet(getText(), getText() + Character.MAX_VALUE));
            if (results.isEmpty()) {
                popup.hide();
            } else {
                populatePopup(results);
            }
        });

        focusedProperty().addListener((observable, oldValue, newValue) -> popup.hide());

        popup.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            @SuppressWarnings("deprecation")
            boolean isAnyItemSelected = popup.getItems().stream().map(item -> item.impl_styleableGetNode())
                    .anyMatch(node -> node.isFocused());
            if (event.getCode() == KeyCode.ENTER && !isAnyItemSelected) {
                UI.getInstance().triggerEnter();
                results.clear();
            }
        });
    }

    public void setKeywords(SortedSet<String> keywords) {
        this.keywords.clear();
        this.keywords.addAll(keywords);
    }

    public void hidePopup() {
        popup.hide();
    }

    public void selectFirst() {
        if (!results.isEmpty()) {
            select(results.get(0));
            popup.hide();
        }
    }

    private void select(String suggestion) {
        setText(suggestion + " ");
        this.positionCaret(this.getText().length());
    }

    private void populatePopup(LinkedList<String> results) {
        List<CustomMenuItem> menuItems = results.stream()
            .map(Label::new)
            .map(label -> {
                CustomMenuItem menuItem = new CustomMenuItem(label, true);
                menuItem.setOnAction(action -> {
                    select(label.getText());
                    popup.hide();
                });
                return menuItem;
            })
            .collect(Collectors.toCollection(LinkedList::new));

        popup.getItems().setAll(menuItems);

        if (!popup.isShowing()) {
            popup.show(this, Side.BOTTOM, 0, 0);
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/AddTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.doThrow;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AddTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        LocalDateTime startDateTime = LocalDateTime.of(2016, 4, 1, 0, 0);
        LocalDateTime endDateTime = LocalDateTime.of(2016, 4, 1, 23, 59);

        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("test")
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .build();

        assertEquals("test", command.getDescription());
        assertEquals(startDateTime, command.getStartDateTime().get());
        assertEquals(endDateTime, command.getEndDateTime().get());
    }

    @Test
    public void testExecute_successful() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("sleep")
            .build();

        command.execute();

        int id = command.getId();
        assertNotEquals(-1, id);

        TaskAttributes task = TaskDb.getInstance().getById(id);
        assertEquals("sleep", task.getDescription());

        TaskDb.getInstance().destroy(id);
    }

    @Test
    public void testExecute_emptyDescription() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder().build();

        command.execute();

        assertEquals(-1, command.getId());
    }

    @Test
    public void testExecute_duplicatedTask() throws Exception {
        AddTaskCommand command1 = new AddTaskCommand.Builder()
            .setDescription("duplicate")
            .build();

        command1.execute();

        int id1 = command1.getId();
        assertNotEquals(-1, id1);

        AddTaskCommand command2 = new AddTaskCommand.Builder()
            .setDescription("duplicate")
            .build();

        command2.execute();

        assertEquals(-1, command2.getId());

        TaskDb.getInstance().destroy(id1);
    }

    @Test
    public void testUndo_successful() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("undo")
            .build();

        command.execute();

        int id = command.getId();

        Command.setTaskDb(TaskDb.getInstance());
        command.undo();
        Command.setTaskDb(taskDb);

        thrown.expect(InvalidIdException.class);
        TaskDb.getInstance().getById(id);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        doThrow(InvalidIdException.class).when(taskDb).destroy(anyInt());

        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("undo")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/AliasCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AliasCommand;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.exceptions.InvalidAliasException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AliasCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        AliasCommand command1 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        assertEquals("list", command1.getCommand());
        assertEquals("ls", command1.getAlias());
        assertTrue(command1.isValid());

        AliasCommand command2 = new AliasCommand.Builder()
            .setCommand("ls")
            .setAlias("list")
            .setIsValid(false)
            .build();

        assertEquals("ls", command2.getCommand());
        assertEquals("list", command2.getAlias());
        assertFalse(command2.isValid());
    }

    @Test
    public void testExecute_successful() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command.execute();

        String commandString = AliasDb.getInstance().getCommandFromAlias("ls");
        assertEquals("list", commandString);

        AliasDb.getInstance().destroy("ls");
    }

    @Test
    public void testExecute_duplicateAlias() throws Exception {
        AliasCommand command1 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command1.execute();

        int currentUndoStackSize = Command.getUndoStack().size();

        AliasCommand command2 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command2.execute();

        assertEquals(currentUndoStackSize, Command.getUndoStack().size());

        String commandString = AliasDb.getInstance().getCommandFromAlias("ls");
        assertEquals("list", commandString);

        AliasDb.getInstance().destroy("ls");
    }

    @Test
    public void testExecute_invalidAlias() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("add")
            .setIsValid(true)
            .build();

        int currentUndoStackSize = Command.getUndoStack().size();

        command.execute();

        assertEquals(currentUndoStackSize, Command.getUndoStack().size());
    }

    @Test
    public void testUndo_successful() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command.undo();
        verify(aliasDb).destroy("ls");
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        doThrow(InvalidAliasException.class).when(aliasDb).destroy("ls");

        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/CommonCommandTest.java
``` java

package jfdi.test.logic.commands;

import com.google.common.eventbus.EventBus;
import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public abstract class CommonCommandTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Mock
    protected UI ui;

    @Mock
    protected MainStorage mainStorage;

    @Mock
    protected TaskDb taskDb;

    @Mock
    protected AliasDb aliasDb;

    @Mock
    protected InputParser parser;

    @Mock
    protected EventBus eventBus;

    @Before
    public void setUp() throws Exception {
        Command.setUi(ui);
        Command.setMainStorage(mainStorage);
        Command.setTaskDb(taskDb);
        Command.setAliasDb(aliasDb);
        Command.setParser(parser);
        Command.setEventBus(eventBus);

        AliasAttributes.setCommandRegex(InputParser.getInstance().getAllCommandRegexes());
        InputParser.getInstance().setAliases(AliasDb.getInstance().getAll());
        MainStorage.getInstance().initialize();
        MainStorage.getInstance().use("./.test_data");
    }

    @After
    public void tearDown() throws Exception {
        Command.setUi(UI.getInstance());
        Command.setMainStorage(MainStorage.getInstance());
        Command.setTaskDb(TaskDb.getInstance());
        Command.setAliasDb(AliasDb.getInstance());
        Command.setParser(InputParser.getInstance());
        Command.setEventBus(UI.getEventBus());
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/DeleteTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DeleteTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<Integer> ids = new ArrayList<>();
        ids.add(2);
        ids.add(3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addIds(ids)
            .build();

        assertEquals(3, command.getScreenIds().size());
        assertTrue(command.getScreenIds().contains(1));
        assertTrue(command.getScreenIds().contains(2));
        assertTrue(command.getScreenIds().contains(3));
    }

    @Test
    public void testExecute_deleteOne_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .build();

        command.execute();

        assertEquals(1, command.getDeletedTasks().size());
    }

    @Test
    public void testExecute_deleteMore_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addId(2)
            .addId(3)
            .build();

        command.execute();

        assertEquals(3, command.getDeletedTasks().size());
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(false);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(3)).thenReturn(task3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addId(2)
            .addId(3)
            .build();

        command.execute();

        assertNull(command.getDeletedTasks());
    }

    @Test
    public void testExecute_shouldNotHappen_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        doThrow(InvalidIdException.class).when(taskDb).getById(1);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addId(2)
            .addId(3)
            .build();

        command.execute();
        command.undo();

        verify(taskDb).destroy(1);
        verify(taskDb).destroy(2);
        verify(taskDb).destroy(3);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).undestroy(anyInt());

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .build();

        command.execute();

        assertEquals(1, command.getDeletedTasks().size());

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/DirectoryCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.DirectoryCommand;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DirectoryCommandTest extends CommonCommandTest {

    @Test
    public void execute() throws Exception {
        DirectoryCommand command = new DirectoryCommand.Builder().build();

        command.execute();

        verify(mainStorage).getCurrentDirectory();
    }

    @Test
    public void undo() throws Exception {
        DirectoryCommand command = new DirectoryCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/ExitCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.ExitCommand;
import jfdi.logic.events.ExitCalledEvent;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ExitCommandTest extends CommonCommandTest {

    @Test
    public void execute() throws Exception {
        ExitCommand command = new ExitCommand.Builder().build();

        command.execute();

        verify(eventBus).post(any(ExitCalledEvent.class));
    }

    @Test
    public void undo() throws Exception {
        ExitCommand command = new ExitCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/HelpCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.HelpCommand;
import jfdi.logic.events.HelpRequestedEvent;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class HelpCommandTest extends CommonCommandTest {

    @Test
    public void execute() throws Exception {
        HelpCommand command = new HelpCommand.Builder().build();

        command.execute();

        verify(eventBus).post(any(HelpRequestedEvent.class));
    }

    @Test
    public void undo() throws Exception {
        HelpCommand command = new HelpCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/InvalidCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.events.InvalidCommandEvent;
import jfdi.parser.Constants;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
public class InvalidCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        InvalidCommand command1 = new InvalidCommand.Builder()
            .setInputString("never gonna give")
            .setCommandType(null)
            .build();

        assertEquals("never gonna give", command1.getInputString());
        assertNull(command1.getCommandType());

        InvalidCommand command2 = new InvalidCommand.Builder()
            .setInputString("list processing")
            .setCommandType(Constants.CommandType.LIST)
            .build();

        assertEquals("list processing", command2.getInputString());
        assertEquals(Constants.CommandType.LIST, command2.getCommandType());
    }

    @Test
    public void execute() throws Exception {
        InvalidCommand command = new InvalidCommand.Builder()
            .setInputString("never gonna give")
            .setCommandType(null)
            .build();

        command.execute();

        verify(eventBus).post(any(InvalidCommandEvent.class));
    }

    @Test
    public void undo() throws Exception {
        InvalidCommand command = new InvalidCommand.Builder()
            .setInputString("list processing")
            .setCommandType(Constants.CommandType.LIST)
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/ListCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.ListDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;
import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ListCommandTest extends CommonCommandTest {

    private ArgumentCaptor<ListDoneEvent> argument = ArgumentCaptor.forClass(ListDoneEvent.class);

    @Before
    public void setUp() throws Exception {
        super.setUp();

        TaskAttributes floating = new TaskAttributes();

        TaskAttributes upcoming = new TaskAttributes();
        upcoming.setStartDateTime(LocalDateTime.now().plusDays(1));

        TaskAttributes overdue = new TaskAttributes();
        overdue.setStartDateTime(LocalDateTime.now().minusDays(1));

        TaskAttributes incomplete = new TaskAttributes();
        incomplete.setCompleted(false);

        TaskAttributes completed = new TaskAttributes();
        completed.setCompleted(true);

        ArrayList<TaskAttributes> tasks = new ArrayList<>();
        tasks.add(floating);
        tasks.add(upcoming);
        tasks.add(overdue);
        tasks.add(incomplete);
        tasks.add(completed);

        ArrayList<TaskAttributes> overdueTasks = new ArrayList<>();
        overdueTasks.add(overdue);

        ArrayList<TaskAttributes> upcomingTasks = new ArrayList<>();
        upcomingTasks.add(upcoming);

        when(taskDb.getAll()).thenReturn(tasks);
        when(taskDb.getOverdue()).thenReturn(overdueTasks);
        when(taskDb.getUpcoming()).thenReturn(upcomingTasks);
    }

    @Test
    public void testBuilder() throws Exception {
        ListCommand listAll = new ListCommand.Builder()
            .setListType(ListCommand.ListType.ALL)
            .build();

        assertEquals(ListCommand.ListType.ALL, listAll.getListType());

        ListCommand listIncomplete = new ListCommand.Builder()
            .setListType(ListCommand.ListType.INCOMPLETE)
            .build();

        assertEquals(ListCommand.ListType.INCOMPLETE, listIncomplete.getListType());

        ListCommand listUpcoming = new ListCommand.Builder()
            .setListType(ListCommand.ListType.UPCOMING)
            .build();

        assertEquals(ListCommand.ListType.UPCOMING, listUpcoming.getListType());

        ListCommand listOverdue = new ListCommand.Builder()
            .setListType(ListCommand.ListType.OVERDUE)
            .build();

        assertEquals(ListCommand.ListType.OVERDUE, listOverdue.getListType());

        ListCommand listCompleted = new ListCommand.Builder()
            .setListType(ListCommand.ListType.COMPLETED)
            .build();

        assertEquals(ListCommand.ListType.COMPLETED, listCompleted.getListType());
    }

    @Test
    public void testExecute_listAll() throws Exception {
        ListCommand listAll = new ListCommand.Builder()
            .setListType(ListCommand.ListType.ALL)
            .build();

        listAll.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(5, argument.getValue().getItems().size());
    }

    @Test
    public void testExecute_listIncomplete() throws Exception {
        ListCommand listIncomplete = new ListCommand.Builder()
            .setListType(ListCommand.ListType.INCOMPLETE)
            .build();

        listIncomplete.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(4, argument.getValue().getItems().size());

        for (int i = 0; i < 4; i++) {
            assertFalse(argument.getValue().getItems().get(i).isCompleted());
        }
    }

    @Test
    public void testExecute_listUpcoming() throws Exception {
        ListCommand listUpcoming = new ListCommand.Builder()
            .setListType(ListCommand.ListType.UPCOMING)
            .build();

        listUpcoming.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(1, argument.getValue().getItems().size());
        assertTrue(argument.getValue().getItems().get(0).getStartDateTime().isAfter(LocalDateTime.now()));
    }

    @Test
    public void testExecute_listOverdue() throws Exception {
        ListCommand listOverdue = new ListCommand.Builder()
            .setListType(ListCommand.ListType.OVERDUE)
            .build();

        listOverdue.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(1, argument.getValue().getItems().size());
        assertTrue(argument.getValue().getItems().get(0).getStartDateTime().isBefore(LocalDateTime.now()));
    }

    @Test
    public void testExecute_listCompleted() throws Exception {
        ListCommand listCompleted = new ListCommand.Builder()
            .setListType(ListCommand.ListType.COMPLETED)
            .build();

        listCompleted.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(1, argument.getValue().getItems().size());
        assertTrue(argument.getValue().getItems().get(0).isCompleted());
    }

    @Test
    public void undo() throws Exception {
        ListCommand listAll = new ListCommand.Builder()
            .setListType(ListCommand.ListType.ALL)
            .build();

        thrown.expect(AssertionError.class);
        listAll.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/MarkTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.MarkTaskCommand;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class MarkTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<Integer> ids = new ArrayList<>();
        ids.add(2);
        ids.add(3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskIds(ids)
            .build();

        assertEquals(3, command.getScreenIds().size());

        assertTrue(command.getScreenIds().contains(1));
        assertTrue(command.getScreenIds().contains(2));
        assertTrue(command.getScreenIds().contains(3));
        assertNull(command.getMarkedIds());
    }

    @Test
    public void testExecute_markSingle_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        assertEquals(1, command.getMarkedIds().size());
    }

    @Test
    public void testExecute_markSingle_alreadyCompleted_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(NoAttributesChangedException.class).when(taskDb).markAsComplete(anyInt());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();
        assertEquals(0, command.getMarkedIds().size());
    }

    @Test
    public void testExecute_markMultiple_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertEquals(3, command.getMarkedIds().size());
    }

    @Test
    public void testExecute_shouldNotHappen_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsComplete(anyInt());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(false);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(3)).thenReturn(task3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertNull(command.getMarkedIds());
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();
        command.undo();

        verify(taskDb).markAsIncomplete(1);
        verify(taskDb).markAsIncomplete(2);
        verify(taskDb).markAsIncomplete(3);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsIncomplete(anyInt());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/MoveDirectoryCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.MoveDirectoryCommand;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class MoveDirectoryCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        assertEquals("./new", command.getNewDirectory());
        assertNull(command.getOldDirectory());
    }

    @Test
    public void testExecute_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(mainStorage).changeDirectory("./new");
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_filesReplaced_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).changeDirectory("./new");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus, times(2)).post(any());
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_invalidPath_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).changeDirectory("./new");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus).post(any(MoveDirectoryFailedEvent.class));
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testUndo_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).changeDirectory("./old");
    }

    @Test
    public void testUndo_filesReplaced_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).changeDirectory("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).changeDirectory("./old");
        verify(eventBus, times(2)).post(any());
    }

    @Test
    public void testUndo_invalidPath_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).changeDirectory("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();

        verify(mainStorage).changeDirectory("./old");
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/RenameTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.RenameTaskCommand;
import jfdi.logic.events.RenameTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class RenameTaskCommandTest extends CommonCommandTest {

    @Before
    public void setUp() throws Exception {
        super.setUp();

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);

        Command.setTaskDb(TaskDb.getInstance());
    }

    @After
    public void tearDown() throws Exception {
        Command.setTaskDb(taskDb);

        super.tearDown();
    }

    @Test
    public void testBuilder() throws Exception {
        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(1)
            .setDescription("Never gonna give")
            .build();

        assertEquals(1, command.getScreenId());
        assertEquals("Never gonna give", command.getDescription());
        assertNull(command.getOldDescription());
    }

    @Test
    public void testExecute_successful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task 1");
        task.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("Never gonna give")
            .build();

        command.execute();

        assertEquals("Task 1", command.getOldDescription());
        assertNotEquals("Never gonna give", task.getDescription());

        TaskDb.getInstance().destroy(task.getId());
    }

    @Test
    public void testExecute_invalidId_unsuccessful() throws Exception {
        doThrow(InvalidIdException.class).when(taskDb).getById(anyInt());

        Command.setTaskDb(taskDb);

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(1)
            .setDescription("Never gonna give")
            .build();

        command.execute();
        verify(eventBus).post(any(RenameTaskFailedEvent.class));
    }

    @Test
    public void testExecute_noAttributesChanged_unsuccessful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task");
        task.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("Task")
            .build();

        command.execute();

        verify(eventBus).post(any(RenameTaskFailedEvent.class));

        TaskDb.getInstance().destroy(task.getId());
    }

    @Test
    public void testExecute_duplicateTask_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        task1.setDescription("Task 1");
        task1.save();

        TaskAttributes task2 = new TaskAttributes();
        task2.setDescription("Task 2");
        task2.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task2.getId())
            .setDescription("Task 1")
            .build();

        command.execute();

        verify(eventBus).post(any(RenameTaskFailedEvent.class));

        TaskDb.getInstance().destroy(task1.getId());
        TaskDb.getInstance().destroy(task2.getId());
    }

    @Test
    public void testExecute_invalidTaskParameter_unsuccessful() throws Exception {
        Command.setTaskDb(taskDb);

        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task");
        task.save();

        when(taskDb.getById(anyInt())).thenReturn(task);
        TaskDb.getInstance().destroy(task.getId());

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("")
            .build();


        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task 1");
        task.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("Never gonna give")
            .build();

        command.execute();

        task = TaskDb.getInstance().getById(task.getId());
        assertEquals("Never gonna give", task.getDescription());

        command.undo();

        task = TaskDb.getInstance().getById(task.getId());
        assertEquals("Task 1", task.getDescription());

        TaskDb.getInstance().destroy(task.getId());
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        Command.setTaskDb(taskDb);
        doThrow(InvalidIdException.class).when(taskDb).getById(anyInt());

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(666)
            .setDescription("Never gonna give")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/RescheduleTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.RescheduleTaskCommand;
import jfdi.logic.events.RescheduleTaskFailedEvent;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class RescheduleTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        assertEquals(1, command.getScreenId());
        assertEquals(startDateTime, command.getStartDateTime());
        assertEquals(endDateTime, command.getEndDateTime());
        assertNull(command.getOldStartDateTime());
        assertNull(command.getOldEndDateTime());
        assertTrue(command.isShiftedDateSpecified());
        assertTrue(command.isShiftedTimeSpecified());
    }

    @Test
    public void testExecute_nonShifting_successful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(task).setStartDateTime(any(LocalDateTime.class));
        verify(task).setEndDateTime(any(LocalDateTime.class));
        verify(task).save();
    }

    @Test
    public void testExecute_shiftingFloatingTask_successful() throws Exception {
        TaskAttributes floating = mock(TaskAttributes.class);
        when(floating.getStartDateTime()).thenReturn(null);
        when(floating.getEndDateTime()).thenReturn(null);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(floating);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(floating).setStartDateTime(shiftedDateTime);
        verify(floating).setEndDateTime(null);
        verify(floating).save();
    }

    @Test
    public void testExecute_shiftingPointTask_successful() throws Exception {
        TaskAttributes point = mock(TaskAttributes.class);
        when(point.getStartDateTime()).thenReturn(LocalDateTime.now());
        when(point.getEndDateTime()).thenReturn(null);
        when(ui.getTaskId(2)).thenReturn(2);
        when(taskDb.getById(2)).thenReturn(point);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(2)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(point).setStartDateTime(shiftedDateTime);
        verify(point).setEndDateTime(null);
        verify(point).save();
    }

    @Test
    public void testExecute_shiftingDeadlineTask_successful() throws Exception {
        TaskAttributes deadline = mock(TaskAttributes.class);
        when(deadline.getStartDateTime()).thenReturn(null);
        when(deadline.getEndDateTime()).thenReturn(LocalDateTime.now());
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.getById(3)).thenReturn(deadline);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(3)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(deadline).setStartDateTime(null);
        verify(deadline).setEndDateTime(shiftedDateTime);
        verify(deadline).save();
    }

    @Test
    public void testExecute_shiftingEventTask_bothDateTimeSpecified_successful() throws Exception {
        LocalDateTime oldStartDateTime = LocalDateTime.now();
        LocalDateTime oldEndDateTime = oldStartDateTime.plusHours(1);

        TaskAttributes event = mock(TaskAttributes.class);
        when(event.getStartDateTime()).thenReturn(oldStartDateTime);
        when(event.getEndDateTime()).thenReturn(oldEndDateTime);
        when(ui.getTaskId(4)).thenReturn(4);
        when(taskDb.getById(4)).thenReturn(event);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(4)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(event).setStartDateTime(shiftedDateTime);
        verify(event).setEndDateTime(shiftedDateTime.plusHours(1));
        verify(event).save();
    }

    @Test
    public void testExecute_shiftingEventTask_onlyDateSpecified_successful() throws Exception {
        LocalDateTime oldStartDateTime = LocalDateTime.now();
        LocalDateTime oldEndDateTime = oldStartDateTime.plusHours(1);

        TaskAttributes event = mock(TaskAttributes.class);
        when(event.getStartDateTime()).thenReturn(oldStartDateTime);
        when(event.getEndDateTime()).thenReturn(oldEndDateTime);
        when(ui.getTaskId(4)).thenReturn(4);
        when(taskDb.getById(4)).thenReturn(event);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(4)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(false)
            .build();

        command.execute();

        verify(event).setStartDateTime(oldStartDateTime.plusDays(1));
        verify(event).setEndDateTime(oldEndDateTime.plusDays(1));
        verify(event).save();
    }

    @Test
    public void testExecute_shiftingEventTask_onlyTimeSpecified_successful() throws Exception {
        LocalDateTime oldStartDateTime = LocalDateTime.now();
        LocalDateTime oldEndDateTime = oldStartDateTime.plusHours(1);

        TaskAttributes event = mock(TaskAttributes.class);
        when(event.getStartDateTime()).thenReturn(oldStartDateTime);
        when(event.getEndDateTime()).thenReturn(oldEndDateTime);
        when(ui.getTaskId(4)).thenReturn(4);
        when(taskDb.getById(4)).thenReturn(event);

        LocalDateTime shiftedDateTime = oldStartDateTime.plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(4)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(false)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(event).setStartDateTime(oldStartDateTime);
        verify(event).setEndDateTime(oldEndDateTime);
        verify(event).save();
    }

    @Test
    public void testExecute_invalidId_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        doThrow(InvalidIdException.class).when(taskDb).getById(1);

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(eventBus).post(any(RescheduleTaskFailedEvent.class));
    }

    @Test
    public void testExecute_invalidTaskParameter_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(InvalidTaskParametersException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testExecute_noAttributesChanged_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(NoAttributesChangedException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(task).setStartDateTime(any(LocalDateTime.class));
        verify(task).setEndDateTime(any(LocalDateTime.class));
        verify(task).save();
        verify(eventBus).post(any(RescheduleTaskFailedEvent.class));
    }

    @Test
    public void testExecute_duplicateTask_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(DuplicateTaskException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(task).setStartDateTime(any(LocalDateTime.class));
        verify(task).setEndDateTime(any(LocalDateTime.class));
        verify(task).save();
        verify(eventBus).post(any(RescheduleTaskFailedEvent.class));
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);

        LocalDateTime oldStartDateTime = LocalDateTime.now().minusDays(2);
        LocalDateTime oldEndDateTime = LocalDateTime.now().minusDays(2);
        when(task.getStartDateTime()).thenReturn(oldStartDateTime);
        when(task.getEndDateTime()).thenReturn(oldEndDateTime);

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        assertEquals(oldStartDateTime, command.getOldStartDateTime());
        assertEquals(oldEndDateTime, command.getOldEndDateTime());
        verify(task).setStartDateTime(startDateTime);
        verify(task).setEndDateTime(endDateTime);
        verify(task).save();

        command.undo();

        verify(task).setStartDateTime(oldStartDateTime);
        verify(task).setEndDateTime(oldEndDateTime);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(InvalidTaskParametersException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/SearchCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.SearchCommand;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class SearchCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<String> keywords = new ArrayList<>();
        keywords.add("you");
        keywords.add("up");

        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .addKeyword("gonna")
            .addKeyword("give")
            .addKeywords(keywords)
            .build();

        assertTrue(command.getKeywords().contains("never"));
        assertTrue(command.getKeywords().contains("gonna"));
        assertTrue(command.getKeywords().contains("give"));
        assertTrue(command.getKeywords().contains("you"));
        assertTrue(command.getKeywords().contains("up"));
        assertNull(command.getResults());
    }

    @Before
    public void setUp() throws Exception {
        super.setUp();

        TaskAttributes neverGonnaGiveYouUp = new TaskAttributes();
        neverGonnaGiveYouUp.setDescription("Never gonna give you up");
        TaskAttributes never = new TaskAttributes();
        never.setDescription("never");
        TaskAttributes gonna = new TaskAttributes();
        gonna.setDescription("gonna");
        TaskAttributes give = new TaskAttributes();
        give.setDescription("give");
        TaskAttributes you = new TaskAttributes();
        you.setDescription("you");
        TaskAttributes up = new TaskAttributes();
        up.setDescription("up");

        ArrayList<TaskAttributes> tasks = new ArrayList<>();
        tasks.add(neverGonnaGiveYouUp);
        tasks.add(never);
        tasks.add(gonna);
        tasks.add(give);
        tasks.add(you);
        tasks.add(up);

        when(taskDb.getAll()).thenReturn(tasks);
    }

    @Test
    public void testExecute_singleKeyword() throws Exception {
        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .build();

        command.execute();

        assertEquals(2, command.getResults().size());
    }

    @Test
    public void testExecute_multipleKeyword() throws Exception {
        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .addKeyword("gonna")
            .addKeyword("give")
            .addKeyword("you")
            .addKeyword("up")
            .build();

        command.execute();

        assertEquals(6, command.getResults().size());
        assertEquals("Never gonna give you up", command.getResults().get(0).getDescription());
    }

    @Test
    public void testUndo() throws Exception {
        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .addKeyword("gonna")
            .addKeyword("give")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/UnaliasCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.UnaliasCommand;
import jfdi.logic.events.UnaliasFailedEvent;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.InvalidAliasException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UnaliasCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        assertEquals("ls", command.getAlias());
    }

    @Test
    public void testExecute_successful() throws Exception {
        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        command.execute();

        verify(aliasDb).destroy("ls");
        verify(aliasDb).getAll();
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        doThrow(InvalidAliasException.class).when(aliasDb).destroy("ls");

        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        command.execute();

        verify(aliasDb).destroy("ls");
        verifyNoMoreInteractions(aliasDb);
        verifyZeroInteractions(parser);
        verify(eventBus).post(any(UnaliasFailedEvent.class));
    }

    @Test
    public void testUndo_successful() throws Exception {
        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        command.undo();

        verify(aliasDb).undestroy("ls");
        verify(aliasDb).getAll();
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        doThrow(InvalidAliasException.class).when(aliasDb).undestroy("ls");

        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/UndoCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AliasCommand;
import jfdi.logic.commands.UndoCommand;
import jfdi.logic.events.UndoFailedEvent;
import jfdi.logic.interfaces.Command;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UndoCommandTest extends CommonCommandTest {

    @Test
    public void testExecute_successful() throws Exception {
        AliasCommand aliasCommand = mock(AliasCommand.class);
        doCallRealMethod().when(aliasCommand).pushToUndoStack();

        aliasCommand.pushToUndoStack();

        UndoCommand undoCommand = new UndoCommand.Builder().build();

        undoCommand.execute();

        verify(aliasCommand).undo();
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        Command.getUndoStack().clear();

        UndoCommand undoCommand = new UndoCommand.Builder().build();

        undoCommand.execute();

        verify(eventBus).post(any(UndoFailedEvent.class));
    }

    @Test
    public void undo() throws Exception {
        UndoCommand command = new UndoCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/UnmarkTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.UnmarkTaskCommand;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UnmarkTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<Integer> ids = new ArrayList<>();
        ids.add(2);
        ids.add(3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskIds(ids)
            .build();

        assertEquals(3, command.getScreenIds().size());
        assertTrue(command.getScreenIds().contains(1));
        assertTrue(command.getScreenIds().contains(2));
        assertTrue(command.getScreenIds().contains(3));
        assertNull(command.getUnmarkedIds());
    }

    @Test
    public void testExecute_markSingle_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        assertEquals(1, command.getUnmarkedIds().size());
    }

    @Test
    public void testExecute_markSingle_alreadyCompleted_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(NoAttributesChangedException.class).when(taskDb).markAsIncomplete(anyInt());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();
        assertEquals(0, command.getUnmarkedIds().size());
    }

    @Test
    public void testExecute_markMultiple_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertEquals(3, command.getUnmarkedIds().size());
    }

    @Test
    public void testExecute_shouldNotHappen_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsIncomplete(anyInt());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(false);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(3)).thenReturn(task3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertNull(command.getUnmarkedIds());
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();
        command.undo();

        verify(taskDb).markAsComplete(1);
        verify(taskDb).markAsComplete(2);
        verify(taskDb).markAsComplete(3);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsComplete(anyInt());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/UseDirectoryCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.UseDirectoryCommand;
import jfdi.logic.events.UseDirectoryDoneEvent;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UseDirectoryCommandTest extends CommonCommandTest {

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        assertEquals("./new", command.getNewDirectory());
        assertNull(command.getOldDirectory());
    }

    @Test
    public void testExecute_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(mainStorage).use("./new");
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_filesReplaced_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).use("./new");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus, times(2)).post(any());
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_invalidPath_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).use("./new");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus).post(any(UseDirectoryDoneEvent.class));
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testUndo_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).use("./old");
    }

    @Test
    public void testUndo_filesReplaced_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).use("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).use("./old");
        verify(eventBus, times(2)).post(any());
    }

    @Test
    public void testUndo_invalidPath_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).use("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();

        verify(mainStorage).use("./old");
    }

}
```
###### ./src/test/java/jfdi/test/logic/commands/WildcardCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.WildcardCommand;
import jfdi.logic.events.NoSurpriseEvent;
import jfdi.logic.events.SurpriseEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class WildcardCommandTest extends CommonCommandTest {

    @Test
    public void testExecute_successful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Never gonna give you up");
        task.setCompleted(false);

        ArrayList<TaskAttributes> tasks = new ArrayList<>();
        tasks.add(task);

        when(taskDb.getAll()).thenReturn(tasks);

        WildcardCommand command = new WildcardCommand.Builder().build();

        assertNull(command.getLucky());

        command.execute();

        assertEquals(task, command.getLucky());
        verify(eventBus).post(any(SurpriseEvent.class));
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        when(taskDb.getAll()).thenReturn(new ArrayList<>());

        WildcardCommand command = new WildcardCommand.Builder().build();

        assertNull(command.getLucky());

        command.execute();

        assertNull(command.getLucky());
        verify(eventBus).post(any(NoSurpriseEvent.class));
    }

    @Test
    public void undo() throws Exception {
        WildcardCommand command = new WildcardCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### ./src/test/java/jfdi/test/logic/ControlCenterTest.java
``` java

package jfdi.test.logic;

import com.google.common.eventbus.EventBus;
import jfdi.logic.ControlCenter;
import jfdi.logic.commands.ExitCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.InitializationFailedEvent;
import jfdi.logic.events.InvalidCommandEvent;
import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertSame;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ControlCenterTest {

    @Mock
    private InputParser parser;

    @Mock
    private MainStorage mainStorage;

    @Mock
    private TaskDb taskDb;

    @Mock
    private AliasDb aliasDb;

    @Mock
    private EventBus eventBus;

    @Mock
    private ListCommand ls;

    @Mock
    private ExitCommand exit;

    @Mock
    private InvalidCommand lol;

    @Before
    public void setUp() throws Exception {
        ControlCenter.setParser(parser);
        ControlCenter.setMainStorage(mainStorage);
        ControlCenter.setTaskDb(taskDb);
        ControlCenter.setAliasDb(aliasDb);
        ControlCenter.setEventBus(eventBus);

        when(parser.getAllCommandRegexes()).thenReturn(InputParser.getInstance().getAllCommandRegexes());
    }

    @After
    public void tearDown() throws Exception {
        ControlCenter.setParser(InputParser.getInstance());
        ControlCenter.setMainStorage(MainStorage.getInstance());
        ControlCenter.setTaskDb(TaskDb.getInstance());
        ControlCenter.setAliasDb(AliasDb.getInstance());
        ControlCenter.setEventBus(UI.getEventBus());
        ControlCenter.removeInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(ControlCenter.getInstance(), ControlCenter.getInstance());
    }

    @Test
    public void testHandleInput_successful() throws Exception {
        when(parser.parse("list")).thenReturn(ls);
        when(parser.parse("lol")).thenReturn(lol);
        when(parser.parse("exit")).thenReturn(exit);

        ControlCenter cc = ControlCenter.getInstance();

        cc.handleInput("list");
        cc.handleInput("lol");
        cc.handleInput("exit");

        verify(ls).execute();
        verify(lol).execute();
        verify(exit).execute();
    }

    @Test
    public void testHandleInput_invalidInput() throws Exception {
        doThrow(InvalidInputException.class).when(parser).parse(anyString());

        EventBus eventBus = mock(EventBus.class);
        Command.setEventBus(eventBus);

        ControlCenter cc = ControlCenter.getInstance();

        cc.handleInput("never gonna give");

        verify(eventBus).post(any(InvalidCommandEvent.class));
        Command.setEventBus(UI.getEventBus());
    }

    @Test
    public void testInitStorage_filesReplaced() throws Exception {
        doThrow(FilesReplacedException.class).when(mainStorage).initialize();

        ControlCenter.getInstance();
        verify(eventBus).post(any(FilesReplacedEvent.class));
    }

    @Test
    public void testInitStorage_invalidPath() throws Exception {
        doThrow(InvalidFilePathException.class).when(mainStorage).initialize();

        ControlCenter.getInstance();
        verify(eventBus).post(any(InitializationFailedEvent.class));
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/AddTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertSame;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AddTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        AddTaskDoneEvent event = new AddTaskDoneEvent(task);
        assertSame(task, event.getTask());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/AddTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AddTaskFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AddTaskFailedEventTest {

    @Test
    public void getError() throws Exception {
        AddTaskFailedEvent event = new AddTaskFailedEvent(AddTaskFailedEvent.Error.EMPTY_DESCRIPTION);
        assertEquals(AddTaskFailedEvent.Error.EMPTY_DESCRIPTION, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (AddTaskFailedEvent.Error error : AddTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            AddTaskFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### ./src/test/java/jfdi/test/logic/events/AliasDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AliasDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AliasDoneEventTest {

    private static final String COMMAND = "delete";
    private static final String ALIAS = "del";

    @Test
    public void getCommand() throws Exception {
        AliasDoneEvent event = new AliasDoneEvent(COMMAND, ALIAS);
        assertEquals(COMMAND, event.getCommand());
    }

    @Test
    public void getAlias() throws Exception {
        AliasDoneEvent event = new AliasDoneEvent(COMMAND, ALIAS);
        assertEquals(ALIAS, event.getAlias());
    }
}
```
###### ./src/test/java/jfdi/test/logic/events/AliasFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AliasFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AliasFailedEventTest {

    private AliasFailedEvent event = new AliasFailedEvent("list", "ls", AliasFailedEvent.Error.DUPLICATED_ALIAS);

    @Test
    public void getCommand() throws Exception {
        assertEquals("list", event.getCommand());
    }

    @Test
    public void getAlias() throws Exception {
        assertEquals("ls", event.getAlias());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(AliasFailedEvent.Error.DUPLICATED_ALIAS, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (AliasFailedEvent.Error error : AliasFailedEvent.Error.values()) {
            // Force a full coverage on enums
            AliasFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### ./src/test/java/jfdi/test/logic/events/CommandUndoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.logic.events.CommandUndoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEventTest {

    @Test
    public void getCommandType() throws Exception {
        CommandUndoneEvent event = new CommandUndoneEvent(DeleteTaskCommand.class);
        assertEquals(DeleteTaskCommand.class, event.getCommandType());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/DeleteTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DeleteTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> deletedIds;

    @Mock
    private ArrayList<TaskAttributes> deletedTasks;

    @Test
    public void getDeletedIds() throws Exception {
        DeleteTaskDoneEvent event = new DeleteTaskDoneEvent(deletedIds, deletedTasks);
        assertEquals(deletedIds, event.getDeletedIds());
    }

    @Test
    public void getDeletedTasks() throws Exception {
        DeleteTaskDoneEvent event = new DeleteTaskDoneEvent(deletedIds, deletedTasks);
        assertEquals(deletedTasks, event.getDeletedTasks());
    }
}
```
###### ./src/test/java/jfdi/test/logic/events/DeleteTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.DeleteTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> invalidIds;

    @Test
    public void getInvalidIds() throws Exception {
        DeleteTaskFailedEvent event = new DeleteTaskFailedEvent(invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        DeleteTaskFailedEvent event1 = new DeleteTaskFailedEvent(invalidIds);
        assertEquals(DeleteTaskFailedEvent.Error.NON_EXISTENT_ID, event1.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (DeleteTaskFailedEvent.Error error : DeleteTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            DeleteTaskFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### ./src/test/java/jfdi/test/logic/events/ExitCalledEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.ExitCalledEvent;
import org.junit.Test;

import static org.junit.Assert.assertNotNull;

/**
 * @author Xinan
 */
public class ExitCalledEventTest {

    @Test
    public void nothingToTest() {
        ExitCalledEvent event = new ExitCalledEvent();
        assertNotNull(event);
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/FilesReplacedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.storage.exceptions.FilePathPair;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEventTest {

    @Mock
    private ArrayList<FilePathPair> filePathPairs;

    private String newDirectory = ".";

    @Test
    public void getFilePathPairs() throws Exception {
        FilesReplacedEvent event1 = new FilesReplacedEvent(filePathPairs);
        assertEquals(filePathPairs, event1.getFilePathPairs());

        FilesReplacedEvent event2 = new FilesReplacedEvent(newDirectory, filePathPairs);
        assertEquals(filePathPairs, event2.getFilePathPairs());
    }

    @Test
    public void getNewDirectory() throws Exception {
        FilesReplacedEvent event1 = new FilesReplacedEvent(filePathPairs);
        assertNull(event1.getNewDirectory());

        FilesReplacedEvent event2 = new FilesReplacedEvent(newDirectory, filePathPairs);
        assertEquals(newDirectory, event2.getNewDirectory());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/HelpRequestedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.HelpRequestedEvent;
import org.junit.Test;

import static org.junit.Assert.assertNotNull;

/**
 * @author Liu Xinan
 */
public class HelpRequestedEventTest {

    @Test
    public void nothingToTest() {
        HelpRequestedEvent event = new HelpRequestedEvent();
        assertNotNull(event);
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/InitializationFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.InitializationFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEventTest {

    private InitializationFailedEvent.Error error = InitializationFailedEvent.Error.INVALID_PATH;
    private String path = "!@#!@#!@#";

    @Test
    public void getError() throws Exception {
        InitializationFailedEvent event = new InitializationFailedEvent(error, path);
        assertEquals(error, event.getError());
    }

    @Test
    public void getPath() throws Exception {
        InitializationFailedEvent event = new InitializationFailedEvent(error, path);
        assertEquals(path, event.getPath());
    }

    @Test
    public void testEnum() throws Exception {
        for (InitializationFailedEvent.Error error : InitializationFailedEvent.Error.values()) {
            // Force a full coverage on enums
            InitializationFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### ./src/test/java/jfdi/test/logic/events/InvalidCommandEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.parser.Constants;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEventTest {

    @Test
    public void getInputString() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("WTF", null);
        assertEquals("WTF", event.getInputString());
    }

    @Test
    public void getCommandType() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("undo redo", Constants.CommandType.UNDO);
        assertEquals(Constants.CommandType.UNDO, event.getCommandType());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/ListDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.ListDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class ListDoneEventTest {

    @Mock
    private ListCommand.ListType listType;

    @Mock
    private ArrayList<TaskAttributes> items;

    @Test
    public void getItems() throws Exception {
        ListDoneEvent event = new ListDoneEvent(listType, items);
        assertEquals(items, event.getItems());
    }

    @Test
    public void getListType() throws Exception {
        ListDoneEvent event = new ListDoneEvent(listType, items);
        assertEquals(listType, event.getListType());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/MarkTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<TaskAttributes> markedTasks;

    @Test
    public void getScreenIds() throws Exception {
        MarkTaskDoneEvent event = new MarkTaskDoneEvent(screenIds, markedTasks);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getMarkedTasks() throws Exception {
        MarkTaskDoneEvent event = new MarkTaskDoneEvent(screenIds, markedTasks);
        assertEquals(markedTasks, event.getMarkedTasks());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/MarkTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MarkTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<Integer> invalidIds;

    private MarkTaskFailedEvent.Error error = MarkTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenIds() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getInvalidIds() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (MarkTaskFailedEvent.Error error : MarkTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            MarkTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/MoveDirectoryDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MoveDirectoryDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEventTest {

    private String newDirectory = ".";

    @Test
    public void getNewDirectory() throws Exception {
        MoveDirectoryDoneEvent event = new MoveDirectoryDoneEvent(newDirectory);
        assertEquals(newDirectory, event.getNewDirectory());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/MoveDirectoryFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MoveDirectoryFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEventTest {

    private String newDirectory = "!@#!@#$@#$";
    private MoveDirectoryFailedEvent.Error error = MoveDirectoryFailedEvent.Error.INVALID_PATH;

    @Test
    public void getNewDirectory() throws Exception {
        MoveDirectoryFailedEvent event = new MoveDirectoryFailedEvent(newDirectory, error);
        assertEquals(newDirectory, event.getNewDirectory());
    }

    @Test
    public void getError() throws Exception {
        MoveDirectoryFailedEvent event = new MoveDirectoryFailedEvent(newDirectory, error);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (MoveDirectoryFailedEvent.Error error : MoveDirectoryFailedEvent.Error.values()) {
            // Force a full coverage on enums
            MoveDirectoryFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/NoSurpriseEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.NoSurpriseEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEventTest {

    @Test
    public void getError() throws Exception {
        NoSurpriseEvent event = new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS);
        assertEquals(NoSurpriseEvent.Error.NO_TASKS, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (NoSurpriseEvent.Error error : NoSurpriseEvent.Error.values()) {
            // Force a full coverage on enums
            NoSurpriseEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/RenameTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        RenameTaskDoneEvent event = new RenameTaskDoneEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/RenameTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RenameTaskFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEventTest {

    private int screenId = 666;
    private String description = "Task 666";
    private RenameTaskFailedEvent event = new RenameTaskFailedEvent(screenId, description,
        RenameTaskFailedEvent.Error.DUPLICATED_TASK);

    @Test
    public void getScreenId() throws Exception {
        assertEquals(screenId, event.getScreenId());
    }

    @Test
    public void getDescription() throws Exception {
        assertEquals(description, event.getDescription());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(RenameTaskFailedEvent.Error.DUPLICATED_TASK, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (RenameTaskFailedEvent.Error error : RenameTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            RenameTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/RescheduleTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        RescheduleTaskDoneEvent event = new RescheduleTaskDoneEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/RescheduleTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RescheduleTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.time.LocalDateTime;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEventTest {

    @Mock
    private LocalDateTime startDateTime;

    @Mock
    private LocalDateTime endDateTime;

    private int screenId = 666;
    private RescheduleTaskFailedEvent.Error error = RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenId() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(screenId, event.getScreenId());
    }

    @Test
    public void getStartDateTime() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(startDateTime, event.getStartDateTime());
    }

    @Test
    public void getEndDateTime() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(endDateTime, event.getEndDateTime());
    }

    @Test
    public void getError() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (RescheduleTaskFailedEvent.Error error : RescheduleTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            RescheduleTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/SearchDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;
import java.util.HashSet;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class SearchDoneEventTest {

    @Mock
    private HashSet<String> keywords;

    @Mock
    private ArrayList<TaskAttributes> results;

    @Test
    public void getResults() throws Exception {
        SearchDoneEvent event = new SearchDoneEvent(results, keywords);
        assertEquals(results, event.getResults());
    }

    @Test
    public void getKeywords() throws Exception {
        SearchDoneEvent event = new SearchDoneEvent(results, keywords);
        assertEquals(keywords, event.getKeywords());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/ShowDirectoryEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.ShowDirectoryEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEventTest {

    private String pwd = "/home/ubuntu/jfdi";

    @Test
    public void getPwd() throws Exception {
        ShowDirectoryEvent event = new ShowDirectoryEvent(pwd);
        assertEquals(pwd, event.getPwd());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/SurpriseEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.SurpriseEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class SurpriseEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        SurpriseEvent event = new SurpriseEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UnaliasDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnaliasDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEventTest {

    private String alias = "alias";

    @Test
    public void getAlias() throws Exception {
        UnaliasDoneEvent event = new UnaliasDoneEvent(alias);
        assertEquals(alias, event.getAlias());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UnaliasFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnaliasFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEventTest {

    private String alias = "alias";
    private UnaliasFailedEvent.Error error = UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS;
    private UnaliasFailedEvent event = new UnaliasFailedEvent(alias, error);

    @Test
    public void getAlias() throws Exception {
        assertEquals(alias, event.getAlias());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UnaliasFailedEvent.Error error : UnaliasFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UnaliasFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UndoFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UndoFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UndoFailedEventTest {

    @Test
    public void getError() throws Exception {
        UndoFailedEvent event = new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO);
        assertEquals(UndoFailedEvent.Error.NONTHING_TO_UNDO, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UndoFailedEvent.Error error : UndoFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UndoFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UnmarkTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<TaskAttributes> unmarkedTasks;

    @Test
    public void getScreenIds() throws Exception {
        UnmarkTaskDoneEvent event = new UnmarkTaskDoneEvent(screenIds, unmarkedTasks);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getUnmarkedTasks() throws Exception {
        UnmarkTaskDoneEvent event = new UnmarkTaskDoneEvent(screenIds, unmarkedTasks);
        assertEquals(unmarkedTasks, event.getUnmarkedTasks());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UnmarkTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnmarkTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<Integer> invalidIds;

    private UnmarkTaskFailedEvent.Error error = UnmarkTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenIds() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getInvalidIds() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UnmarkTaskFailedEvent.Error error : UnmarkTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UnmarkTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UseDirectoryDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UseDirectoryDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEventTest {

    private String newDirectory = ".";

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryDoneEvent event = new UseDirectoryDoneEvent(newDirectory);
        assertEquals(newDirectory, event.getNewDirectory());
    }

}
```
###### ./src/test/java/jfdi/test/logic/events/UseDirectoryFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UseDirectoryFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEventTest {

    private String newDirectory = "!@#$!@#$";
    private UseDirectoryFailedEvent.Error error = UseDirectoryFailedEvent.Error.INVALID_PATH;

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryFailedEvent event = new UseDirectoryFailedEvent(newDirectory, error);
        assertEquals(newDirectory, event.getNewDirectory());
    }

    @Test
    public void getError() throws Exception {
        UseDirectoryFailedEvent event = new UseDirectoryFailedEvent(newDirectory, error);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UseDirectoryFailedEvent.Error error : UseDirectoryFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UseDirectoryFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### ./src/test/java/jfdi/test/logic/interfaces/CommandTest.java
``` java

package jfdi.test.logic.interfaces;

import com.google.common.eventbus.EventBus;
import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertSame;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class CommandTest {

    private Command command;

    @Mock
    private UI ui;

    @Mock
    private MainStorage mainStorage;

    @Mock
    private TaskDb taskDb;

    @Mock
    private AliasDb aliasDb;

    @Mock
    private InputParser parser;

    @Mock
    private EventBus eventBus;

    @Before
    public void setUp() throws Exception {
        command = Mockito.mock(Command.class, Mockito.CALLS_REAL_METHODS);
        Command.setUi(ui);
        Command.setMainStorage(mainStorage);
        Command.setTaskDb(taskDb);
        Command.setAliasDb(aliasDb);
        Command.setParser(parser);
        Command.setEventBus(eventBus);
    }

    @After
    public void tearDown() throws Exception {
        Command.setUi(UI.getInstance());
        Command.setMainStorage(MainStorage.getInstance());
        Command.setTaskDb(TaskDb.getInstance());
        Command.setAliasDb(AliasDb.getInstance());
        Command.setParser(InputParser.getInstance());
        Command.setEventBus(UI.getEventBus());
    }

    @Test
    public void pushToUndoStack() throws Exception {
        int currentSize = Command.getUndoStack().size();

        command.pushToUndoStack();
        assertEquals(currentSize + 1, Command.getUndoStack().size());

        command.pushToUndoStack();
        assertEquals(currentSize + 2, Command.getUndoStack().size());

        command.pushToUndoStack();
        assertEquals(currentSize + 3, Command.getUndoStack().size());
    }

    @Test
    public void clearUndoStack() throws Exception {
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();

        Command.clearUndoStack();

        assertEquals(0, Command.getUndoStack().size());
    }

    @Test
    public void getParser() throws Exception {
        assertSame(parser, Command.getParser());
    }

    @Test
    public void getMainStorage() throws Exception {
        assertSame(mainStorage, Command.getMainStorage());
    }

    @Test
    public void getTaskDb() throws Exception {
        assertSame(taskDb, Command.getTaskDb());
    }

    @Test
    public void getAliasDb() throws Exception {
        assertSame(aliasDb, Command.getAliasDb());
    }

    @Test
    public void getUI()  throws Exception {
        assertSame(ui, Command.getUI());
    }

    @Test
    public void getEventBus() throws Exception {
        assertSame(eventBus, Command.getEventBus());
    }

}
```
