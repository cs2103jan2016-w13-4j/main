# A0130195M
###### /config/checkstyle/checkstyle.xml
``` xml
<!DOCTYPE module PUBLIC
  "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
  "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">

<module name="Checker">
  <property name="localeCountry" value="SG" />
  <property name="localeLanguage" value="en" />
  <property name="charset" value="UTF-8" />

  <module name="FileTabCharacter">
    <property name="eachLine" value="true" />
  </module>
  <module name="NewlineAtEndOfFile" />
  <module name="RegexpSingleline">
    <property name="format" value="\s+$"/>
    <property name="message" value="Trailing whitespace"/>
  </module>
  <module name="RegexpSingleline">
    <property name="format" value="/\*\* +\p{javaLowerCase}"/>
    <property name="fileExtensions" value="java"/>
    <property name="message" value="First sentence in a comment should start with a capital letter"/>
  </module>
  <module name="RegexpMultiline">
    <property name="format" value="/\*\*\W+\* +\p{javaLowerCase}"/>
    <property name="fileExtensions" value="java"/>
    <property name="message" value="First sentence in a comment should start with a capital letter"/>
  </module>

  <module name="TreeWalker">
    <module name="OuterTypeFilename" />
    <module name="IllegalTokenText">
      <property name="tokens" value="STRING_LITERAL, CHAR_LITERAL" />
      <property name="format" value="\\u00(08|09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)" />
      <property name="message" value="Avoid using corresponding octal or unicode escape for characters that have special escape sequences." />
    </module>
    <module name="AvoidEscapedUnicodeCharacters">
      <property name="allowEscapesForControlCharacters" value="true" />
      <property name="allowByTailComment" value="true" />
      <property name="allowNonPrintableEscapes" value="true" />
    </module>
    <module name="EmptyLineSeparator">
      <property name="allowNoEmptyLineBetweenFields" value="true" />
    </module>
    <module name="LineLength">
      <property name="max" value="120" />
      <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://" />
    </module>
    <module name="NoLineWrap" />
    <module name="OneTopLevelClass" />
    <module name="DeclarationOrder" />
    <module name="OverloadMethodsDeclarationOrder" />
    <module name="AvoidNestedBlocks" />
    <module name="NeedBraces" />
    <module name="LeftCurly" />
    <module name="RightCurly" />
    <module name="DefaultComesLast" />
    <module name="EmptyStatement" />
    <module name="EqualsHashCode" />
    <module name="EmptyBlock">
      <property name="option" value="TEXT" />
      <property name="tokens" value="LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH" />
    </module>
    <module name="EmptyCatchBlock">
      <property name="commentFormat" value="Excepted" />
    </module>
    <module name="Indentation" />
    <module name="OneStatementPerLine" />
    <module name="OperatorWrap">
      <property name="tokens" value="BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR" />
    </module>
    <module name="SeparatorWrap">
      <property name="tokens" value="DOT" />
      <property name="option" value="nl" />
    </module>
    <module name="SeparatorWrap">
      <property name="tokens" value="COMMA" />
      <property name="option" value="eol" />
    </module>
    <module name="NoWhitespaceAfter" />
    <module name="NoWhitespaceBefore" />
    <module name="ParenPad" />
    <module name="WhitespaceAfter" />
    <module name="WhitespaceAround">
      <property name="allowEmptyConstructors" value="true" />
      <property name="allowEmptyMethods" value="true" />
      <property name="allowEmptyTypes" value="true" />
      <property name="allowEmptyLoops" value="true" />
      <message key="ws.notFollowed"
               value="WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement." />
      <message key="ws.notPreceded"
               value="WhitespaceAround: ''{0}'' is not preceded with whitespace." />
    </module>
    <module name="GenericWhitespace">
      <message key="ws.followed"
               value="GenericWhitespace ''{0}'' is followed by whitespace." />
      <message key="ws.preceded"
               value="GenericWhitespace ''{0}'' is preceded with whitespace." />
      <message key="ws.illegalFollow"
               value="GenericWhitespace ''{0}'' should followed by whitespace." />
      <message key="ws.notPreceded"
               value="GenericWhitespace ''{0}'' is not preceded with whitespace." />
    </module>
    <module name="MethodParamPad" />
    <module name="MultipleVariableDeclarations" />
    <module name="ArrayTypeStyle" />
    <module name="FallThrough" />
    <module name="MissingSwitchDefault" />
    <module name="NoClone" />
    <module name="SimplifyBooleanExpression" />
    <module name="SimplifyBooleanReturn" />
    <module name="StringLiteralEquality" />
    <module name="UnnecessaryParentheses" />
    <module name="RedundantImport" />
    <module name="UnusedImports" />
    <module name="TodoComment">
      <property name="format" value="(TODO)|(FIXME)" />
      <property name="severity" value="warning" />
    </module>
    <module name="RedundantModifier" />
    <module name="AnnotationLocation">
      <property name="tokens" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF" />
    </module>
    <module name="AnnotationLocation">
      <property name="tokens" value="VARIABLE_DEF" />
      <property name="allowSamelineMultipleAnnotations" value="true" />
    </module>
    <module name="ModifierOrder" />
    <module name="UpperEll" />
    <module name="PackageName">
      <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$" />
      <message key="name.invalidPattern"
               value="Package name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="TypeName">
      <message key="name.invalidPattern"
               value="Type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="MemberName">
      <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$" />
      <message key="name.invalidPattern"
               value="Member name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="LocalVariableName">
      <property name="tokens" value="VARIABLE_DEF" />
      <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$" />
      <property name="allowOneCharVarInForLoop" value="true" />
      <message key="name.invalidPattern"
               value="Local variable name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="ClassTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Class type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="MethodTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Method type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="InterfaceTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Interface type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="AbbreviationAsWordInName">
      <property name="ignoreFinal" value="false" />
      <property name="allowedAbbreviationLength" value="3" />
    </module>
    <module name="ConstantName">
      <property name="applyToProtected" value="false" />
      <property name="applyToPrivate" value="false" />
      <property name="applyToPackage" value="false" />
    </module>
    <module name="NoFinalizer" />
    <module name="SingleLineJavadoc" />
    <module name="JavadocParagraph" />
    <module name="AtclauseOrder">
      <property name="tagOrder" value="@param, @return, @throws, @deprecated" />
      <property name="target" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF" />
    </module>
    <module name="JavadocTagContinuationIndentation" />
    <module name="NonEmptyAtclauseDescription" />
  </module>
</module>
```
###### /src/main/java/jfdi/logic/commands/AddTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.logic.events.AddTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.LocalDateTime;
import java.util.Optional;

/**
 * @author Liu Xinan
 */
public class AddTaskCommand extends Command {

    private String description;
    private Optional<LocalDateTime> startDateTime;
    private Optional<LocalDateTime> endDateTime;
    private int id = -1;

    private AddTaskCommand(Builder builder) {
        this.description = builder.description;
        this.startDateTime = Optional.ofNullable(builder.startDateTime);
        this.endDateTime = Optional.ofNullable(builder.endDateTime);
    }

    public String getDescription() {
        return description;
    }

    public Optional<LocalDateTime> getStartDateTime() {
        return startDateTime;
    }

    public Optional<LocalDateTime> getEndDateTime() {
        return endDateTime;
    }

    public int getId() {
        return id;
    }

    public static class Builder {

        String description;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
            this.startDateTime = startDateTime;
            return this;
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
            this.endDateTime = endDateTime;
            return this;
        }

        public AddTaskCommand build() {
            return new AddTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        TaskAttributes task = new TaskAttributes();
        task.setDescription(description);
        startDateTime.ifPresent(task::setStartDateTime);
        endDateTime.ifPresent(task::setEndDateTime);
        try {
            task.save();
            this.id = task.getId();

            pushToUndoStack();
            eventBus.post(new AddTaskDoneEvent(task));
            logger.info("Task added: #" + this.id + task.getDescription());
        } catch (InvalidTaskParametersException e) {
            eventBus.post(new AddTaskFailedEvent(
                AddTaskFailedEvent.Error.EMPTY_DESCRIPTION));
            logger.warning("Adding task failed: Description empty");
        } catch (DuplicateTaskException e) {
            eventBus.post(new AddTaskFailedEvent(
                AddTaskFailedEvent.Error.DUPLICATED_TASK));
            logger.warning("Adding task failed: Duplicate task");
        } catch (NoAttributesChangedException | InvalidIdException e) {
            // Should not happen for creating tasks
            assert false;
        }
    }

    @Override
    public void undo() {
        try {
            taskDb.destroy(id);

            logger.info("Undo add task: Deleting task #" + id);
        } catch (InvalidIdException e) {
            // Should not happen for creating tasks
            assert false;
        }
    }

}
```
###### /src/main/java/jfdi/logic/commands/AliasCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.AliasDoneEvent;
import jfdi.logic.events.AliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

/**
 * @author Liu Xinan
 */
public class AliasCommand extends Command {

    private String command;
    private String alias;
    private boolean isValid;

    private AliasCommand(Builder builder) {
        this.command = builder.command;
        this.alias = builder.alias;
        this.isValid = builder.isValid;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

    public boolean isValid() {
        return isValid;
    }

    public static class Builder {

        String command;
        String alias;
        boolean isValid;

        public Builder setCommand(String command) {
            this.command = command;
            return this;
        }

        public Builder setAlias(String alias) {
            this.alias = alias;
            return this;
        }

        public Builder setIsValid(boolean isValid) {
            this.isValid = isValid;
            return this;
        }

        public AliasCommand build() {
            return new AliasCommand(this);
        }

    }

    @Override
    public void execute() {
        AliasAttributes newAlias = new AliasAttributes(alias, command);
        try {
            newAlias.save();
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new AliasDoneEvent(command, alias));
            logger.info("Aliased " + command + " to " + alias);
        } catch (InvalidAliasParametersException e) {
            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.INVALID_PARAMETERS));
            logger.warning("Alias not saved: Invalid alias");
        } catch (DuplicateAliasException e) {
            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.DUPLICATED_ALIAS));
            logger.warning("Alias not saved: Duplicate alias");
        }
    }

    @Override
    public void undo() {
        try {
            aliasDb.destroy(alias);
            parser.setAliases(aliasDb.getAll());

            logger.info("Undo add alias: Deleting alias:" + alias);
        } catch (InvalidAliasException e) {
            // Should not happen
            assert false;
        }
    }

}
```
###### /src/main/java/jfdi/logic/commands/DeleteTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.logic.events.DeleteTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class DeleteTaskCommand extends Command {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> deletedTasks;

    private DeleteTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getDeletedTasks() {
        return deletedTasks;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public DeleteTaskCommand build() {
            return new DeleteTaskCommand(this);
        }

    }



    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            deletedTasks = new ArrayList<>();
            taskIds.forEach(id -> {
                try {
                    deletedTasks.add(taskDb.getById(id));
                    taskDb.destroy(id);
                    logger.info("Task deleted: #" + id);
                } catch (InvalidIdException e) {
                    // Should not happen
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new DeleteTaskDoneEvent(screenIds, deletedTasks));
        } else {
            eventBus.post(new DeleteTaskFailedEvent(invalidIds));
        }
    }

    @Override
    public void undo() {
        deletedTasks.stream().forEach(task -> {
            try {
                taskDb.undestroy(task.getId());

                logger.info("Undo deleting task: #" + task.getId());
            } catch (InvalidIdException | DuplicateTaskException e) {
                assert false;
            }
        });
    }
}
```
###### /src/main/java/jfdi/logic/commands/DirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ShowDirectoryEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class DirectoryCommand extends Command {

    private DirectoryCommand(Builder builder) {}

    public static class Builder {

        public DirectoryCommand build() {
            return new DirectoryCommand(this);
        }

    }

    @Override
    public void execute() {
        String pwd = mainStorage.getCurrentDirectory();
        eventBus.post(new ShowDirectoryEvent(pwd));
        logger.info("Showing current directory: " + pwd);
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/ExitCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ExitCalledEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class ExitCommand extends Command {

    private ExitCommand(Builder builder) {}

    public static class Builder {

        public ExitCommand build() {
            return new ExitCommand(this);
        }

    }

    @Override
    public void execute() {
        // Nothing needs to be done.
        // Post an event to notify UI to exit.
        eventBus.post(new ExitCalledEvent());

        logger.info("Exiting the program...");
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/HelpCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.HelpRequestedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class HelpCommand extends Command {

    private HelpCommand(Builder builder) {}

    public static class Builder {

        public HelpCommand build() {
            return new HelpCommand(this);
        }

    }

    @Override
    public void execute() {
        eventBus.post(new HelpRequestedEvent());

        logger.info("User requested for help");
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/InvalidCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
public class InvalidCommand extends Command {

    private String inputString;
    private CommandType commandType;

    private InvalidCommand(Builder builder) {
        this.inputString = builder.inputString;
        this.commandType = builder.commandType;
    }

    public static class Builder {

        String inputString = "";
        CommandType commandType = null;

        public Builder setInputString(String inputString) {
            this.inputString = inputString;
            return this;
        }

        public Builder setCommandType(CommandType commandType) {
            this.commandType = commandType;
            return this;
        }

        public InvalidCommand build() {
            return new InvalidCommand(this);
        }

    }

    public String getInputString() {
        return inputString;
    }

    public CommandType getCommandType() {
        return commandType;
    }

    @Override
    public void execute() {
        // Invalid command always fail.
        eventBus.post(new InvalidCommandEvent(inputString, commandType));

        logger.warning("Invalid command received: " + inputString);
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/ListCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ListDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ListCommand extends Command {

    public enum ListType {
        ALL,
        COMPLETED,
        INCOMPLETE,
        OVERDUE,
        UPCOMING
    }

    private ListType listType;

    private ListCommand(Builder builder) {
        this.listType = builder.listType;
    }

    public static class Builder {

        ListType listType;

        public Builder setListType(ListType listType) {
            this.listType = listType;
            return this;
        }

        public ListCommand build() {
            return new ListCommand(this);
        }
    }

    public ListType getListType() {
        return this.listType;
    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> tasks = taskDb.getAll().stream()
            .collect(Collectors.toCollection(ArrayList::new));

        switch (listType) {
            case COMPLETED:
                tasks = tasks.stream()
                    .filter(TaskAttributes::isCompleted)
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of completed tasks requested.");
                break;
            case INCOMPLETE:
                tasks = tasks.stream()
                    .filter(task -> !task.isCompleted())
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of incomplete tasks requested.");
                break;
            case OVERDUE:
                tasks = taskDb.getOverdue().stream()
                    .sorted()
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of overdue tasks requested.");
                break;
            case UPCOMING:
                tasks = taskDb.getUpcoming().stream()
                    .sorted()
                    .collect(Collectors.toCollection(ArrayList::new));
                logger.info("List of upcoming tasks requested.");
                break;
            default:
                break;
        }

        eventBus.post(new ListDoneEvent(listType, tasks));
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/MarkTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.logic.events.MarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class MarkTaskCommand extends Command {

    private static final Logger logger = JfdiLogger.getLogger();

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> markedIds;

    private MarkTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getMarkedIds() {
        return markedIds;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addTaskId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addTaskIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public MarkTaskCommand build() {
            return new MarkTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            ArrayList<TaskAttributes> markedTasks = new ArrayList<>();
            markedIds = new ArrayList<>();
            taskIds.stream().forEach(id -> {
                try {
                    markedTasks.add(taskDb.getById(id));
                    taskDb.markAsComplete(id);
                    markedIds.add(id);

                    logger.info("Task marked: #" + id);
                } catch (NoAttributesChangedException e) {
                    logger.warning("Task " + id + " is already completed.");
                } catch (InvalidIdException e) {
                    // Should not happen!
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new MarkTaskDoneEvent(screenIds, markedTasks));
        } else {
            eventBus.post(new MarkTaskFailedEvent(screenIds, invalidIds));

            logger.warning("Some invalid id(s) supplied. Not marking any tasks as done.");
        }
    }

    @Override
    public void undo() {
        markedIds.stream().forEach(id -> {
            try {
                taskDb.markAsIncomplete(id);

                logger.info("Undo marking task: #" + id);
            } catch (NoAttributesChangedException | InvalidIdException e) {
                assert false;
            }
        });
    }
}
```
###### /src/main/java/jfdi/logic/commands/MoveDirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.MoveDirectoryDoneEvent;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryCommand extends Command {

    private String oldDirectory;
    private String newDirectory;

    private MoveDirectoryCommand(Builder builder) {
        this.newDirectory = builder.newDirectory;
    }

    public static class Builder {

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
            this.newDirectory = newDirectory;
            return this;
        }

        public MoveDirectoryCommand build() {
            return new MoveDirectoryCommand(this);
        }

    }

    public String getOldDirectory() {
        return oldDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    @Override
    public void execute() {
        try {
            oldDirectory = mainStorage.getCurrentDirectory();

            mainStorage.changeDirectory(newDirectory);

            pushToUndoStack();
            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));

            logger.info("Program data moved to " + newDirectory);
        } catch (FilesReplacedException e) {
            pushToUndoStack();
            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));
            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));

            logger.warning("Destination files replaced.");
        } catch (InvalidFilePathException e) {
            eventBus.post(new MoveDirectoryFailedEvent(newDirectory, MoveDirectoryFailedEvent.Error.INVALID_PATH));

            logger.warning("Invalid file path specified.");
        }
    }

    @Override
    public void undo() {
        try {
            mainStorage.changeDirectory(oldDirectory);

            logger.info("Undo moving directory: Moving back to " + oldDirectory);
        } catch (InvalidFilePathException e) {
            assert false;
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));
        }
    }
}
```
###### /src/main/java/jfdi/logic/commands/RenameTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.logic.events.RenameTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

/**
 * @author Liu Xinan
 */
public class RenameTaskCommand extends Command {

    private int screenId;
    private String description;
    private String oldDescription;

    private RenameTaskCommand(Builder builder) {
        this.screenId = builder.screenId;
        this.description = builder.description;
    }

    public int getScreenId() {
        return screenId;
    }

    public String getDescription() {
        return description;
    }

    public String getOldDescription() {
        return oldDescription;
    }

    public static class Builder {

        int screenId = -1;
        String description;

        public Builder setId(int screenId) {
            this.screenId = screenId;
            return this;
        }

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public RenameTaskCommand build() {
            return new RenameTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);
            oldDescription = task.getDescription();

            task.setDescription(description);
            task.save();

            pushToUndoStack();
            eventBus.post(new RenameTaskDoneEvent(task));

            logger.info("Task #" + taskId + " renamed to " + description);
        } catch (InvalidIdException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description,
                          RenameTaskFailedEvent.Error.NON_EXISTENT_ID));

            logger.warning("Rename task failed: Invalid task id");
        } catch (NoAttributesChangedException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description,
                          RenameTaskFailedEvent.Error.NO_CHANGES));

            logger.warning("Rename task failed: Task description not changed");
        } catch (DuplicateTaskException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description,
                          RenameTaskFailedEvent.Error.DUPLICATED_TASK));

            logger.warning("Rename task failed: Duplicate task");
        } catch (InvalidTaskParametersException e) {
            // Should not happen
            assert false;
        }
    }

    @Override
    public void undo() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            task.setDescription(oldDescription);
            task.save();

            logger.info("Undo renaming: renaming task #" + taskId + " back to " + oldDescription);
        } catch (InvalidIdException | NoAttributesChangedException | InvalidTaskParametersException
               | DuplicateTaskException e) {
            assert false;
        }
    }
}
```
###### /src/main/java/jfdi/logic/commands/RescheduleTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.logic.events.RescheduleTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.Duration;
import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskCommand extends Command {

    private int screenId;
    private boolean isShiftedDateSpecified;
    private boolean isShiftedTimeSpecified;
    private LocalDateTime shiftedDateTime;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime oldStartDateTime;
    private LocalDateTime oldEndDateTime;

    private RescheduleTaskCommand(Builder builder) {
        this.screenId = builder.screenId;
        this.isShiftedDateSpecified = builder.isShiftedDateSpecified;
        this.isShiftedTimeSpecified = builder.isShiftedTimeSpecified;
        this.shiftedDateTime = builder.shiftedDateTime;
        this.startDateTime = builder.startDateTime;
        this.endDateTime = builder.endDateTime;
    }

    public int getScreenId() {
        return screenId;
    }

    public boolean isShiftedDateSpecified() {
        return isShiftedDateSpecified;
    }

    public boolean isShiftedTimeSpecified() {
        return isShiftedTimeSpecified;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public LocalDateTime getOldStartDateTime() {
        return oldStartDateTime;
    }

    public LocalDateTime getOldEndDateTime() {
        return oldEndDateTime;
    }

    public static class Builder {

        int screenId;
        boolean isShiftedDateSpecified = false;
        boolean isShiftedTimeSpecified = false;
        LocalDateTime shiftedDateTime;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setId(int screenId) {
            this.screenId = screenId;
            return this;
        }

        public Builder setShiftedDateSpecified(boolean isShiftedDateSpecified) {
            this.isShiftedDateSpecified = isShiftedDateSpecified;
            return this;
        }

        public Builder setShiftedTimeSpecified(boolean isShiftedTimeSpecified) {
            this.isShiftedTimeSpecified = isShiftedTimeSpecified;
            return this;
        }

        public Builder setShiftedDateTime(LocalDateTime shiftedDateTime) {
            this.shiftedDateTime = shiftedDateTime;
            return this;
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
            this.startDateTime = startDateTime;
            return this;
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
            this.endDateTime = endDateTime;
            return this;
        }

        public RescheduleTaskCommand build() {
            return new RescheduleTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            oldStartDateTime = task.getStartDateTime();
            oldEndDateTime = task.getEndDateTime();

            if (shiftedDateTime != null) {
                shiftStartAndEndDateTimes(task);
            }

            task.setStartDateTime(startDateTime);
            task.setEndDateTime(endDateTime);
            task.save();

            pushToUndoStack();
            eventBus.post(new RescheduleTaskDoneEvent(task));

            logger.info("Task #" + taskId + " rescheduled.");
        } catch (InvalidIdException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID));

            logger.warning("Reschedule failed: Invalid id");
        } catch (InvalidTaskParametersException e) {
            // Should not happen
            assert false;
        } catch (NoAttributesChangedException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.NO_CHANGES));

            logger.warning("Reschedule failed: Date time not changed");
        } catch (DuplicateTaskException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.DUPLICATED_TASK));

            logger.warning("Reschedule failed: Duplicate task");
        }
    }

    @Override
    public void undo() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            task.setStartDateTime(oldStartDateTime);
            task.setEndDateTime(oldEndDateTime);
            task.save();

            logger.info("Undo rescheduling: rescheduled back #" + taskId);
        } catch (InvalidIdException | InvalidTaskParametersException | NoAttributesChangedException
            | DuplicateTaskException e) {
            assert false;
        }
    }

    private void shiftStartAndEndDateTimes(TaskAttributes task) {
        LocalDateTime taskStart = task.getStartDateTime();
        LocalDateTime taskEnd = task.getEndDateTime();

        if (taskStart == null && taskEnd == null) {
            startDateTime = shiftedDateTime;
            endDateTime = null;

            logger.info("Shifting a floating task to a point task.");
        } else if (taskStart != null && taskEnd == null) {
            startDateTime = getShiftedDateTime(task.getStartDateTime());
            endDateTime = null;

            logger.info("Shifting point task.");
        } else if (taskStart == null) {
            startDateTime = null;
            endDateTime = getShiftedDateTime(task.getEndDateTime());

            logger.info("Shifting deadline task.");
        } else {
            Duration eventDuration = Duration.between(taskStart, taskEnd);
            startDateTime = getShiftedDateTime(task.getStartDateTime());
            endDateTime = startDateTime.plus(eventDuration);

            logger.info("Shifting event task.");
        }
    }

    public LocalDateTime getShiftedDateTime() {
        return shiftedDateTime;
    }

    private LocalDateTime getShiftedDateTime(LocalDateTime dateTime) {
        // At least one of them must be true
        if (!isShiftedTimeSpecified) {
            return shiftDate(dateTime);
        } else if (!isShiftedDateSpecified) {
            return shiftTime(dateTime);
        } else {
            return shiftedDateTime;
        }
    }

    private LocalDateTime shiftTime(LocalDateTime originalDateTime) {
        return LocalDateTime.of(originalDateTime.toLocalDate(), shiftedDateTime.toLocalTime());
    }

    private LocalDateTime shiftDate(LocalDateTime originalDateTime) {
        return LocalDateTime.of(shiftedDateTime.toLocalDate(), originalDateTime.toLocalTime());
    }

}
```
###### /src/main/java/jfdi/logic/commands/SearchCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import opennlp.tools.stemmer.PorterStemmer;
import org.apache.commons.lang3.tuple.ImmutableTriple;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class SearchCommand extends Command {

    private static final PorterStemmer stemmer = new PorterStemmer();

    private HashSet<String> keywords;

    private ArrayList<TaskAttributes> results;

    private SearchCommand(Builder builder) {
        this.keywords = builder.keywords;
    }

    public HashSet<String> getKeywords() {
        return keywords;
    }

    public ArrayList<TaskAttributes> getResults() {
        return results;
    }

    public static class Builder {

        HashSet<String> keywords = new HashSet<>();

        public Builder addKeyword(String keyword) {
            this.keywords.add(keyword);
            return this;
        }

        public Builder addKeywords(Collection<String> keywords) {
            this.keywords.addAll(keywords);
            return this;
        }

        public SearchCommand build() {
            return new SearchCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> fullMatches = taskDb.getAll().stream()
                .map(this::constructFullMatchCancidate)
                .filter(this::isValidCandidate)
                .sorted(this::candidateCompare)
                .map(ImmutableTriple::getRight)
                .collect(Collectors.toCollection(ArrayList::new));

        results = new ArrayList<>(fullMatches);

        results.addAll(taskDb.getAll().stream()
                .map(this::constructStemMatchCandidate)
                .filter(this::isValidCandidate)
                .sorted(this::candidateCompare)
                .map(ImmutableTriple::getRight)
                .filter(task -> !fullMatches.contains(task))
                .collect(Collectors.toCollection(ArrayList::new)));

        logger.info(String.format("Search completed. %d results found.", results.size()));

        eventBus.post(new SearchDoneEvent(results, keywords));
    }

    private ImmutableTriple<Long, Integer, TaskAttributes> constructFullMatchCancidate(TaskAttributes task) {
        String[] parts = task.getDescription().split("\\s+");
        int wordCount = parts.length;

        long rank = Arrays.stream(parts)
            .filter(this::isFullMatch)
            .count();

        return new ImmutableTriple<Long, Integer, TaskAttributes>(rank, wordCount, task);
    }

    private ImmutableTriple<Long, Integer, TaskAttributes> constructStemMatchCandidate(TaskAttributes task) {
        String[] parts = task.getDescription().split("\\s+");
        int wordCount = parts.length;

        long rank = Arrays.stream(parts)
                .map(stemmer::stem)
                .filter(this::isStemMatch)
                .count();

        return new ImmutableTriple<Long, Integer, TaskAttributes>(rank, wordCount, task);
    }

    private boolean isValidCandidate(ImmutableTriple<Long, Integer, TaskAttributes> candidate) {
        return candidate.getLeft() > 0;
    }

    private boolean isFullMatch(String word) {
        return keywords.stream()
                .reduce(
                    false,
                    (isMatched, keyword) -> isMatched || word.equalsIgnoreCase(keyword),
                    (isPreviouslyMatched, isNowMatched) -> isPreviouslyMatched || isNowMatched
                );
    }

    private boolean isStemMatch(String word) {
        return keywords.stream()
                .map(stemmer::stem)
                .reduce(
                        false,
                        (isMatched, keyword) -> isMatched || word.equalsIgnoreCase(keyword),
                        (isPreviouslyMatched, isNowMatched) -> isPreviouslyMatched || isNowMatched
                );
    }

    private int candidateCompare(ImmutableTriple<Long, Integer, TaskAttributes> left,
                                 ImmutableTriple<Long, Integer, TaskAttributes> right) {

        if (left.getLeft() > right.getLeft()) {
            return -1;
        } else if (left.getLeft() < right.getLeft()) {
            return 1;
        } else {
            return left.getMiddle() - right.getMiddle();
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/UnaliasCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.UnaliasDoneEvent;
import jfdi.logic.events.UnaliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.InvalidAliasException;

/**
 * @author Liu Xinan
 */
public class UnaliasCommand extends Command {

    private String alias;

    private UnaliasCommand(Builder builder) {
        this.alias = builder.alias;
    }

    public String getAlias() {
        return alias;
    }

    public static class Builder {

        String alias;

        public Builder setAlias(String alias) {
            this.alias = alias;
            return this;
        }

        public UnaliasCommand build() {
            return new UnaliasCommand(this);
        }

    }

    @Override
    public void execute() {
        try {
            aliasDb.destroy(alias);
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new UnaliasDoneEvent(alias));

            logger.info("Alias deleted: " + alias);
        } catch (InvalidAliasException e) {
            eventBus.post(new UnaliasFailedEvent(alias, UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS));

            logger.info("Delete alias failed: Invalid alias");
        }
    }

    @Override
    public void undo() {
        try {
            aliasDb.undestroy(alias);
            parser.setAliases(aliasDb.getAll());

            logger.info("Undo deleting alias: Adding alias " + alias + " back");
        } catch (InvalidAliasException e) {
            assert false;
        }
    }

}
```
###### /src/main/java/jfdi/logic/commands/UndoCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.CommandUndoneEvent;
import jfdi.logic.events.UndoFailedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class UndoCommand extends Command {

    private UndoCommand(Builder builder) {}

    public static class Builder {

        public UndoCommand build() {
            return new UndoCommand(this);
        }

    }

    @Override
    public void execute() {
        if (!undoStack.empty()) {
            Command lastUndoableCommand = undoStack.pop();
            lastUndoableCommand.undo();

            eventBus.post(new CommandUndoneEvent(lastUndoableCommand.getClass()));

            logger.info("Undoing previous " + lastUndoableCommand.getClass());
        } else {
            eventBus.post(new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO));

            logger.warning("Undo failed: Nothing to undo");
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/UnmarkTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.logic.events.UnmarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskCommand extends Command {

    private static final Logger LOGGER = JfdiLogger.getLogger();

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> unmarkedIds;

    private UnmarkTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getUnmarkedIds() {
        return unmarkedIds;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addTaskId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addTaskIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public UnmarkTaskCommand build() {
            return new UnmarkTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            ArrayList<TaskAttributes> unmarkedTasks = new ArrayList<>();
            unmarkedIds = new ArrayList<>();
            taskIds.stream().forEach(id -> {
                try {
                    unmarkedTasks.add(taskDb.getById(id));
                    taskDb.markAsIncomplete(id);

                    unmarkedIds.add(id);

                    logger.info("Task unmarked: #" + id);
                } catch (NoAttributesChangedException e) {
                    LOGGER.warning("Task " + id + " was not completed.");
                } catch (InvalidIdException e) {
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new UnmarkTaskDoneEvent(screenIds, unmarkedTasks));
        } else {
            eventBus.post(new UnmarkTaskFailedEvent(screenIds, invalidIds));

            logger.warning("Some invalid id(s) supplied. Not marking any tasks as incomplete.");
        }
    }

    @Override
    public void undo() {
        unmarkedIds.stream().forEach(id -> {
            try {
                taskDb.markAsComplete(id);

                logger.info("Undo unmarking task: #" + id);
            } catch (NoAttributesChangedException | InvalidIdException e) {
                assert false;
            }
        });
    }

}
```
###### /src/main/java/jfdi/logic/commands/UseDirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.UseDirectoryDoneEvent;
import jfdi.logic.events.UseDirectoryFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
public class UseDirectoryCommand extends Command {

    private String oldDirectory;
    private String newDirectory;

    private UseDirectoryCommand(Builder builder) {
        this.newDirectory = builder.newDirectory;
    }

    public static class Builder {

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
            this.newDirectory = newDirectory;
            return this;
        }

        public UseDirectoryCommand build() {
            return new UseDirectoryCommand(this);
        }

    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public String getOldDirectory() {
        return oldDirectory;
    }

    @Override
    public void execute() {
        try {
            oldDirectory = mainStorage.getCurrentDirectory();

            mainStorage.use(newDirectory);
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new UseDirectoryDoneEvent(newDirectory));

            logger.info("Direcroty switched to: " + newDirectory);
        } catch (FilesReplacedException e) {
            eventBus.post(new UseDirectoryDoneEvent(newDirectory));
            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));

            logger.warning("Destination files replaced.");
        } catch (InvalidFilePathException e) {
            eventBus.post(new UseDirectoryFailedEvent(newDirectory, UseDirectoryFailedEvent.Error.INVALID_PATH));

            logger.warning("Invalid file path specified.");
        }
    }

    @Override
    public void undo() {
        try {
            mainStorage.use(oldDirectory);
            parser.setAliases(aliasDb.getAll());

            logger.info("Undo switching directory: Switching back to " + oldDirectory);
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            assert false;
        }
    }
}
```
###### /src/main/java/jfdi/logic/commands/WildcardCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.NoSurpriseEvent;
import jfdi.logic.events.SurpriseEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class WildcardCommand extends Command {

    private TaskAttributes lucky;

    private WildcardCommand(Builder builder) {}

    public static class Builder {

        public WildcardCommand build() {
            return new WildcardCommand(this);
        }

    }

    public TaskAttributes getLucky() {
        return lucky;
    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> incompleteTasks = taskDb.getAll().stream()
                .filter(task -> !task.isCompleted() && task.getStartDateTime() == null)
                .collect(Collectors.toCollection(ArrayList::new));

        SecureRandom random = new SecureRandom();

        if (!incompleteTasks.isEmpty()) {
            lucky = incompleteTasks.get(random.nextInt(incompleteTasks.size()));
            eventBus.post(new SurpriseEvent(lucky));

            logger.info("Lucky task chosen: " + lucky.getDescription());
        } else {
            eventBus.post(new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS));

            logger.warning("No surprise for everybody!");
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/ControlCenter.java
``` java

package jfdi.logic;

import com.google.common.eventbus.EventBus;
import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.InitializationFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.logic.interfaces.ILogic;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.*;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import jfdi.ui.UI;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ControlCenter implements ILogic {

    private static final Logger logger = JfdiLogger.getLogger();

    private static ControlCenter ourInstance;

    private static EventBus eventBus = UI.getEventBus();

    private static MainStorage mainStorage = MainStorage.getInstance();
    private static TaskDb taskDb = TaskDb.getInstance();
    private static AliasDb aliasDb = AliasDb.getInstance();

    private static InputParser parser = InputParser.getInstance();

    private ControlCenter() {
        initStorage();
        initParser();
    }

    public static ControlCenter getInstance() {
        if (ourInstance == null) {
            ourInstance = new ControlCenter();
        }
        return ourInstance;
    }

    @Override
    public void handleInput(String input) {
        logger.info("Handling input: " + input);

        Command command;
        try {
            command = parser.parse(input);
        } catch (InvalidInputException e) {
            command = new InvalidCommand.Builder().build();
        }
        command.execute();
    }

    @Override
    public TreeSet<String> getKeywords() {
        TreeSet<String> keywords = Arrays.stream(InputParser.getInstance()
            .getAllCommandRegexes()
            .replaceAll("\\W+", " ").split("\\s+"))
            .filter(part -> part.length() > 1)
            .collect(Collectors.toCollection(TreeSet::new));

        AliasDb.getInstance()
            .getAll().stream()
            .map(AliasAttributes::getAlias)
            .forEach(keywords::add);

        return keywords;
    }

    @Override
    public ArrayList<TaskAttributes> getIncompleteTasks() {
        return taskDb.getAll().stream()
            .filter(task -> !task.isCompleted())
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getCompletedTasks() {
        return taskDb.getAll().stream()
            .filter(TaskAttributes::isCompleted)
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getAllTasks() {
        return taskDb.getAll().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getUpcomingTasks() {
        return taskDb.getUpcoming().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getOverdueTasks() {
        return taskDb.getOverdue().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    private void initStorage() {
        logger.info("Initializing Storage...");

        // Set a list of permitted commands that can be aliased
        AliasAttributes.setCommandRegex(parser.getAllCommandRegexes());
        try {
            mainStorage.initialize();
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            eventBus.post(new InitializationFailedEvent(InitializationFailedEvent.Error.INVALID_PATH,
                e.getPath()));
        }

        logger.info("Storage initialized successfully!");
    }

    private void initParser() {
        logger.info("Initializing Parser...");

        parser.setAliases(aliasDb.getAll());

        logger.info("Parser initialized successfully!");
    }

    //================================================================
    // Methods for testing.
    //================================================================

    public static void removeInstance() {
        ourInstance = null;
    }

    public static void setParser(InputParser parser) {
        ControlCenter.parser = parser;
    }

    public static void setMainStorage(MainStorage mainStorage) {
        ControlCenter.mainStorage = mainStorage;
    }

    public static void setTaskDb(TaskDb taskDb) {
        ControlCenter.taskDb = taskDb;
    }

    public static void setAliasDb(AliasDb aliasDb) {
        ControlCenter.aliasDb = aliasDb;
    }

    public static void setEventBus(EventBus eventBus) {
        ControlCenter.eventBus = eventBus;
    }

}
```
###### /src/main/java/jfdi/logic/events/AddTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class AddTaskDoneEvent {

    private TaskAttributes task;

    public AddTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }
}
```
###### /src/main/java/jfdi/logic/events/AddTaskFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AddTaskFailedEvent {

    public enum Error {
        EMPTY_DESCRIPTION, DUPLICATED_TASK
    }

    private Error error;

    public AddTaskFailedEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/AliasDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasDoneEvent {

    private String command;
    private String alias;

    public AliasDoneEvent(String command, String alias) {
        this.command = command;
        this.alias = alias;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### /src/main/java/jfdi/logic/events/AliasFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasFailedEvent {

    public enum Error {
        INVALID_PARAMETERS, DUPLICATED_ALIAS, UNKNOWN
    }

    private String command;
    private String alias;
    private Error error;

    public AliasFailedEvent(String command, String alias, Error error) {
        this.command = command;
        this.alias = alias;
        this.error = error;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/CommandRedoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandRedoneEvent {

    private Class<? extends Command> commandType;

    public CommandRedoneEvent(Class<? extends Command> commandType) {
        this.commandType = commandType;
    }

    public Class<? extends Command> getCommandType() {
        return commandType;
    }

}
```
###### /src/main/java/jfdi/logic/events/CommandUndoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEvent {

    private Class<? extends Command> commandType;

    public CommandUndoneEvent(Class<? extends Command> commandType) {
        this.commandType = commandType;
    }

    public Class<? extends Command> getCommandType() {
        return commandType;
    }

}
```
###### /src/main/java/jfdi/logic/events/DeleteTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskDoneEvent {

    private ArrayList<Integer> deletedIds;
    private ArrayList<TaskAttributes> deletedTasks;

    public DeleteTaskDoneEvent(ArrayList<Integer> deletedIds, ArrayList<TaskAttributes> deletedTasks) {
        this.deletedIds = deletedIds;
        this.deletedTasks = deletedTasks;
    }

    public ArrayList<Integer> getDeletedIds() {
        return deletedIds;
    }

    public ArrayList<TaskAttributes> getDeletedTasks() {
        return deletedTasks;
    }
}
```
###### /src/main/java/jfdi/logic/events/DeleteTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> invalidIds;
    private Error error;

    public DeleteTaskFailedEvent(ArrayList<Integer> invalidIds) {
        error = Error.NON_EXISTENT_ID;
        this.invalidIds = invalidIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/ExitCalledEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ExitCalledEvent {}
```
###### /src/main/java/jfdi/logic/events/FilesReplacedEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.exceptions.FilePathPair;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEvent {

    private String newDirectory = null;
    private ArrayList<FilePathPair> filePathPairs;

    public FilesReplacedEvent(ArrayList<FilePathPair> filePathPairs) {
        this.filePathPairs = filePathPairs;
    }

    public FilesReplacedEvent(String newDirectory, ArrayList<FilePathPair> filePathPairs) {
        this.newDirectory = newDirectory;
        this.filePathPairs = filePathPairs;
    }

    public ArrayList<FilePathPair> getFilePathPairs() {
        return filePathPairs;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### /src/main/java/jfdi/logic/events/HelpRequestedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class HelpRequestedEvent {}
```
###### /src/main/java/jfdi/logic/events/InitializationFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private Error error;
    private String path;

    public InitializationFailedEvent(Error error, String path) {
        this.error = error;
        this.path = path;
    }

    public Error getError() {
        return error;
    }

    public String getPath() {
        return path;
    }

}
```
###### /src/main/java/jfdi/logic/events/InvalidCommandEvent.java
``` java

package jfdi.logic.events;

import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEvent {

    private String inputString;
    private CommandType commandType;

    public InvalidCommandEvent(String inputString, CommandType commandType) {
        this.inputString = inputString;
        this.commandType = commandType;
    }

    public String getInputString() {
        return inputString;
    }

    public CommandType getCommandType() {
        return commandType;
    }

}
```
###### /src/main/java/jfdi/logic/events/ListDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.commands.ListCommand.ListType;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class ListDoneEvent {

    private ListType listType;
    private ArrayList<TaskAttributes> items;

    public ListDoneEvent(ListType listType, ArrayList<TaskAttributes> items) {
        this.listType = listType;
        this.items = items;
    }

    public ArrayList<TaskAttributes> getItems() {
        return items;
    }

    public ListType getListType() {
        return listType;
    }
}
```
###### /src/main/java/jfdi/logic/events/MarkTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEvent {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> markedTasks;

    public MarkTaskDoneEvent(ArrayList<Integer> screenIds, ArrayList<TaskAttributes> markedTasks) {
        this.screenIds = screenIds;
        this.markedTasks = markedTasks;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getMarkedTasks() {
        return markedTasks;
    }

}
```
###### /src/main/java/jfdi/logic/events/MarkTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> invalidIds;
    private Error error;

    public MarkTaskFailedEvent(ArrayList<Integer> screenIds, ArrayList<Integer> invalidIds) {
        this.screenIds = screenIds;
        this.invalidIds = invalidIds;
        this.error = Error.NON_EXISTENT_ID;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/MoveDirectoryDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEvent {

    private String newDirectory;

    public MoveDirectoryDoneEvent(String newDirectory) {
        this.newDirectory = newDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### /src/main/java/jfdi/logic/events/MoveDirectoryFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private String newDirectory;
    private Error error;

    public MoveDirectoryFailedEvent(String newDirectory, Error error) {
        this.newDirectory = newDirectory;
        this.error = error;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/NoSurpriseEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEvent {

    public enum Error {
        NO_TASKS, UNKNOWN
    }

    private Error error;

    public NoSurpriseEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/RenameTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEvent {

    private TaskAttributes task;

    public RenameTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }
}
```
###### /src/main/java/jfdi/logic/events/RenameTaskFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID,
        DUPLICATED_TASK,
        NO_CHANGES,
        UNKNOWN
    }

    private int screenId;
    private String description;
    private Error error;

    public RenameTaskFailedEvent(int screenId, String description, Error error) {
        this.screenId = screenId;
        this.description = description;
        this.error = error;
    }

    public int getScreenId() {
        return screenId;
    }

    public String getDescription() {
        return description;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/RescheduleTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEvent {

    private TaskAttributes task;

    public RescheduleTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }

}
```
###### /src/main/java/jfdi/logic/events/RescheduleTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID,
        DUPLICATED_TASK,
        NO_CHANGES,
        UNKNOWN
    }

    private int screenId;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private Error error;

    public RescheduleTaskFailedEvent(int screenId, LocalDateTime startDateTime, LocalDateTime endDateTime,
                                     Error error) {
        this.screenId = screenId;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.error = error;
    }

    public int getScreenId() {
        return screenId;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/SearchDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.HashSet;

/**
 * @author Liu Xinan
 */
public class SearchDoneEvent {

    private ArrayList<TaskAttributes> results;
    private HashSet<String> keywords;

    public SearchDoneEvent(ArrayList<TaskAttributes> results, HashSet<String> keywords) {
        this.results = results;
        this.keywords = keywords;
    }

    public ArrayList<TaskAttributes> getResults() {
        return results;
    }

    public HashSet<String> getKeywords() {
        return keywords;
    }

}
```
###### /src/main/java/jfdi/logic/events/ShowDirectoryEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEvent {

    private String pwd;

    public ShowDirectoryEvent(String pwd) {
        this.pwd = pwd;
    }

    public String getPwd() {
        return pwd;
    }

}
```
###### /src/main/java/jfdi/logic/events/SurpriseEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class SurpriseEvent {

    private TaskAttributes task;

    public SurpriseEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnaliasDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEvent {

    private String alias;

    public UnaliasDoneEvent(String alias) {
        this.alias = alias;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnaliasFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEvent {

    public enum Error {
        NON_EXISTENT_ALIAS,
        UNKNOWN
    }

    private String alias;
    private Error error;

    public UnaliasFailedEvent(String alias, Error error) {
        this.alias = alias;
        this.error = error;
    }

    public String getAlias() {
        return alias;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/UndoFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UndoFailedEvent {

    public enum Error {
        NONTHING_TO_UNDO, UNKNOWN
    }

    private Error error;

    public UndoFailedEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnmarkTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEvent {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> unmarkedTasks;

    public UnmarkTaskDoneEvent(ArrayList<Integer> screenIds, ArrayList<TaskAttributes> unmarkedTasks) {
        this.screenIds = screenIds;
        this.unmarkedTasks = unmarkedTasks;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getUnmarkedTasks() {
        return unmarkedTasks;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnmarkTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> invalidIds;
    private Error error;

    public UnmarkTaskFailedEvent(ArrayList<Integer> screenIds, ArrayList<Integer> invalidIds) {
        this.screenIds = screenIds;
        this.invalidIds = invalidIds;
        this.error = Error.NON_EXISTENT_ID;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/UseDirectoryDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEvent {

    private String newDirectory;

    public UseDirectoryDoneEvent(String newDirectory) {
        this.newDirectory = newDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### /src/main/java/jfdi/logic/events/UseDirectoryFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private String newDirectory;
    private Error error;

    public UseDirectoryFailedEvent(String newDirectory, Error error) {
        this.newDirectory = newDirectory;
        this.error = error;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/interfaces/Command.java
``` java

package jfdi.logic.interfaces;

import java.util.Stack;
import java.util.logging.Logger;

import com.google.common.eventbus.EventBus;

import jfdi.common.utilities.JfdiLogger;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;

/**
 * @author Liu Xinan
 */
public abstract class Command {

    protected static final Logger logger = JfdiLogger.getLogger();
    protected static EventBus eventBus = UI.getEventBus();

    protected static final Stack<Command> undoStack = new Stack<>();

    protected static UI ui = UI.getInstance();
    protected static InputParser parser = InputParser.getInstance();
    protected static MainStorage mainStorage = MainStorage.getInstance();
    protected static TaskDb taskDb = TaskDb.getInstance();
    protected static AliasDb aliasDb = AliasDb.getInstance();

    /**
     * Executes the command.
     */
    public abstract void execute();

    /**
     * Undoes the command.
     */
    public abstract void undo();

    public void pushToUndoStack() {
        undoStack.push(this);
    }

    //================================================================
    // List of setters and getters for testing.
    //================================================================


    public static void setUi(UI ui) {
        Command.ui = ui;
    }

    public static void setParser(InputParser parser) {
        Command.parser = parser;
    }

    public static void setMainStorage(MainStorage mainStorage) {
        Command.mainStorage = mainStorage;
    }

    public static void setTaskDb(TaskDb taskDb) {
        Command.taskDb = taskDb;
    }

    public static void setAliasDb(AliasDb aliasDb) {
        Command.aliasDb = aliasDb;
    }

    public static void setEventBus(EventBus eventBus) {
        Command.eventBus = eventBus;
    }

    public static Stack<Command> getUndoStack() {
        return undoStack;
    }

    public static void clearUndoStack() {
        undoStack.clear();
    }

    public static UI getUI() {
        return ui;
    }

    public static InputParser getParser() {
        return parser;
    }

    public static MainStorage getMainStorage() {
        return mainStorage;
    }

    public static TaskDb getTaskDb() {
        return taskDb;
    }

    public static AliasDb getAliasDb() {
        return aliasDb;
    }

    public static EventBus getEventBus() {
        return eventBus;
    }

}
```
###### /src/main/java/jfdi/logic/interfaces/ILogic.java
``` java

package jfdi.logic.interfaces;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.TreeSet;

/**
 * @author Liu Xinan
 */
public interface ILogic {

    /**
     * Handles user's input.
     * Called by UI whenever the user inputs a text command.
     *
     * @param input Input from user
     */
    void handleInput(String input);

    /**
     * Gets the list of command keywords.
     * Called by UI for populating auto-completion suggestion list.
     *
     * @return a {@code TreeSet} of {@code String}
     */
    TreeSet<String> getKeywords();

    /**
     * Gets the list of incomplete tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getIncompleteTasks();

    /**
     * Gets the list of completed tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getCompletedTasks();

    /**
     * Gets the list of all tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getAllTasks();

    /**
     * Gets the list of upcoming tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getUpcomingTasks();

    /**
     * Gets the list of overdue tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getOverdueTasks();
}
```
###### /src/main/java/jfdi/ui/items/AutoCompleteTextField.java
``` java

package jfdi.ui.items;

import javafx.geometry.Side;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import jfdi.ui.UI;

import java.util.LinkedList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class AutoCompleteTextField extends TextField {

    private SortedSet<String> keywords;
    private LinkedList<String> results;

    private ContextMenu popup;

    public AutoCompleteTextField() {
        super();
        keywords = new TreeSet<>(String::compareToIgnoreCase);
        results = new LinkedList<>();
        popup = new ContextMenu();

        textProperty().addListener((observable, oldValue, newValue) -> {
            if (getText().isEmpty()) {
                popup.hide();
                return;
            }
            results.clear();
            results.addAll(keywords.subSet(getText(), getText() + Character.MAX_VALUE));
            if (results.isEmpty()) {
                popup.hide();
            } else {
                populatePopup(results);
            }
        });

        focusedProperty().addListener((observable, oldValue, newValue) -> popup.hide());

        popup.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            @SuppressWarnings("deprecation")
            boolean isAnyItemSelected = popup.getItems().stream().map(item -> item.impl_styleableGetNode())
                    .anyMatch(node -> node.isFocused());
            if (event.getCode() == KeyCode.ENTER && !isAnyItemSelected) {
                UI.getInstance().triggerEnter();
                results.clear();
            }
        });
    }

    public void setKeywords(SortedSet<String> keywords) {
        this.keywords.clear();
        this.keywords.addAll(keywords);
    }

    public void hidePopup() {
        popup.hide();
    }

    public void selectFirst() {
        if (!results.isEmpty()) {
            select(results.get(0));
            popup.hide();
        }
    }

    private void select(String suggestion) {
        setText(suggestion + " ");
        this.positionCaret(this.getText().length());
    }

    private void populatePopup(LinkedList<String> results) {
        List<CustomMenuItem> menuItems = results.stream()
            .map(Label::new)
            .map(label -> {
                CustomMenuItem menuItem = new CustomMenuItem(label, true);
                menuItem.setOnAction(action -> {
                    select(label.getText());
                    popup.hide();
                });
                return menuItem;
            })
            .collect(Collectors.toCollection(LinkedList::new));

        popup.getItems().setAll(menuItems);

        if (!popup.isShowing()) {
            popup.show(this, Side.BOTTOM, 0, 0);
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/AddTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.doThrow;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AddTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        LocalDateTime startDateTime = LocalDateTime.of(2016, 4, 1, 0, 0);
        LocalDateTime endDateTime = LocalDateTime.of(2016, 4, 1, 23, 59);

        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("test")
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .build();

        assertEquals("test", command.getDescription());
        assertEquals(startDateTime, command.getStartDateTime().get());
        assertEquals(endDateTime, command.getEndDateTime().get());
    }

    @Test
    public void testExecute_successful() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("sleep")
            .build();

        command.execute();

        int id = command.getId();
        assertNotEquals(-1, id);

        TaskAttributes task = TaskDb.getInstance().getById(id);
        assertEquals("sleep", task.getDescription());

        TaskDb.getInstance().destroy(id);
    }

    @Test
    public void testExecute_emptyDescription() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder().build();

        command.execute();

        assertEquals(-1, command.getId());
    }

    @Test
    public void testExecute_duplicatedTask() throws Exception {
        AddTaskCommand command1 = new AddTaskCommand.Builder()
            .setDescription("duplicate")
            .build();

        command1.execute();

        int id1 = command1.getId();
        assertNotEquals(-1, id1);

        AddTaskCommand command2 = new AddTaskCommand.Builder()
            .setDescription("duplicate")
            .build();

        command2.execute();

        assertEquals(-1, command2.getId());

        TaskDb.getInstance().destroy(id1);
    }

    @Test
    public void testUndo_successful() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("undo")
            .build();

        command.execute();

        int id = command.getId();

        Command.setTaskDb(TaskDb.getInstance());
        command.undo();
        Command.setTaskDb(taskDb);

        thrown.expect(InvalidIdException.class);
        TaskDb.getInstance().getById(id);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        doThrow(InvalidIdException.class).when(taskDb).destroy(anyInt());

        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("undo")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/AliasCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AliasCommand;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.exceptions.InvalidAliasException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AliasCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        AliasCommand command1 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        assertEquals("list", command1.getCommand());
        assertEquals("ls", command1.getAlias());
        assertTrue(command1.isValid());

        AliasCommand command2 = new AliasCommand.Builder()
            .setCommand("ls")
            .setAlias("list")
            .setIsValid(false)
            .build();

        assertEquals("ls", command2.getCommand());
        assertEquals("list", command2.getAlias());
        assertFalse(command2.isValid());
    }

    @Test
    public void testExecute_successful() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command.execute();

        String commandString = AliasDb.getInstance().getCommandFromAlias("ls");
        assertEquals("list", commandString);

        AliasDb.getInstance().destroy("ls");
    }

    @Test
    public void testExecute_duplicateAlias() throws Exception {
        AliasCommand command1 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command1.execute();

        int currentUndoStackSize = Command.getUndoStack().size();

        AliasCommand command2 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command2.execute();

        assertEquals(currentUndoStackSize, Command.getUndoStack().size());

        String commandString = AliasDb.getInstance().getCommandFromAlias("ls");
        assertEquals("list", commandString);

        AliasDb.getInstance().destroy("ls");
    }

    @Test
    public void testExecute_invalidAlias() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("add")
            .setIsValid(true)
            .build();

        int currentUndoStackSize = Command.getUndoStack().size();

        command.execute();

        assertEquals(currentUndoStackSize, Command.getUndoStack().size());
    }

    @Test
    public void testUndo_successful() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command.undo();
        verify(aliasDb).destroy("ls");
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        doThrow(InvalidAliasException.class).when(aliasDb).destroy("ls");

        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/CommonCommandTest.java
``` java

package jfdi.test.logic.commands;

import com.google.common.eventbus.EventBus;
import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public abstract class CommonCommandTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Mock
    protected UI ui;

    @Mock
    protected MainStorage mainStorage;

    @Mock
    protected TaskDb taskDb;

    @Mock
    protected AliasDb aliasDb;

    @Mock
    protected InputParser parser;

    @Mock
    protected EventBus eventBus;

    @Before
    public void setUp() throws Exception {
        Command.setUi(ui);
        Command.setMainStorage(mainStorage);
        Command.setTaskDb(taskDb);
        Command.setAliasDb(aliasDb);
        Command.setParser(parser);
        Command.setEventBus(eventBus);

        AliasAttributes.setCommandRegex(InputParser.getInstance().getAllCommandRegexes());
        InputParser.getInstance().setAliases(AliasDb.getInstance().getAll());
        MainStorage.getInstance().initialize();
        MainStorage.getInstance().use("./.test_data");
    }

    @After
    public void tearDown() throws Exception {
        Command.setUi(UI.getInstance());
        Command.setMainStorage(MainStorage.getInstance());
        Command.setTaskDb(TaskDb.getInstance());
        Command.setAliasDb(AliasDb.getInstance());
        Command.setParser(InputParser.getInstance());
        Command.setEventBus(UI.getEventBus());
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/DeleteTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DeleteTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<Integer> ids = new ArrayList<>();
        ids.add(2);
        ids.add(3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addIds(ids)
            .build();

        assertEquals(3, command.getScreenIds().size());
        assertTrue(command.getScreenIds().contains(1));
        assertTrue(command.getScreenIds().contains(2));
        assertTrue(command.getScreenIds().contains(3));
    }

    @Test
    public void testExecute_deleteOne_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .build();

        command.execute();

        assertEquals(1, command.getDeletedTasks().size());
    }

    @Test
    public void testExecute_deleteMore_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addId(2)
            .addId(3)
            .build();

        command.execute();

        assertEquals(3, command.getDeletedTasks().size());
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(false);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(3)).thenReturn(task3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addId(2)
            .addId(3)
            .build();

        command.execute();

        assertNull(command.getDeletedTasks());
    }

    @Test
    public void testExecute_shouldNotHappen_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        doThrow(InvalidIdException.class).when(taskDb).getById(1);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .addId(2)
            .addId(3)
            .build();

        command.execute();
        command.undo();

        verify(taskDb).destroy(1);
        verify(taskDb).destroy(2);
        verify(taskDb).destroy(3);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).undestroy(anyInt());

        DeleteTaskCommand command = new DeleteTaskCommand.Builder()
            .addId(1)
            .build();

        command.execute();

        assertEquals(1, command.getDeletedTasks().size());

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/DirectoryCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.DirectoryCommand;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DirectoryCommandTest extends CommonCommandTest {

    @Test
    public void execute() throws Exception {
        DirectoryCommand command = new DirectoryCommand.Builder().build();

        command.execute();

        verify(mainStorage).getCurrentDirectory();
    }

    @Test
    public void undo() throws Exception {
        DirectoryCommand command = new DirectoryCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/ExitCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.ExitCommand;
import jfdi.logic.events.ExitCalledEvent;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ExitCommandTest extends CommonCommandTest {

    @Test
    public void execute() throws Exception {
        ExitCommand command = new ExitCommand.Builder().build();

        command.execute();

        verify(eventBus).post(any(ExitCalledEvent.class));
    }

    @Test
    public void undo() throws Exception {
        ExitCommand command = new ExitCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/HelpCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.HelpCommand;
import jfdi.logic.events.HelpRequestedEvent;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class HelpCommandTest extends CommonCommandTest {

    @Test
    public void execute() throws Exception {
        HelpCommand command = new HelpCommand.Builder().build();

        command.execute();

        verify(eventBus).post(any(HelpRequestedEvent.class));
    }

    @Test
    public void undo() throws Exception {
        HelpCommand command = new HelpCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/InvalidCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.events.InvalidCommandEvent;
import jfdi.parser.Constants;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
public class InvalidCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        InvalidCommand command1 = new InvalidCommand.Builder()
            .setInputString("never gonna give")
            .setCommandType(null)
            .build();

        assertEquals("never gonna give", command1.getInputString());
        assertNull(command1.getCommandType());

        InvalidCommand command2 = new InvalidCommand.Builder()
            .setInputString("list processing")
            .setCommandType(Constants.CommandType.LIST)
            .build();

        assertEquals("list processing", command2.getInputString());
        assertEquals(Constants.CommandType.LIST, command2.getCommandType());
    }

    @Test
    public void execute() throws Exception {
        InvalidCommand command = new InvalidCommand.Builder()
            .setInputString("never gonna give")
            .setCommandType(null)
            .build();

        command.execute();

        verify(eventBus).post(any(InvalidCommandEvent.class));
    }

    @Test
    public void undo() throws Exception {
        InvalidCommand command = new InvalidCommand.Builder()
            .setInputString("list processing")
            .setCommandType(Constants.CommandType.LIST)
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/ListCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.ListDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;
import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ListCommandTest extends CommonCommandTest {

    private ArgumentCaptor<ListDoneEvent> argument = ArgumentCaptor.forClass(ListDoneEvent.class);

    @Before
    public void setUp() throws Exception {
        super.setUp();

        TaskAttributes floating = new TaskAttributes();

        TaskAttributes upcoming = new TaskAttributes();
        upcoming.setStartDateTime(LocalDateTime.now().plusDays(1));

        TaskAttributes overdue = new TaskAttributes();
        overdue.setStartDateTime(LocalDateTime.now().minusDays(1));

        TaskAttributes incomplete = new TaskAttributes();
        incomplete.setCompleted(false);

        TaskAttributes completed = new TaskAttributes();
        completed.setCompleted(true);

        ArrayList<TaskAttributes> tasks = new ArrayList<>();
        tasks.add(floating);
        tasks.add(upcoming);
        tasks.add(overdue);
        tasks.add(incomplete);
        tasks.add(completed);

        ArrayList<TaskAttributes> overdueTasks = new ArrayList<>();
        overdueTasks.add(overdue);

        ArrayList<TaskAttributes> upcomingTasks = new ArrayList<>();
        upcomingTasks.add(upcoming);

        when(taskDb.getAll()).thenReturn(tasks);
        when(taskDb.getOverdue()).thenReturn(overdueTasks);
        when(taskDb.getUpcoming()).thenReturn(upcomingTasks);
    }

    @Test
    public void testBuilder() throws Exception {
        ListCommand listAll = new ListCommand.Builder()
            .setListType(ListCommand.ListType.ALL)
            .build();

        assertEquals(ListCommand.ListType.ALL, listAll.getListType());

        ListCommand listIncomplete = new ListCommand.Builder()
            .setListType(ListCommand.ListType.INCOMPLETE)
            .build();

        assertEquals(ListCommand.ListType.INCOMPLETE, listIncomplete.getListType());

        ListCommand listUpcoming = new ListCommand.Builder()
            .setListType(ListCommand.ListType.UPCOMING)
            .build();

        assertEquals(ListCommand.ListType.UPCOMING, listUpcoming.getListType());

        ListCommand listOverdue = new ListCommand.Builder()
            .setListType(ListCommand.ListType.OVERDUE)
            .build();

        assertEquals(ListCommand.ListType.OVERDUE, listOverdue.getListType());

        ListCommand listCompleted = new ListCommand.Builder()
            .setListType(ListCommand.ListType.COMPLETED)
            .build();

        assertEquals(ListCommand.ListType.COMPLETED, listCompleted.getListType());
    }

    @Test
    public void testExecute_listAll() throws Exception {
        ListCommand listAll = new ListCommand.Builder()
            .setListType(ListCommand.ListType.ALL)
            .build();

        listAll.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(5, argument.getValue().getItems().size());
    }

    @Test
    public void testExecute_listIncomplete() throws Exception {
        ListCommand listIncomplete = new ListCommand.Builder()
            .setListType(ListCommand.ListType.INCOMPLETE)
            .build();

        listIncomplete.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(4, argument.getValue().getItems().size());

        for (int i = 0; i < 4; i++) {
            assertFalse(argument.getValue().getItems().get(i).isCompleted());
        }
    }

    @Test
    public void testExecute_listUpcoming() throws Exception {
        ListCommand listUpcoming = new ListCommand.Builder()
            .setListType(ListCommand.ListType.UPCOMING)
            .build();

        listUpcoming.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(1, argument.getValue().getItems().size());
        assertTrue(argument.getValue().getItems().get(0).getStartDateTime().isAfter(LocalDateTime.now()));
    }

    @Test
    public void testExecute_listOverdue() throws Exception {
        ListCommand listOverdue = new ListCommand.Builder()
            .setListType(ListCommand.ListType.OVERDUE)
            .build();

        listOverdue.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(1, argument.getValue().getItems().size());
        assertTrue(argument.getValue().getItems().get(0).getStartDateTime().isBefore(LocalDateTime.now()));
    }

    @Test
    public void testExecute_listCompleted() throws Exception {
        ListCommand listCompleted = new ListCommand.Builder()
            .setListType(ListCommand.ListType.COMPLETED)
            .build();

        listCompleted.execute();

        verify(eventBus).post(argument.capture());
        assertEquals(1, argument.getValue().getItems().size());
        assertTrue(argument.getValue().getItems().get(0).isCompleted());
    }

    @Test
    public void undo() throws Exception {
        ListCommand listAll = new ListCommand.Builder()
            .setListType(ListCommand.ListType.ALL)
            .build();

        thrown.expect(AssertionError.class);
        listAll.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/MarkTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.MarkTaskCommand;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class MarkTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<Integer> ids = new ArrayList<>();
        ids.add(2);
        ids.add(3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskIds(ids)
            .build();

        assertEquals(3, command.getScreenIds().size());

        assertTrue(command.getScreenIds().contains(1));
        assertTrue(command.getScreenIds().contains(2));
        assertTrue(command.getScreenIds().contains(3));
        assertNull(command.getMarkedIds());
    }

    @Test
    public void testExecute_markSingle_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        assertEquals(1, command.getMarkedIds().size());
    }

    @Test
    public void testExecute_markSingle_alreadyCompleted_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(NoAttributesChangedException.class).when(taskDb).markAsComplete(anyInt());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();
        assertEquals(0, command.getMarkedIds().size());
    }

    @Test
    public void testExecute_markMultiple_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertEquals(3, command.getMarkedIds().size());
    }

    @Test
    public void testExecute_shouldNotHappen_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsComplete(anyInt());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(false);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(3)).thenReturn(task3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertNull(command.getMarkedIds());
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();
        command.undo();

        verify(taskDb).markAsIncomplete(1);
        verify(taskDb).markAsIncomplete(2);
        verify(taskDb).markAsIncomplete(3);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsIncomplete(anyInt());

        MarkTaskCommand command = new MarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/MoveDirectoryCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.MoveDirectoryCommand;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class MoveDirectoryCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        assertEquals("./new", command.getNewDirectory());
        assertNull(command.getOldDirectory());
    }

    @Test
    public void testExecute_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(mainStorage).changeDirectory("./new");
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_filesReplaced_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).changeDirectory("./new");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus, times(2)).post(any());
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_invalidPath_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).changeDirectory("./new");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus).post(any(MoveDirectoryFailedEvent.class));
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testUndo_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).changeDirectory("./old");
    }

    @Test
    public void testUndo_filesReplaced_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).changeDirectory("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).changeDirectory("./old");
        verify(eventBus, times(2)).post(any());
    }

    @Test
    public void testUndo_invalidPath_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).changeDirectory("./old");

        MoveDirectoryCommand command = new MoveDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();

        verify(mainStorage).changeDirectory("./old");
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/RenameTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.RenameTaskCommand;
import jfdi.logic.events.RenameTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class RenameTaskCommandTest extends CommonCommandTest {

    @Before
    public void setUp() throws Exception {
        super.setUp();

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);

        Command.setTaskDb(TaskDb.getInstance());
    }

    @After
    public void tearDown() throws Exception {
        Command.setTaskDb(taskDb);

        super.tearDown();
    }

    @Test
    public void testBuilder() throws Exception {
        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(1)
            .setDescription("Never gonna give")
            .build();

        assertEquals(1, command.getScreenId());
        assertEquals("Never gonna give", command.getDescription());
        assertNull(command.getOldDescription());
    }

    @Test
    public void testExecute_successful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task 1");
        task.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("Never gonna give")
            .build();

        command.execute();

        assertEquals("Task 1", command.getOldDescription());
        assertNotEquals("Never gonna give", task.getDescription());

        TaskDb.getInstance().destroy(task.getId());
    }

    @Test
    public void testExecute_invalidId_unsuccessful() throws Exception {
        doThrow(InvalidIdException.class).when(taskDb).getById(anyInt());

        Command.setTaskDb(taskDb);

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(1)
            .setDescription("Never gonna give")
            .build();

        command.execute();
        verify(eventBus).post(any(RenameTaskFailedEvent.class));
    }

    @Test
    public void testExecute_noAttributesChanged_unsuccessful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task");
        task.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("Task")
            .build();

        command.execute();

        verify(eventBus).post(any(RenameTaskFailedEvent.class));

        TaskDb.getInstance().destroy(task.getId());
    }

    @Test
    public void testExecute_duplicateTask_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        task1.setDescription("Task 1");
        task1.save();

        TaskAttributes task2 = new TaskAttributes();
        task2.setDescription("Task 2");
        task2.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task2.getId())
            .setDescription("Task 1")
            .build();

        command.execute();

        verify(eventBus).post(any(RenameTaskFailedEvent.class));

        TaskDb.getInstance().destroy(task1.getId());
        TaskDb.getInstance().destroy(task2.getId());
    }

    @Test
    public void testExecute_invalidTaskParameter_unsuccessful() throws Exception {
        Command.setTaskDb(taskDb);

        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task");
        task.save();

        when(taskDb.getById(anyInt())).thenReturn(task);
        TaskDb.getInstance().destroy(task.getId());

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("")
            .build();


        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Task 1");
        task.save();

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(task.getId())
            .setDescription("Never gonna give")
            .build();

        command.execute();

        task = TaskDb.getInstance().getById(task.getId());
        assertEquals("Never gonna give", task.getDescription());

        command.undo();

        task = TaskDb.getInstance().getById(task.getId());
        assertEquals("Task 1", task.getDescription());

        TaskDb.getInstance().destroy(task.getId());
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        Command.setTaskDb(taskDb);
        doThrow(InvalidIdException.class).when(taskDb).getById(anyInt());

        RenameTaskCommand command = new RenameTaskCommand.Builder()
            .setId(666)
            .setDescription("Never gonna give")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/RescheduleTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.RescheduleTaskCommand;
import jfdi.logic.events.RescheduleTaskFailedEvent;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class RescheduleTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        assertEquals(1, command.getScreenId());
        assertEquals(startDateTime, command.getStartDateTime());
        assertEquals(endDateTime, command.getEndDateTime());
        assertNull(command.getOldStartDateTime());
        assertNull(command.getOldEndDateTime());
        assertTrue(command.isShiftedDateSpecified());
        assertTrue(command.isShiftedTimeSpecified());
    }

    @Test
    public void testExecute_nonShifting_successful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(task).setStartDateTime(any(LocalDateTime.class));
        verify(task).setEndDateTime(any(LocalDateTime.class));
        verify(task).save();
    }

    @Test
    public void testExecute_shiftingFloatingTask_successful() throws Exception {
        TaskAttributes floating = mock(TaskAttributes.class);
        when(floating.getStartDateTime()).thenReturn(null);
        when(floating.getEndDateTime()).thenReturn(null);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(floating);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(floating).setStartDateTime(shiftedDateTime);
        verify(floating).setEndDateTime(null);
        verify(floating).save();
    }

    @Test
    public void testExecute_shiftingPointTask_successful() throws Exception {
        TaskAttributes point = mock(TaskAttributes.class);
        when(point.getStartDateTime()).thenReturn(LocalDateTime.now());
        when(point.getEndDateTime()).thenReturn(null);
        when(ui.getTaskId(2)).thenReturn(2);
        when(taskDb.getById(2)).thenReturn(point);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(2)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(point).setStartDateTime(shiftedDateTime);
        verify(point).setEndDateTime(null);
        verify(point).save();
    }

    @Test
    public void testExecute_shiftingDeadlineTask_successful() throws Exception {
        TaskAttributes deadline = mock(TaskAttributes.class);
        when(deadline.getStartDateTime()).thenReturn(null);
        when(deadline.getEndDateTime()).thenReturn(LocalDateTime.now());
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.getById(3)).thenReturn(deadline);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(3)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(deadline).setStartDateTime(null);
        verify(deadline).setEndDateTime(shiftedDateTime);
        verify(deadline).save();
    }

    @Test
    public void testExecute_shiftingEventTask_bothDateTimeSpecified_successful() throws Exception {
        LocalDateTime oldStartDateTime = LocalDateTime.now();
        LocalDateTime oldEndDateTime = oldStartDateTime.plusHours(1);

        TaskAttributes event = mock(TaskAttributes.class);
        when(event.getStartDateTime()).thenReturn(oldStartDateTime);
        when(event.getEndDateTime()).thenReturn(oldEndDateTime);
        when(ui.getTaskId(4)).thenReturn(4);
        when(taskDb.getById(4)).thenReturn(event);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(4)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(event).setStartDateTime(shiftedDateTime);
        verify(event).setEndDateTime(shiftedDateTime.plusHours(1));
        verify(event).save();
    }

    @Test
    public void testExecute_shiftingEventTask_onlyDateSpecified_successful() throws Exception {
        LocalDateTime oldStartDateTime = LocalDateTime.now();
        LocalDateTime oldEndDateTime = oldStartDateTime.plusHours(1);

        TaskAttributes event = mock(TaskAttributes.class);
        when(event.getStartDateTime()).thenReturn(oldStartDateTime);
        when(event.getEndDateTime()).thenReturn(oldEndDateTime);
        when(ui.getTaskId(4)).thenReturn(4);
        when(taskDb.getById(4)).thenReturn(event);

        LocalDateTime shiftedDateTime = LocalDateTime.now().plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(4)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(false)
            .build();

        command.execute();

        verify(event).setStartDateTime(oldStartDateTime.plusDays(1));
        verify(event).setEndDateTime(oldEndDateTime.plusDays(1));
        verify(event).save();
    }

    @Test
    public void testExecute_shiftingEventTask_onlyTimeSpecified_successful() throws Exception {
        LocalDateTime oldStartDateTime = LocalDateTime.now();
        LocalDateTime oldEndDateTime = oldStartDateTime.plusHours(1);

        TaskAttributes event = mock(TaskAttributes.class);
        when(event.getStartDateTime()).thenReturn(oldStartDateTime);
        when(event.getEndDateTime()).thenReturn(oldEndDateTime);
        when(ui.getTaskId(4)).thenReturn(4);
        when(taskDb.getById(4)).thenReturn(event);

        LocalDateTime shiftedDateTime = oldStartDateTime.plusDays(1);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(4)
            .setShiftedDateTime(shiftedDateTime)
            .setShiftedDateSpecified(false)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(event).setStartDateTime(oldStartDateTime);
        verify(event).setEndDateTime(oldEndDateTime);
        verify(event).save();
    }

    @Test
    public void testExecute_invalidId_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        doThrow(InvalidIdException.class).when(taskDb).getById(1);

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(eventBus).post(any(RescheduleTaskFailedEvent.class));
    }

    @Test
    public void testExecute_invalidTaskParameter_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(InvalidTaskParametersException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testExecute_noAttributesChanged_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(NoAttributesChangedException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(task).setStartDateTime(any(LocalDateTime.class));
        verify(task).setEndDateTime(any(LocalDateTime.class));
        verify(task).save();
        verify(eventBus).post(any(RescheduleTaskFailedEvent.class));
    }

    @Test
    public void testExecute_duplicateTask_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(DuplicateTaskException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        verify(task).setStartDateTime(any(LocalDateTime.class));
        verify(task).setEndDateTime(any(LocalDateTime.class));
        verify(task).save();
        verify(eventBus).post(any(RescheduleTaskFailedEvent.class));
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);

        LocalDateTime oldStartDateTime = LocalDateTime.now().minusDays(2);
        LocalDateTime oldEndDateTime = LocalDateTime.now().minusDays(2);
        when(task.getStartDateTime()).thenReturn(oldStartDateTime);
        when(task.getEndDateTime()).thenReturn(oldEndDateTime);

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        command.execute();

        assertEquals(oldStartDateTime, command.getOldStartDateTime());
        assertEquals(oldEndDateTime, command.getOldEndDateTime());
        verify(task).setStartDateTime(startDateTime);
        verify(task).setEndDateTime(endDateTime);
        verify(task).save();

        command.undo();

        verify(task).setStartDateTime(oldStartDateTime);
        verify(task).setEndDateTime(oldEndDateTime);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        TaskAttributes task = mock(TaskAttributes.class);
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.getById(1)).thenReturn(task);
        doThrow(InvalidTaskParametersException.class).when(task).save();

        LocalDateTime startDateTime = LocalDateTime.now().plusDays(1);
        LocalDateTime endDateTime = LocalDateTime.now().plusDays(2);

        RescheduleTaskCommand command = new RescheduleTaskCommand.Builder()
            .setId(1)
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .setShiftedDateSpecified(true)
            .setShiftedTimeSpecified(true)
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/SearchCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.SearchCommand;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class SearchCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<String> keywords = new ArrayList<>();
        keywords.add("you");
        keywords.add("up");

        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .addKeyword("gonna")
            .addKeyword("give")
            .addKeywords(keywords)
            .build();

        assertTrue(command.getKeywords().contains("never"));
        assertTrue(command.getKeywords().contains("gonna"));
        assertTrue(command.getKeywords().contains("give"));
        assertTrue(command.getKeywords().contains("you"));
        assertTrue(command.getKeywords().contains("up"));
        assertNull(command.getResults());
    }

    @Before
    public void setUp() throws Exception {
        super.setUp();

        TaskAttributes neverGonnaGiveYouUp = new TaskAttributes();
        neverGonnaGiveYouUp.setDescription("Never gonna give you up");
        TaskAttributes never = new TaskAttributes();
        never.setDescription("never");
        TaskAttributes gonna = new TaskAttributes();
        gonna.setDescription("gonna");
        TaskAttributes give = new TaskAttributes();
        give.setDescription("give");
        TaskAttributes you = new TaskAttributes();
        you.setDescription("you");
        TaskAttributes up = new TaskAttributes();
        up.setDescription("up");

        ArrayList<TaskAttributes> tasks = new ArrayList<>();
        tasks.add(neverGonnaGiveYouUp);
        tasks.add(never);
        tasks.add(gonna);
        tasks.add(give);
        tasks.add(you);
        tasks.add(up);

        when(taskDb.getAll()).thenReturn(tasks);
    }

    @Test
    public void testExecute_singleKeyword() throws Exception {
        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .build();

        command.execute();

        assertEquals(2, command.getResults().size());
    }

    @Test
    public void testExecute_multipleKeyword() throws Exception {
        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .addKeyword("gonna")
            .addKeyword("give")
            .addKeyword("you")
            .addKeyword("up")
            .build();

        command.execute();

        assertEquals(6, command.getResults().size());
        assertEquals("Never gonna give you up", command.getResults().get(0).getDescription());
    }

    @Test
    public void testUndo() throws Exception {
        SearchCommand command = new SearchCommand.Builder()
            .addKeyword("never")
            .addKeyword("gonna")
            .addKeyword("give")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/UnaliasCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.UnaliasCommand;
import jfdi.logic.events.UnaliasFailedEvent;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.InvalidAliasException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UnaliasCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        assertEquals("ls", command.getAlias());
    }

    @Test
    public void testExecute_successful() throws Exception {
        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        command.execute();

        verify(aliasDb).destroy("ls");
        verify(aliasDb).getAll();
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        doThrow(InvalidAliasException.class).when(aliasDb).destroy("ls");

        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        command.execute();

        verify(aliasDb).destroy("ls");
        verifyNoMoreInteractions(aliasDb);
        verifyZeroInteractions(parser);
        verify(eventBus).post(any(UnaliasFailedEvent.class));
    }

    @Test
    public void testUndo_successful() throws Exception {
        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        command.undo();

        verify(aliasDb).undestroy("ls");
        verify(aliasDb).getAll();
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        doThrow(InvalidAliasException.class).when(aliasDb).undestroy("ls");

        UnaliasCommand command = new UnaliasCommand.Builder()
            .setAlias("ls")
            .build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/UndoCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AliasCommand;
import jfdi.logic.commands.UndoCommand;
import jfdi.logic.events.UndoFailedEvent;
import jfdi.logic.interfaces.Command;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UndoCommandTest extends CommonCommandTest {

    @Test
    public void testExecute_successful() throws Exception {
        AliasCommand aliasCommand = mock(AliasCommand.class);
        doCallRealMethod().when(aliasCommand).pushToUndoStack();

        aliasCommand.pushToUndoStack();

        UndoCommand undoCommand = new UndoCommand.Builder().build();

        undoCommand.execute();

        verify(aliasCommand).undo();
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        Command.getUndoStack().clear();

        UndoCommand undoCommand = new UndoCommand.Builder().build();

        undoCommand.execute();

        verify(eventBus).post(any(UndoFailedEvent.class));
    }

    @Test
    public void undo() throws Exception {
        UndoCommand command = new UndoCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/UnmarkTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.UnmarkTaskCommand;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UnmarkTaskCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        ArrayList<Integer> ids = new ArrayList<>();
        ids.add(2);
        ids.add(3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskIds(ids)
            .build();

        assertEquals(3, command.getScreenIds().size());
        assertTrue(command.getScreenIds().contains(1));
        assertTrue(command.getScreenIds().contains(2));
        assertTrue(command.getScreenIds().contains(3));
        assertNull(command.getUnmarkedIds());
    }

    @Test
    public void testExecute_markSingle_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        assertEquals(1, command.getUnmarkedIds().size());
    }

    @Test
    public void testExecute_markSingle_alreadyCompleted_successful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(NoAttributesChangedException.class).when(taskDb).markAsIncomplete(anyInt());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();
        assertEquals(0, command.getUnmarkedIds().size());
    }

    @Test
    public void testExecute_markMultiple_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertEquals(3, command.getUnmarkedIds().size());
    }

    @Test
    public void testExecute_shouldNotHappen_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsIncomplete(anyInt());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        thrown.expect(AssertionError.class);
        command.execute();
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(false);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(3)).thenReturn(task3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();

        assertNull(command.getUnmarkedIds());
    }

    @Test
    public void testUndo_successful() throws Exception {
        TaskAttributes task1 = new TaskAttributes();
        TaskAttributes task2 = new TaskAttributes();
        TaskAttributes task3 = new TaskAttributes();
        task1.setId(1);
        task2.setId(2);
        task3.setId(3);

        when(ui.getTaskId(1)).thenReturn(1);
        when(ui.getTaskId(2)).thenReturn(2);
        when(ui.getTaskId(3)).thenReturn(3);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.hasId(2)).thenReturn(true);
        when(taskDb.hasId(3)).thenReturn(true);
        when(taskDb.getById(1)).thenReturn(task1);
        when(taskDb.getById(2)).thenReturn(task2);
        when(taskDb.getById(3)).thenReturn(task3);

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .addTaskId(2)
            .addTaskId(3)
            .build();

        command.execute();
        command.undo();

        verify(taskDb).markAsComplete(1);
        verify(taskDb).markAsComplete(2);
        verify(taskDb).markAsComplete(3);
    }

    @Test
    public void testUndo_unsuccessful() throws Exception {
        when(ui.getTaskId(1)).thenReturn(1);
        when(taskDb.hasId(1)).thenReturn(true);
        when(taskDb.getById(anyInt())).thenReturn(new TaskAttributes());
        doThrow(InvalidIdException.class).when(taskDb).markAsComplete(anyInt());

        UnmarkTaskCommand command = new UnmarkTaskCommand.Builder()
            .addTaskId(1)
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/UseDirectoryCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.UseDirectoryCommand;
import jfdi.logic.events.UseDirectoryDoneEvent;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class UseDirectoryCommandTest extends CommonCommandTest {

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        assertEquals("./new", command.getNewDirectory());
        assertNull(command.getOldDirectory());
    }

    @Test
    public void testExecute_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(mainStorage).use("./new");
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_filesReplaced_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).use("./new");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus, times(2)).post(any());
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testExecute_invalidPath_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).use("./new");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        verify(eventBus).post(any(UseDirectoryDoneEvent.class));
        assertEquals("./old", command.getOldDirectory());
    }

    @Test
    public void testUndo_successful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).use("./old");
    }

    @Test
    public void testUndo_filesReplaced_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(FilesReplacedException.class).when(mainStorage).use("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();
        command.undo();

        verify(mainStorage).use("./old");
        verify(eventBus, times(2)).post(any());
    }

    @Test
    public void testUndo_invalidPath_unsuccessful() throws Exception {
        when(mainStorage.getCurrentDirectory()).thenReturn("./old");
        doThrow(InvalidFilePathException.class).when(mainStorage).use("./old");

        UseDirectoryCommand command = new UseDirectoryCommand.Builder()
            .setNewDirectory("./new")
            .build();

        command.execute();

        thrown.expect(AssertionError.class);
        command.undo();

        verify(mainStorage).use("./old");
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/WildcardCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.WildcardCommand;
import jfdi.logic.events.NoSurpriseEvent;
import jfdi.logic.events.SurpriseEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class WildcardCommandTest extends CommonCommandTest {

    @Test
    public void testExecute_successful() throws Exception {
        TaskAttributes task = new TaskAttributes();
        task.setDescription("Never gonna give you up");
        task.setCompleted(false);

        ArrayList<TaskAttributes> tasks = new ArrayList<>();
        tasks.add(task);

        when(taskDb.getAll()).thenReturn(tasks);

        WildcardCommand command = new WildcardCommand.Builder().build();

        assertNull(command.getLucky());

        command.execute();

        assertEquals(task, command.getLucky());
        verify(eventBus).post(any(SurpriseEvent.class));
    }

    @Test
    public void testExecute_unsuccessful() throws Exception {
        when(taskDb.getAll()).thenReturn(new ArrayList<>());

        WildcardCommand command = new WildcardCommand.Builder().build();

        assertNull(command.getLucky());

        command.execute();

        assertNull(command.getLucky());
        verify(eventBus).post(any(NoSurpriseEvent.class));
    }

    @Test
    public void undo() throws Exception {
        WildcardCommand command = new WildcardCommand.Builder().build();

        thrown.expect(AssertionError.class);
        command.undo();
    }

}
```
###### /src/test/java/jfdi/test/logic/ControlCenterTest.java
``` java

package jfdi.test.logic;

import com.google.common.eventbus.EventBus;
import jfdi.logic.ControlCenter;
import jfdi.logic.commands.ExitCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.InitializationFailedEvent;
import jfdi.logic.events.InvalidCommandEvent;
import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertSame;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.*;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ControlCenterTest {

    @Mock
    private InputParser parser;

    @Mock
    private MainStorage mainStorage;

    @Mock
    private TaskDb taskDb;

    @Mock
    private AliasDb aliasDb;

    @Mock
    private EventBus eventBus;

    @Mock
    private ListCommand ls;

    @Mock
    private ExitCommand exit;

    @Mock
    private InvalidCommand lol;

    @Before
    public void setUp() throws Exception {
        ControlCenter.setParser(parser);
        ControlCenter.setMainStorage(mainStorage);
        ControlCenter.setTaskDb(taskDb);
        ControlCenter.setAliasDb(aliasDb);
        ControlCenter.setEventBus(eventBus);

        when(parser.getAllCommandRegexes()).thenReturn(InputParser.getInstance().getAllCommandRegexes());
    }

    @After
    public void tearDown() throws Exception {
        ControlCenter.setParser(InputParser.getInstance());
        ControlCenter.setMainStorage(MainStorage.getInstance());
        ControlCenter.setTaskDb(TaskDb.getInstance());
        ControlCenter.setAliasDb(AliasDb.getInstance());
        ControlCenter.setEventBus(UI.getEventBus());
        ControlCenter.removeInstance();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertSame(ControlCenter.getInstance(), ControlCenter.getInstance());
    }

    @Test
    public void testHandleInput_successful() throws Exception {
        when(parser.parse("list")).thenReturn(ls);
        when(parser.parse("lol")).thenReturn(lol);
        when(parser.parse("exit")).thenReturn(exit);

        ControlCenter cc = ControlCenter.getInstance();

        cc.handleInput("list");
        cc.handleInput("lol");
        cc.handleInput("exit");

        verify(ls).execute();
        verify(lol).execute();
        verify(exit).execute();
    }

    @Test
    public void testHandleInput_invalidInput() throws Exception {
        doThrow(InvalidInputException.class).when(parser).parse(anyString());

        EventBus eventBus = mock(EventBus.class);
        Command.setEventBus(eventBus);

        ControlCenter cc = ControlCenter.getInstance();

        cc.handleInput("never gonna give");

        verify(eventBus).post(any(InvalidCommandEvent.class));
        Command.setEventBus(UI.getEventBus());
    }

    @Test
    public void testInitStorage_filesReplaced() throws Exception {
        doThrow(FilesReplacedException.class).when(mainStorage).initialize();

        ControlCenter.getInstance();
        verify(eventBus).post(any(FilesReplacedEvent.class));
    }

    @Test
    public void testInitStorage_invalidPath() throws Exception {
        doThrow(InvalidFilePathException.class).when(mainStorage).initialize();

        ControlCenter.getInstance();
        verify(eventBus).post(any(InitializationFailedEvent.class));
    }

}
```
###### /src/test/java/jfdi/test/logic/events/AddTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertSame;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AddTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        AddTaskDoneEvent event = new AddTaskDoneEvent(task);
        assertSame(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/AddTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AddTaskFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AddTaskFailedEventTest {

    @Test
    public void getError() throws Exception {
        AddTaskFailedEvent event = new AddTaskFailedEvent(AddTaskFailedEvent.Error.EMPTY_DESCRIPTION);
        assertEquals(AddTaskFailedEvent.Error.EMPTY_DESCRIPTION, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (AddTaskFailedEvent.Error error : AddTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            AddTaskFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### /src/test/java/jfdi/test/logic/events/AliasDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AliasDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AliasDoneEventTest {

    private static final String COMMAND = "delete";
    private static final String ALIAS = "del";

    @Test
    public void getCommand() throws Exception {
        AliasDoneEvent event = new AliasDoneEvent(COMMAND, ALIAS);
        assertEquals(COMMAND, event.getCommand());
    }

    @Test
    public void getAlias() throws Exception {
        AliasDoneEvent event = new AliasDoneEvent(COMMAND, ALIAS);
        assertEquals(ALIAS, event.getAlias());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/AliasFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AliasFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AliasFailedEventTest {

    private AliasFailedEvent event = new AliasFailedEvent("list", "ls", AliasFailedEvent.Error.DUPLICATED_ALIAS);

    @Test
    public void getCommand() throws Exception {
        assertEquals("list", event.getCommand());
    }

    @Test
    public void getAlias() throws Exception {
        assertEquals("ls", event.getAlias());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(AliasFailedEvent.Error.DUPLICATED_ALIAS, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (AliasFailedEvent.Error error : AliasFailedEvent.Error.values()) {
            // Force a full coverage on enums
            AliasFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### /src/test/java/jfdi/test/logic/events/CommandUndoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.logic.events.CommandUndoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEventTest {

    @Test
    public void getCommandType() throws Exception {
        CommandUndoneEvent event = new CommandUndoneEvent(DeleteTaskCommand.class);
        assertEquals(DeleteTaskCommand.class, event.getCommandType());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/DeleteTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DeleteTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> deletedIds;

    @Mock
    private ArrayList<TaskAttributes> deletedTasks;

    @Test
    public void getDeletedIds() throws Exception {
        DeleteTaskDoneEvent event = new DeleteTaskDoneEvent(deletedIds, deletedTasks);
        assertEquals(deletedIds, event.getDeletedIds());
    }

    @Test
    public void getDeletedTasks() throws Exception {
        DeleteTaskDoneEvent event = new DeleteTaskDoneEvent(deletedIds, deletedTasks);
        assertEquals(deletedTasks, event.getDeletedTasks());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/DeleteTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.DeleteTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> invalidIds;

    @Test
    public void getInvalidIds() throws Exception {
        DeleteTaskFailedEvent event = new DeleteTaskFailedEvent(invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        DeleteTaskFailedEvent event1 = new DeleteTaskFailedEvent(invalidIds);
        assertEquals(DeleteTaskFailedEvent.Error.NON_EXISTENT_ID, event1.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (DeleteTaskFailedEvent.Error error : DeleteTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            DeleteTaskFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### /src/test/java/jfdi/test/logic/events/ExitCalledEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.ExitCalledEvent;
import org.junit.Test;

import static org.junit.Assert.assertNotNull;

/**
 * @author Xinan
 */
public class ExitCalledEventTest {

    @Test
    public void nothingToTest() {
        ExitCalledEvent event = new ExitCalledEvent();
        assertNotNull(event);
    }

}
```
###### /src/test/java/jfdi/test/logic/events/FilesReplacedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.storage.exceptions.FilePathPair;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEventTest {

    @Mock
    private ArrayList<FilePathPair> filePathPairs;

    private String newDirectory = ".";

    @Test
    public void getFilePathPairs() throws Exception {
        FilesReplacedEvent event1 = new FilesReplacedEvent(filePathPairs);
        assertEquals(filePathPairs, event1.getFilePathPairs());

        FilesReplacedEvent event2 = new FilesReplacedEvent(newDirectory, filePathPairs);
        assertEquals(filePathPairs, event2.getFilePathPairs());
    }

    @Test
    public void getNewDirectory() throws Exception {
        FilesReplacedEvent event1 = new FilesReplacedEvent(filePathPairs);
        assertNull(event1.getNewDirectory());

        FilesReplacedEvent event2 = new FilesReplacedEvent(newDirectory, filePathPairs);
        assertEquals(newDirectory, event2.getNewDirectory());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/HelpRequestedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.HelpRequestedEvent;
import org.junit.Test;

import static org.junit.Assert.assertNotNull;

/**
 * @author Liu Xinan
 */
public class HelpRequestedEventTest {

    @Test
    public void nothingToTest() {
        HelpRequestedEvent event = new HelpRequestedEvent();
        assertNotNull(event);
    }

}
```
###### /src/test/java/jfdi/test/logic/events/InitializationFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.InitializationFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEventTest {

    private InitializationFailedEvent.Error error = InitializationFailedEvent.Error.INVALID_PATH;
    private String path = "!@#!@#!@#";

    @Test
    public void getError() throws Exception {
        InitializationFailedEvent event = new InitializationFailedEvent(error, path);
        assertEquals(error, event.getError());
    }

    @Test
    public void getPath() throws Exception {
        InitializationFailedEvent event = new InitializationFailedEvent(error, path);
        assertEquals(path, event.getPath());
    }

    @Test
    public void testEnum() throws Exception {
        for (InitializationFailedEvent.Error error : InitializationFailedEvent.Error.values()) {
            // Force a full coverage on enums
            InitializationFailedEvent.Error.valueOf(error.toString());
        }
    }
}
```
###### /src/test/java/jfdi/test/logic/events/InvalidCommandEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.parser.Constants;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEventTest {

    @Test
    public void getInputString() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("WTF", null);
        assertEquals("WTF", event.getInputString());
    }

    @Test
    public void getCommandType() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("undo redo", Constants.CommandType.UNDO);
        assertEquals(Constants.CommandType.UNDO, event.getCommandType());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/ListDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.ListDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class ListDoneEventTest {

    @Mock
    private ListCommand.ListType listType;

    @Mock
    private ArrayList<TaskAttributes> items;

    @Test
    public void getItems() throws Exception {
        ListDoneEvent event = new ListDoneEvent(listType, items);
        assertEquals(items, event.getItems());
    }

    @Test
    public void getListType() throws Exception {
        ListDoneEvent event = new ListDoneEvent(listType, items);
        assertEquals(listType, event.getListType());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MarkTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<TaskAttributes> markedTasks;

    @Test
    public void getScreenIds() throws Exception {
        MarkTaskDoneEvent event = new MarkTaskDoneEvent(screenIds, markedTasks);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getMarkedTasks() throws Exception {
        MarkTaskDoneEvent event = new MarkTaskDoneEvent(screenIds, markedTasks);
        assertEquals(markedTasks, event.getMarkedTasks());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MarkTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MarkTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<Integer> invalidIds;

    private MarkTaskFailedEvent.Error error = MarkTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenIds() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getInvalidIds() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (MarkTaskFailedEvent.Error error : MarkTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            MarkTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MoveDirectoryDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MoveDirectoryDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEventTest {

    private String newDirectory = ".";

    @Test
    public void getNewDirectory() throws Exception {
        MoveDirectoryDoneEvent event = new MoveDirectoryDoneEvent(newDirectory);
        assertEquals(newDirectory, event.getNewDirectory());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MoveDirectoryFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MoveDirectoryFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEventTest {

    private String newDirectory = "!@#!@#$@#$";
    private MoveDirectoryFailedEvent.Error error = MoveDirectoryFailedEvent.Error.INVALID_PATH;

    @Test
    public void getNewDirectory() throws Exception {
        MoveDirectoryFailedEvent event = new MoveDirectoryFailedEvent(newDirectory, error);
        assertEquals(newDirectory, event.getNewDirectory());
    }

    @Test
    public void getError() throws Exception {
        MoveDirectoryFailedEvent event = new MoveDirectoryFailedEvent(newDirectory, error);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (MoveDirectoryFailedEvent.Error error : MoveDirectoryFailedEvent.Error.values()) {
            // Force a full coverage on enums
            MoveDirectoryFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/NoSurpriseEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.NoSurpriseEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEventTest {

    @Test
    public void getError() throws Exception {
        NoSurpriseEvent event = new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS);
        assertEquals(NoSurpriseEvent.Error.NO_TASKS, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (NoSurpriseEvent.Error error : NoSurpriseEvent.Error.values()) {
            // Force a full coverage on enums
            NoSurpriseEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RenameTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        RenameTaskDoneEvent event = new RenameTaskDoneEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RenameTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RenameTaskFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEventTest {

    private int screenId = 666;
    private String description = "Task 666";
    private RenameTaskFailedEvent event = new RenameTaskFailedEvent(screenId, description,
        RenameTaskFailedEvent.Error.DUPLICATED_TASK);

    @Test
    public void getScreenId() throws Exception {
        assertEquals(screenId, event.getScreenId());
    }

    @Test
    public void getDescription() throws Exception {
        assertEquals(description, event.getDescription());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(RenameTaskFailedEvent.Error.DUPLICATED_TASK, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (RenameTaskFailedEvent.Error error : RenameTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            RenameTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RescheduleTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        RescheduleTaskDoneEvent event = new RescheduleTaskDoneEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RescheduleTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RescheduleTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.time.LocalDateTime;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEventTest {

    @Mock
    private LocalDateTime startDateTime;

    @Mock
    private LocalDateTime endDateTime;

    private int screenId = 666;
    private RescheduleTaskFailedEvent.Error error = RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenId() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(screenId, event.getScreenId());
    }

    @Test
    public void getStartDateTime() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(startDateTime, event.getStartDateTime());
    }

    @Test
    public void getEndDateTime() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(endDateTime, event.getEndDateTime());
    }

    @Test
    public void getError() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (RescheduleTaskFailedEvent.Error error : RescheduleTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            RescheduleTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/SearchDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;
import java.util.HashSet;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class SearchDoneEventTest {

    @Mock
    private HashSet<String> keywords;

    @Mock
    private ArrayList<TaskAttributes> results;

    @Test
    public void getResults() throws Exception {
        SearchDoneEvent event = new SearchDoneEvent(results, keywords);
        assertEquals(results, event.getResults());
    }

    @Test
    public void getKeywords() throws Exception {
        SearchDoneEvent event = new SearchDoneEvent(results, keywords);
        assertEquals(keywords, event.getKeywords());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/ShowDirectoryEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.ShowDirectoryEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEventTest {

    private String pwd = "/home/ubuntu/jfdi";

    @Test
    public void getPwd() throws Exception {
        ShowDirectoryEvent event = new ShowDirectoryEvent(pwd);
        assertEquals(pwd, event.getPwd());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/SurpriseEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.SurpriseEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class SurpriseEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        SurpriseEvent event = new SurpriseEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnaliasDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnaliasDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEventTest {

    private String alias = "alias";

    @Test
    public void getAlias() throws Exception {
        UnaliasDoneEvent event = new UnaliasDoneEvent(alias);
        assertEquals(alias, event.getAlias());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnaliasFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnaliasFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEventTest {

    private String alias = "alias";
    private UnaliasFailedEvent.Error error = UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS;
    private UnaliasFailedEvent event = new UnaliasFailedEvent(alias, error);

    @Test
    public void getAlias() throws Exception {
        assertEquals(alias, event.getAlias());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UnaliasFailedEvent.Error error : UnaliasFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UnaliasFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UndoFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UndoFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UndoFailedEventTest {

    @Test
    public void getError() throws Exception {
        UndoFailedEvent event = new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO);
        assertEquals(UndoFailedEvent.Error.NONTHING_TO_UNDO, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UndoFailedEvent.Error error : UndoFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UndoFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnmarkTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<TaskAttributes> unmarkedTasks;

    @Test
    public void getScreenIds() throws Exception {
        UnmarkTaskDoneEvent event = new UnmarkTaskDoneEvent(screenIds, unmarkedTasks);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getUnmarkedTasks() throws Exception {
        UnmarkTaskDoneEvent event = new UnmarkTaskDoneEvent(screenIds, unmarkedTasks);
        assertEquals(unmarkedTasks, event.getUnmarkedTasks());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnmarkTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnmarkTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<Integer> invalidIds;

    private UnmarkTaskFailedEvent.Error error = UnmarkTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenIds() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getInvalidIds() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UnmarkTaskFailedEvent.Error error : UnmarkTaskFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UnmarkTaskFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UseDirectoryDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UseDirectoryDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEventTest {

    private String newDirectory = ".";

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryDoneEvent event = new UseDirectoryDoneEvent(newDirectory);
        assertEquals(newDirectory, event.getNewDirectory());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UseDirectoryFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UseDirectoryFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEventTest {

    private String newDirectory = "!@#$!@#$";
    private UseDirectoryFailedEvent.Error error = UseDirectoryFailedEvent.Error.INVALID_PATH;

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryFailedEvent event = new UseDirectoryFailedEvent(newDirectory, error);
        assertEquals(newDirectory, event.getNewDirectory());
    }

    @Test
    public void getError() throws Exception {
        UseDirectoryFailedEvent event = new UseDirectoryFailedEvent(newDirectory, error);
        assertEquals(error, event.getError());
    }

    @Test
    public void testEnum() throws Exception {
        for (UseDirectoryFailedEvent.Error error : UseDirectoryFailedEvent.Error.values()) {
            // Force a full coverage on enums
            UseDirectoryFailedEvent.Error.valueOf(error.toString());
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/interfaces/CommandTest.java
``` java

package jfdi.test.logic.interfaces;

import com.google.common.eventbus.EventBus;
import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertSame;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class CommandTest {

    private Command command;

    @Mock
    private UI ui;

    @Mock
    private MainStorage mainStorage;

    @Mock
    private TaskDb taskDb;

    @Mock
    private AliasDb aliasDb;

    @Mock
    private InputParser parser;

    @Mock
    private EventBus eventBus;

    @Before
    public void setUp() throws Exception {
        command = Mockito.mock(Command.class, Mockito.CALLS_REAL_METHODS);
        Command.setUi(ui);
        Command.setMainStorage(mainStorage);
        Command.setTaskDb(taskDb);
        Command.setAliasDb(aliasDb);
        Command.setParser(parser);
        Command.setEventBus(eventBus);
    }

    @After
    public void tearDown() throws Exception {
        Command.setUi(UI.getInstance());
        Command.setMainStorage(MainStorage.getInstance());
        Command.setTaskDb(TaskDb.getInstance());
        Command.setAliasDb(AliasDb.getInstance());
        Command.setParser(InputParser.getInstance());
        Command.setEventBus(UI.getEventBus());
    }

    @Test
    public void pushToUndoStack() throws Exception {
        int currentSize = Command.getUndoStack().size();

        command.pushToUndoStack();
        assertEquals(currentSize + 1, Command.getUndoStack().size());

        command.pushToUndoStack();
        assertEquals(currentSize + 2, Command.getUndoStack().size());

        command.pushToUndoStack();
        assertEquals(currentSize + 3, Command.getUndoStack().size());
    }

    @Test
    public void clearUndoStack() throws Exception {
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();
        command.pushToUndoStack();

        Command.clearUndoStack();

        assertEquals(0, Command.getUndoStack().size());
    }

    @Test
    public void getParser() throws Exception {
        assertSame(parser, Command.getParser());
    }

    @Test
    public void getMainStorage() throws Exception {
        assertSame(mainStorage, Command.getMainStorage());
    }

    @Test
    public void getTaskDb() throws Exception {
        assertSame(taskDb, Command.getTaskDb());
    }

    @Test
    public void getAliasDb() throws Exception {
        assertSame(aliasDb, Command.getAliasDb());
    }

    @Test
    public void getUI()  throws Exception {
        assertSame(ui, Command.getUI());
    }

    @Test
    public void getEventBus() throws Exception {
        assertSame(eventBus, Command.getEventBus());
    }

}
```
