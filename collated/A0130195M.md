# A0130195M
###### /config/checkstyle/checkstyle.xml
``` xml
<!DOCTYPE module PUBLIC
  "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
  "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">

<module name="Checker">
  <property name="localeCountry" value="SG" />
  <property name="localeLanguage" value="en" />
  <property name="charset" value="UTF-8" />

  <module name="FileTabCharacter">
    <property name="eachLine" value="true" />
  </module>
  <module name="NewlineAtEndOfFile" />
  <module name="RegexpSingleline">
    <property name="format" value="\s+$"/>
    <property name="message" value="Trailing whitespace"/>
  </module>
  <module name="RegexpSingleline">
    <property name="format" value="/\*\* +\p{javaLowerCase}"/>
    <property name="fileExtensions" value="java"/>
    <property name="message" value="First sentence in a comment should start with a capital letter"/>
  </module>
  <module name="RegexpMultiline">
    <property name="format" value="/\*\*\W+\* +\p{javaLowerCase}"/>
    <property name="fileExtensions" value="java"/>
    <property name="message" value="First sentence in a comment should start with a capital letter"/>
  </module>

  <module name="TreeWalker">
    <module name="OuterTypeFilename" />
    <module name="IllegalTokenText">
      <property name="tokens" value="STRING_LITERAL, CHAR_LITERAL" />
      <property name="format" value="\\u00(08|09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)" />
      <property name="message" value="Avoid using corresponding octal or unicode escape for characters that have special escape sequences." />
    </module>
    <module name="AvoidEscapedUnicodeCharacters">
      <property name="allowEscapesForControlCharacters" value="true" />
      <property name="allowByTailComment" value="true" />
      <property name="allowNonPrintableEscapes" value="true" />
    </module>
    <module name="EmptyLineSeparator">
      <property name="allowNoEmptyLineBetweenFields" value="true" />
    </module>
    <module name="LineLength">
      <property name="max" value="120" />
      <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://" />
    </module>
    <module name="NoLineWrap" />
    <module name="OneTopLevelClass" />
    <module name="DeclarationOrder" />
    <module name="OverloadMethodsDeclarationOrder" />
    <module name="AvoidNestedBlocks" />
    <module name="NeedBraces" />
    <module name="LeftCurly" />
    <module name="RightCurly" />
    <module name="DefaultComesLast" />
    <module name="EmptyStatement" />
    <module name="EqualsHashCode" />
    <module name="EmptyBlock">
      <property name="option" value="TEXT" />
      <property name="tokens" value="LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH" />
    </module>
    <module name="EmptyCatchBlock">
      <property name="commentFormat" value="Excepted" />
    </module>
    <module name="Indentation" />
    <module name="OneStatementPerLine" />
    <module name="OperatorWrap">
      <property name="tokens" value="BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR" />
    </module>
    <module name="SeparatorWrap">
      <property name="tokens" value="DOT" />
      <property name="option" value="nl" />
    </module>
    <module name="SeparatorWrap">
      <property name="tokens" value="COMMA" />
      <property name="option" value="eol" />
    </module>
    <module name="NoWhitespaceAfter" />
    <module name="NoWhitespaceBefore" />
    <module name="ParenPad" />
    <module name="WhitespaceAfter" />
    <module name="WhitespaceAround">
      <property name="allowEmptyConstructors" value="true" />
      <property name="allowEmptyMethods" value="true" />
      <property name="allowEmptyTypes" value="true" />
      <property name="allowEmptyLoops" value="true" />
      <message key="ws.notFollowed"
               value="WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement." />
      <message key="ws.notPreceded"
               value="WhitespaceAround: ''{0}'' is not preceded with whitespace." />
    </module>
    <module name="GenericWhitespace">
      <message key="ws.followed"
               value="GenericWhitespace ''{0}'' is followed by whitespace." />
      <message key="ws.preceded"
               value="GenericWhitespace ''{0}'' is preceded with whitespace." />
      <message key="ws.illegalFollow"
               value="GenericWhitespace ''{0}'' should followed by whitespace." />
      <message key="ws.notPreceded"
               value="GenericWhitespace ''{0}'' is not preceded with whitespace." />
    </module>
    <module name="MethodParamPad" />
    <module name="MultipleVariableDeclarations" />
    <module name="ArrayTypeStyle" />
    <module name="FallThrough" />
    <module name="MissingSwitchDefault" />
    <module name="NoClone" />
    <module name="SimplifyBooleanExpression" />
    <module name="SimplifyBooleanReturn" />
    <module name="StringLiteralEquality" />
    <module name="UnnecessaryParentheses" />
    <module name="RedundantImport" />
    <module name="UnusedImports" />
    <module name="TodoComment">
      <property name="format" value="(TODO)|(FIXME)" />
      <property name="severity" value="warning" />
    </module>
    <module name="RedundantModifier" />
    <module name="AnnotationLocation">
      <property name="tokens" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF" />
    </module>
    <module name="AnnotationLocation">
      <property name="tokens" value="VARIABLE_DEF" />
      <property name="allowSamelineMultipleAnnotations" value="true" />
    </module>
    <module name="ModifierOrder" />
    <module name="UpperEll" />
    <module name="PackageName">
      <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$" />
      <message key="name.invalidPattern"
               value="Package name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="TypeName">
      <message key="name.invalidPattern"
               value="Type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="MemberName">
      <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$" />
      <message key="name.invalidPattern"
               value="Member name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="LocalVariableName">
      <property name="tokens" value="VARIABLE_DEF" />
      <property name="format" value="^[a-z][a-z0-9][a-zA-Z0-9]*$" />
      <property name="allowOneCharVarInForLoop" value="true" />
      <message key="name.invalidPattern"
               value="Local variable name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="ClassTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Class type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="MethodTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Method type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="InterfaceTypeParameterName">
      <property name="format" value="(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)" />
      <message key="name.invalidPattern"
               value="Interface type name ''{0}'' must match pattern ''{1}''." />
    </module>
    <module name="AbbreviationAsWordInName">
      <property name="ignoreFinal" value="false" />
      <property name="allowedAbbreviationLength" value="3" />
    </module>
    <module name="ConstantName">
      <property name="applyToProtected" value="false" />
      <property name="applyToPrivate" value="false" />
      <property name="applyToPackage" value="false" />
    </module>
    <module name="NoFinalizer" />
    <module name="SingleLineJavadoc" />
    <module name="JavadocParagraph" />
    <module name="AtclauseOrder">
      <property name="tagOrder" value="@param, @return, @throws, @deprecated" />
      <property name="target" value="CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF" />
    </module>
    <module name="JavadocTagContinuationIndentation" />
    <module name="NonEmptyAtclauseDescription" />
  </module>
</module>
```
###### /src/main/java/jfdi/logic/commands/AddTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.logic.events.AddTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.LocalDateTime;
import java.util.Optional;

/**
 * @author Liu Xinan
 */
public class AddTaskCommand extends Command {

    private String description;
    private Optional<LocalDateTime> startDateTime;
    private Optional<LocalDateTime> endDateTime;
    private int id = -1;

    private AddTaskCommand(Builder builder) {
        this.description = builder.description;
        this.startDateTime = Optional.ofNullable(builder.startDateTime);
        this.endDateTime = Optional.ofNullable(builder.endDateTime);
    }

    public String getDescription() {
        return description;
    }

    public Optional<LocalDateTime> getStartDateTime() {
        return startDateTime;
    }

    public Optional<LocalDateTime> getEndDateTime() {
        return endDateTime;
    }

    public int getId() {
        return id;
    }

    public static class Builder {

        String description;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
            this.startDateTime = startDateTime;
            return this;
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
            this.endDateTime = endDateTime;
            return this;
        }

        public AddTaskCommand build() {
            return new AddTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        TaskAttributes task = new TaskAttributes();
        task.setDescription(description);
        startDateTime.ifPresent(task::setStartDateTime);
        endDateTime.ifPresent(task::setEndDateTime);
        try {
            task.save();
            this.id = task.getId();

            pushToUndoStack();
            eventBus.post(new AddTaskDoneEvent(task));
        } catch (InvalidTaskParametersException e) {
            eventBus.post(new AddTaskFailedEvent(
                AddTaskFailedEvent.Error.EMPTY_DESCRIPTION));
        } catch (DuplicateTaskException e) {
            eventBus.post(new AddTaskFailedEvent(
                AddTaskFailedEvent.Error.DUPLICATED_TASK));
        } catch (NoAttributesChangedException | InvalidIdException e) {
            // Should not happen for creating tasks
            assert false;
        }
    }

    @Override
    public void undo() {
        try {
            taskDb.destroy(id);

            pushToRedoStack();
        } catch (InvalidIdException e) {
            // Should not happen for creating tasks
            assert false;
        }
    }

}
```
###### /src/main/java/jfdi/logic/commands/AliasCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.AliasDoneEvent;
import jfdi.logic.events.AliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

/**
 * @author Liu Xinan
 */
public class AliasCommand extends Command {

    private String command;
    private String alias;
    private boolean isValid;

    private AliasCommand(Builder builder) {
        this.command = builder.command;
        this.alias = builder.alias;
        this.isValid = builder.isValid;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

    public boolean isValid() {
        return isValid;
    }

    public static class Builder {

        String command;
        String alias;
        boolean isValid;

        public Builder setCommand(String command) {
            this.command = command;
            return this;
        }

        public Builder setAlias(String alias) {
            this.alias = alias;
            return this;
        }

        public Builder setIsValid(boolean isValid) {
            this.isValid = isValid;
            return this;
        }

        public AliasCommand build() {
            return new AliasCommand(this);
        }

    }

    @Override
    public void execute() {
        AliasAttributes newAlias = new AliasAttributes(alias, command);
        try {
            newAlias.save();
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new AliasDoneEvent(command, alias));
        } catch (InvalidAliasParametersException e) {
            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.INVALID_PARAMETERS));
        } catch (DuplicateAliasException e) {
            eventBus.post(new AliasFailedEvent(command, alias, AliasFailedEvent.Error.DUPLICATED_ALIAS));
        }
    }

    @Override
    public void undo() {
        try {
            aliasDb.destroy(alias);
            parser.setAliases(aliasDb.getAll());

            pushToRedoStack();
        } catch (InvalidAliasException e) {
            // Should not happen
            assert false;
        }
    }

}
```
###### /src/main/java/jfdi/logic/commands/DeleteTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.logic.events.DeleteTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class DeleteTaskCommand extends Command {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> deletedTasks;

    private DeleteTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getDeletedTasks() {
        return deletedTasks;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public DeleteTaskCommand build() {
            return new DeleteTaskCommand(this);
        }

    }



    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            deletedTasks = new ArrayList<>();
            taskIds.forEach(id -> {
                try {
                    deletedTasks.add(taskDb.getById(id));
                    logger.info("Deleting task #" + id);
                    taskDb.destroy(id);
                } catch (InvalidIdException e) {
                    // Should not happen
                assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new DeleteTaskDoneEvent(screenIds, deletedTasks));
        } else {
            eventBus.post(new DeleteTaskFailedEvent(invalidIds));
        }
    }

    @Override
    public void undo() {
        deletedTasks.stream().forEach(task -> {
            try {
                taskDb.undestroy(task.getId());
            } catch (InvalidIdException | DuplicateTaskException e) {
                assert false;
            }
        });

        pushToRedoStack();
    }
}
```
###### /src/main/java/jfdi/logic/commands/DirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ShowDirectoryEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class DirectoryCommand extends Command {

    private DirectoryCommand(Builder builder) {}

    public static class Builder {

        public DirectoryCommand build() {
            return new DirectoryCommand(this);
        }

    }

    @Override
    public void execute() {
        String pwd = mainStorage.getCurrentDirectory();
        eventBus.post(new ShowDirectoryEvent(pwd));
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/ExitCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ExitCalledEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class ExitCommand extends Command {

    private ExitCommand(Builder builder) {}

    public static class Builder {

        public ExitCommand build() {
            return new ExitCommand(this);
        }

    }

    @Override
    public void execute() {
        // Nothing needs to be done.
        // Post an event to notify UI to exit.
        eventBus.post(new ExitCalledEvent());
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/HelpCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.HelpRequestedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class HelpCommand extends Command {

    private HelpCommand(Builder builder) {}

    public static class Builder {

        public HelpCommand build() {
            return new HelpCommand(this);
        }

    }

    @Override
    public void execute() {
        eventBus.post(new HelpRequestedEvent());
    }

    @Override
    public void undo() {
        assert false;
    }
}
```
###### /src/main/java/jfdi/logic/commands/InvalidCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.logic.interfaces.Command;
import jfdi.parser.Constants.CommandType;

import java.util.Optional;

/**
 * @author Liu Xinan
 */
public class InvalidCommand extends Command {

    private String inputString;
    private CommandType commandType;
    private String suggestion;

    private InvalidCommand(Builder builder) {
        this.inputString = builder.inputString;
        this.commandType = builder.commandType;
        this.suggestion = builder.suggestion;
    }

    public static class Builder {

        String inputString = "";
        CommandType commandType = null;
        String suggestion = "";

        public Builder setInputString(String inputString) {
            this.inputString = inputString;
            return this;
        }

        public Builder setCommandType(CommandType commandType) {
            this.commandType = commandType;
            return this;
        }

        public Builder setSuggestion(String suggestion) {
            this.suggestion = suggestion;
            return this;
        }

        public InvalidCommand build() {
            return new InvalidCommand(this);
        }

    }

    @Override
    public void execute() {
        // Invalid command always fail.
        setLastSuggestion(Optional.of(suggestion));
        eventBus.post(new InvalidCommandEvent(inputString, commandType, suggestion));
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/ListCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.ListDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ListCommand extends Command {

    public enum ListType {
        ALL,
        COMPLETED,
        INCOMPLETE,
        ALIASES,
        OVERDUE,
        UPCOMING
    }

    private ListType listType;

    private ListCommand(Builder builder) {
        this.listType = builder.listType;
    }

    public static class Builder {

        ListType listType;

        public Builder setListType(ListType listType) {
            this.listType = listType;
            return this;
        }

        public ListCommand build() {
            return new ListCommand(this);
        }
    }

    public ListType getListType() {
        return this.listType;
    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> tasks = taskDb.getAll().stream()
            .collect(Collectors.toCollection(ArrayList::new));

        switch (listType) {
            case ALL:
                break;
            case COMPLETED:
                tasks = tasks.stream().filter(TaskAttributes::isCompleted)
                    .collect(Collectors.toCollection(ArrayList::new));
                break;
            case INCOMPLETE:
                tasks = tasks.stream().filter(task -> !task.isCompleted())
                    .collect(Collectors.toCollection(ArrayList::new));
                break;
            case ALIASES:
                break;
            case OVERDUE:
                tasks = taskDb.getOverdue().stream()
                    .sorted()
                    .collect(Collectors.toCollection(ArrayList::new));
                break;
            case UPCOMING:
                tasks = taskDb.getUpcoming().stream()
                    .sorted()
                    .collect(Collectors.toCollection(ArrayList::new));
                break;
            default:
                break;
        }
        eventBus.post(new ListDoneEvent(listType, tasks));
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/MarkTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.logic.events.MarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class MarkTaskCommand extends Command {

    private static final Logger LOGGER = JfdiLogger.getLogger();

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> markedIds;

    private MarkTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addTaskId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addTaskIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public MarkTaskCommand build() {
            return new MarkTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            ArrayList<TaskAttributes> markedTasks = new ArrayList<>();
            markedIds = new ArrayList<>();
            taskIds.stream().forEach(id -> {
                try {
                    markedTasks.add(taskDb.getById(id));
                    taskDb.markAsComplete(id);
                    markedIds.add(id);
                } catch (NoAttributesChangedException e) {
                    LOGGER.warning("Task " + id + " is already completed.");
                } catch (InvalidIdException e) {
                    // Should not happen!
                assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new MarkTaskDoneEvent(screenIds, markedTasks));
        } else {
            eventBus.post(new MarkTaskFailedEvent(screenIds, invalidIds));
        }
    }

    @Override
    public void undo() {
        markedIds.stream().forEach(id -> {
            try {
                taskDb.markAsIncomplete(id);
            } catch (NoAttributesChangedException | InvalidIdException e) {
                assert false;
            }
        });

        pushToRedoStack();
    }
}
```
###### /src/main/java/jfdi/logic/commands/MoveDirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.MoveDirectoryDoneEvent;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryCommand extends Command {

    private String oldDirectory;
    private String newDirectory;

    private MoveDirectoryCommand(Builder builder) {
        this.newDirectory = builder.newDirectory;
    }

    public static class Builder {

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
            this.newDirectory = newDirectory;
            return this;
        }

        public MoveDirectoryCommand build() {
            return new MoveDirectoryCommand(this);
        }

    }

    public String getNewDirectory() {
        return newDirectory;
    }

    @Override
    public void execute() {
        try {
            oldDirectory = mainStorage.getCurrentDirectory();

            mainStorage.changeDirectory(newDirectory);

            pushToUndoStack();
            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));
        } catch (FilesReplacedException e) {
            eventBus.post(new MoveDirectoryDoneEvent(newDirectory));
            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            eventBus.post(new MoveDirectoryFailedEvent(newDirectory, MoveDirectoryFailedEvent.Error.INVALID_PATH));
        }
    }

    @Override
    public void undo() {
        try {
            mainStorage.changeDirectory(oldDirectory);

            pushToRedoStack();
        } catch (InvalidFilePathException e) {
            assert false;
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(oldDirectory, e.getReplacedFilePairs()));
        }
    }
}
```
###### /src/main/java/jfdi/logic/commands/NoCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.NoThanksEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class NoCommand extends Command {

    @Override
    public void execute() {
        eventBus.post(new NoThanksEvent());
    }

    @Override
    public void undo() {
        assert false;
    }
}
```
###### /src/main/java/jfdi/logic/commands/RedoCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.CommandRedoneEvent;
import jfdi.logic.events.RedoFailedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class RedoCommand extends Command {

    private RedoCommand(Builder builder) {}

    public static class Builder {

        public RedoCommand build() {
            return new RedoCommand(this);
        }

    }

    @Override
    public void execute() {
        if (!redoStack.empty()) {
            setRedoing(true);

            Command lastRedoableCommand = redoStack.pop();
            lastRedoableCommand.execute();

            setRedoing(false);

            eventBus.post(new CommandRedoneEvent(lastRedoableCommand.getClass()));
        } else {
            eventBus.post(new RedoFailedEvent(RedoFailedEvent.Error.NONTHING_TO_REDO));
        }
    }

    @Override
    public void undo() {
        throw new UnsupportedOperationException();
    }

}
```
###### /src/main/java/jfdi/logic/commands/RenameTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.logic.events.RenameTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

/**
 * @author Liu Xinan
 */
public class RenameTaskCommand extends Command {

    private int screenId;
    private String description;
    private String oldDescription;

    private RenameTaskCommand(Builder builder) {
        this.screenId = builder.screenId;
        this.description = builder.description;
    }

    public int getScreenId() {
        return screenId;
    }

    public String getDescription() {
        return description;
    }

    public static class Builder {

        int screenId = -1;
        String description;

        public Builder setId(int screenId) {
            this.screenId = screenId;
            return this;
        }

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public RenameTaskCommand build() {
            if (screenId == -1) {
                throw new IllegalStateException("You must set the task ID for rename!");
            }
            return new RenameTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);
            oldDescription = task.getDescription();

            task.setDescription(description);
            task.save();

            pushToUndoStack();
            eventBus.post(new RenameTaskDoneEvent(task));
        } catch (InvalidIdException e) {
            eventBus
                .post(new RenameTaskFailedEvent(screenId, description, RenameTaskFailedEvent.Error.NON_EXISTENT_ID));
        } catch (InvalidTaskParametersException e) {
            // Should not happen
            assert false;
        } catch (NoAttributesChangedException e) {
            eventBus.post(new RenameTaskFailedEvent(screenId, description, RenameTaskFailedEvent.Error.NO_CHANGES));
        } catch (DuplicateTaskException e) {
            eventBus
                .post(new RenameTaskFailedEvent(screenId, description, RenameTaskFailedEvent.Error.DUPLICATED_TASK));
        }
    }

    @Override
    public void undo() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            task.setDescription(oldDescription);
            task.save();

            pushToRedoStack();
        } catch (InvalidIdException | NoAttributesChangedException | InvalidTaskParametersException
            | DuplicateTaskException e) {
            assert false;
        }
    }
}
```
###### /src/main/java/jfdi/logic/commands/RescheduleTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.logic.events.RescheduleTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.DuplicateTaskException;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.InvalidTaskParametersException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.time.Duration;
import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskCommand extends Command {

    private int screenId;
    private boolean isShiftedDateSpecified;
    private boolean isShiftedTimeSpecified;
    private LocalDateTime shiftedDateTime;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime oldStartDateTime;
    private LocalDateTime oldEndDateTime;

    private RescheduleTaskCommand(Builder builder) {
        this.screenId = builder.screenId;
        this.isShiftedDateSpecified = builder.isShiftedDateSpecified;
        this.isShiftedTimeSpecified = builder.isShiftedTimeSpecified;
        this.shiftedDateTime = builder.shiftedDateTime;
        this.startDateTime = builder.startDateTime;
        this.endDateTime = builder.endDateTime;
    }

    public int getScreenId() {
        return screenId;
    }

    public boolean isShiftedDateSpecified() {
        return isShiftedDateSpecified;
    }

    public boolean isShiftedTimeSpecified() {
        return isShiftedTimeSpecified;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public static class Builder {

        int screenId;
        boolean isShiftedDateSpecified = false;
        boolean isShiftedTimeSpecified = false;
        LocalDateTime shiftedDateTime;
        LocalDateTime startDateTime;
        LocalDateTime endDateTime;

        public Builder setId(int screenId) {
            this.screenId = screenId;
            return this;
        }

        public Builder setShiftedDateSpecified(boolean isShiftedDateSpecified) {
            this.isShiftedDateSpecified = isShiftedDateSpecified;
            return this;
        }

        public Builder setShiftedTimeSpecified(boolean isShiftedTimeSpecified) {
            this.isShiftedTimeSpecified = isShiftedTimeSpecified;
            return this;
        }

        public Builder setShiftedDateTime(LocalDateTime shiftedDateTime) {
            this.shiftedDateTime = shiftedDateTime;
            return this;
        }

        public Builder setStartDateTime(LocalDateTime startDateTime) {
            this.startDateTime = startDateTime;
            return this;
        }

        public Builder setEndDateTime(LocalDateTime endDateTime) {
            this.endDateTime = endDateTime;
            return this;
        }

        public RescheduleTaskCommand build() {
            return new RescheduleTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            oldStartDateTime = task.getStartDateTime();
            oldEndDateTime = task.getEndDateTime();

            if (shiftedDateTime != null) {
                shiftStartAndEndDateTimes(task);
            }

            task.setStartDateTime(startDateTime);
            task.setEndDateTime(endDateTime);
            task.save();

            pushToUndoStack();
            eventBus.post(new RescheduleTaskDoneEvent(task));
        } catch (InvalidIdException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID));
        } catch (InvalidTaskParametersException e) {
            // Should not happen
            assert false;
        } catch (NoAttributesChangedException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.NO_CHANGES));
        } catch (DuplicateTaskException e) {
            eventBus.post(new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime,
                RescheduleTaskFailedEvent.Error.DUPLICATED_TASK));
        }
    }

    @Override
    public void undo() {
        int taskId = ui.getTaskId(screenId);

        try {
            TaskAttributes task = taskDb.getById(taskId);

            task.setStartDateTime(oldStartDateTime);
            task.setEndDateTime(oldEndDateTime);
            task.save();

            pushToRedoStack();
        } catch (InvalidIdException | InvalidTaskParametersException | NoAttributesChangedException
            | DuplicateTaskException e) {
            assert false;
        }
    }

    private void shiftStartAndEndDateTimes(TaskAttributes task) {
        assert shiftedDateTime != null;
        assert isShiftedDateSpecified || isShiftedTimeSpecified;
        LocalDateTime taskStart = task.getStartDateTime();
        LocalDateTime taskEnd = task.getEndDateTime();

        if (taskStart == null && taskEnd == null) {
            // Set floating task to point task
            startDateTime = shiftedDateTime;
            endDateTime = null;

        } else if (taskStart != null && taskEnd == null) {
            // Shift point task
            startDateTime = getShiftedDateTime(task.getStartDateTime());
            endDateTime = null;

        } else if (taskStart == null && taskEnd != null) {
            // Shift deadline task
            startDateTime = null;
            endDateTime = getShiftedDateTime(task.getEndDateTime());

        } else {
            // Shift event, preserving duration
            Duration eventDuration = Duration.between(taskStart, taskEnd);
            startDateTime = getShiftedDateTime(task.getStartDateTime());
            endDateTime = startDateTime.plus(eventDuration);
        }
    }

    public LocalDateTime getShiftedDateTime() {
        return shiftedDateTime;
    }

    private LocalDateTime getShiftedDateTime(LocalDateTime dateTime) {
        if (isShiftedDateSpecified && isShiftedTimeSpecified) {
            return shiftedDateTime;
        } else if (isShiftedDateSpecified && !isShiftedTimeSpecified) {
            return shiftDate(dateTime);
        } else if (!isShiftedDateSpecified && isShiftedTimeSpecified) {
            return shiftTime(dateTime);
        }
        assert false;
        return null;
    }

    private LocalDateTime shiftTime(LocalDateTime originalDateTime) {
        assert originalDateTime != null && shiftedDateTime != null;
        return LocalDateTime.of(originalDateTime.toLocalDate(), shiftedDateTime.toLocalTime());
    }

    private LocalDateTime shiftDate(LocalDateTime originalDateTime) {
        assert originalDateTime != null && shiftedDateTime != null;
        return LocalDateTime.of(shiftedDateTime.toLocalDate(), originalDateTime.toLocalTime());
    }

}
```
###### /src/main/java/jfdi/logic/commands/SearchCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class SearchCommand extends Command {

    private HashSet<String> keywords;

    private SearchCommand(Builder builder) {
        this.keywords = builder.keywords;
    }

    public HashSet<String> getKeywords() {
        return keywords;
    }

    public static class Builder {

        HashSet<String> keywords = new HashSet<>();

        public Builder addKeyword(String keyword) {
            this.keywords.add(keyword);
            return this;
        }

        public Builder addKeywords(Collection<String> keywords) {
            this.keywords.addAll(keywords);
            return this;
        }

        public SearchCommand build() {
            return new SearchCommand(this);
        }

    }

    @Override
    public void execute() {
        Collection<TaskAttributes> allTasks = taskDb.getAll();
        ArrayList<TaskAttributes> results = allTasks.stream().filter(task -> {
            for (String keyword : keywords) {
                if (!task.getDescription().matches(String.format("(?i:.*\\b%s\\b.*)", keyword))) {
                    return false;
                }
            }
            return true;
        }).collect(Collectors.toCollection(ArrayList::new));
        eventBus.post(new SearchDoneEvent(results, keywords));
        System.out.println(results);
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/UnaliasCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.UnaliasDoneEvent;
import jfdi.logic.events.UnaliasFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.exceptions.DuplicateAliasException;
import jfdi.storage.exceptions.InvalidAliasException;
import jfdi.storage.exceptions.InvalidAliasParametersException;

/**
 * @author Liu Xinan
 */
public class UnaliasCommand extends Command {

    private String alias;
    private String command;

    private UnaliasCommand(Builder builder) {
        this.alias = builder.alias;
    }

    public String getAlias() {
        return alias;
    }

    public static class Builder {

        String alias;

        public Builder setAlias(String alias) {
            this.alias = alias;
            return this;
        }

        public UnaliasCommand build() {
            return new UnaliasCommand(this);
        }

    }

    @Override
    public void execute() {
        try {
            command = aliasDb.getCommandFromAlias(alias);

            aliasDb.destroy(alias);
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new UnaliasDoneEvent(alias));
        } catch (InvalidAliasException e) {
            eventBus.post(new UnaliasFailedEvent(alias, UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS));
        }
    }

    @Override
    public void undo() {
        try {
            AliasAttributes oldAlias = new AliasAttributes(alias, command);
            oldAlias.save();
            parser.setAliases(aliasDb.getAll());

            pushToRedoStack();
        } catch (InvalidAliasParametersException | DuplicateAliasException e) {
            assert false;
        }
    }

}
```
###### /src/main/java/jfdi/logic/commands/UndoCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.CommandUndoneEvent;
import jfdi.logic.events.UndoFailedEvent;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class UndoCommand extends Command {

    private UndoCommand(Builder builder) {}

    public static class Builder {

        public UndoCommand build() {
            return new UndoCommand(this);
        }

    }

    @Override
    public void execute() {
        if (!undoStack.empty()) {
            Command lastUndoableCommand = undoStack.pop();
            lastUndoableCommand.undo();

            eventBus.post(new CommandUndoneEvent(lastUndoableCommand.getClass()));
        } else {
            eventBus.post(new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO));
        }
    }

    @Override
    public void undo() {
        assert false;
    }

}
```
###### /src/main/java/jfdi/logic/commands/UnmarkTaskCommand.java
``` java

package jfdi.logic.commands;

import jfdi.common.utilities.JfdiLogger;
import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.logic.events.UnmarkTaskFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.exceptions.InvalidIdException;
import jfdi.storage.exceptions.NoAttributesChangedException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskCommand extends Command {

    private static final Logger LOGGER = JfdiLogger.getLogger();

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> unmarkedIds;

    private UnmarkTaskCommand(Builder builder) {
        this.screenIds = builder.screenIds;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public static class Builder {

        ArrayList<Integer> screenIds = new ArrayList<>();

        public Builder addTaskId(int id) {
            screenIds.add(id);
            return this;
        }

        public Builder addTaskIds(Collection<Integer> ids) {
            screenIds.addAll(ids);
            return this;
        }

        public UnmarkTaskCommand build() {
            return new UnmarkTaskCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<Integer> taskIds = screenIds.stream().map(ui::getTaskId)
            .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Integer> invalidIds = screenIds.stream()
            .filter(id -> !taskDb.hasId(ui.getTaskId(id)))
            .collect(Collectors.toCollection(ArrayList::new));

        if (invalidIds.isEmpty()) {
            ArrayList<TaskAttributes> unmarkedTasks = new ArrayList<>();
            unmarkedIds = new ArrayList<>();
            taskIds.stream().forEach(id -> {
                try {
                    unmarkedTasks.add(taskDb.getById(id));
                    taskDb.markAsIncomplete(id);

                    unmarkedIds.add(id);
                } catch (NoAttributesChangedException e) {
                    LOGGER.warning("Task " + id + " was not completed.");
                } catch (InvalidIdException e) {
                    assert false;
                }
            });

            pushToUndoStack();
            eventBus.post(new UnmarkTaskDoneEvent(screenIds, unmarkedTasks));
        } else {
            eventBus.post(new UnmarkTaskFailedEvent(screenIds, invalidIds));
        }
    }

    @Override
    public void undo() {
        unmarkedIds.stream().forEach(id -> {
            try {
                taskDb.markAsComplete(id);

                pushToRedoStack();
            } catch (NoAttributesChangedException | InvalidIdException e) {
                assert false;
            }
        });
    }

}
```
###### /src/main/java/jfdi/logic/commands/UseDirectoryCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.MoveDirectoryFailedEvent;
import jfdi.logic.events.UseDirectoryDoneEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;

/**
 * @author Liu Xinan
 */
public class UseDirectoryCommand extends Command {

    private String oldDirectory;
    private String newDirectory;

    private UseDirectoryCommand(Builder builder) {
        this.newDirectory = builder.newDirectory;
    }

    public static class Builder {

        String newDirectory;

        public Builder setNewDirectory(String newDirectory) {
            this.newDirectory = newDirectory;
            return this;
        }

        public UseDirectoryCommand build() {
            return new UseDirectoryCommand(this);
        }

    }

    public String getNewDirectory() {
        return newDirectory;
    }

    @Override
    public void execute() {
        try {
            oldDirectory = mainStorage.getCurrentDirectory();

            mainStorage.use(newDirectory);
            parser.setAliases(aliasDb.getAll());

            pushToUndoStack();
            eventBus.post(new UseDirectoryDoneEvent(newDirectory));
        } catch (FilesReplacedException e) {
            eventBus.post(new UseDirectoryDoneEvent(newDirectory));
            eventBus.post(new FilesReplacedEvent(newDirectory, e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            eventBus.post(new MoveDirectoryFailedEvent(newDirectory, MoveDirectoryFailedEvent.Error.INVALID_PATH));
        }
    }

    @Override
    public void undo() {
        try {
            mainStorage.use(oldDirectory);
            parser.setAliases(aliasDb.getAll());

            pushToRedoStack();
        } catch (InvalidFilePathException | FilesReplacedException e) {
            assert false;
        }
    }
}
```
###### /src/main/java/jfdi/logic/commands/WildcardCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.events.NoSurpriseEvent;
import jfdi.logic.events.SurpriseEvent;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class WildcardCommand extends Command {

    private WildcardCommand(Builder builder) {}

    public static class Builder {

        public WildcardCommand build() {
            return new WildcardCommand(this);
        }

    }

    @Override
    public void execute() {
        ArrayList<TaskAttributes> incompleteTasks = taskDb.getAll().stream()
                .filter(task -> !task.isCompleted() && task.getStartDateTime() == null)
                .collect(Collectors.toCollection(ArrayList::new));

        SecureRandom random = new SecureRandom();

        if (!incompleteTasks.isEmpty()) {
            TaskAttributes lucky = incompleteTasks.get(random.nextInt(incompleteTasks.size()));
            eventBus.post(new SurpriseEvent(lucky));
        } else {
            eventBus.post(new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS));
        }
    }

    @Override
    public void undo() {
        throw new UnsupportedOperationException();
    }
}
```
###### /src/main/java/jfdi/logic/commands/YesCommand.java
``` java

package jfdi.logic.commands;

import jfdi.logic.ControlCenter;
import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class YesCommand extends Command {

    @Override
    public void execute() {
        ControlCenter cc = ControlCenter.getInstance();
        getLastSuggestion().ifPresent(cc::handleInput);
    }

    @Override
    public void undo() {
        assert false;
    }
}
```
###### /src/main/java/jfdi/logic/ControlCenter.java
``` java

package jfdi.logic;

import com.google.common.eventbus.EventBus;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.events.FilesReplacedEvent;
import jfdi.logic.events.InitializationFailedEvent;
import jfdi.logic.interfaces.Command;
import jfdi.logic.interfaces.ILogic;
import jfdi.parser.InputParser;
import jfdi.parser.exceptions.InvalidInputException;
import jfdi.storage.apis.*;
import jfdi.storage.exceptions.FilesReplacedException;
import jfdi.storage.exceptions.InvalidFilePathException;
import jfdi.ui.UI;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class ControlCenter implements ILogic {

    private static ControlCenter ourInstance = new ControlCenter();

    private final EventBus eventBus = UI.getEventBus();

    private MainStorage mainStorage = MainStorage.getInstance();
    private TaskDb taskDb = TaskDb.getInstance();
    private AliasDb aliasDb = AliasDb.getInstance();

    private InputParser parser = InputParser.getInstance();

    private ControlCenter() {
        initStorage();
        initParser();
    }

    public static ControlCenter getInstance() {
        return ourInstance;
    }

    @Override
    public void handleInput(String input) {
        Command command;
        try {
            command = parser.parse(input);
        } catch (InvalidInputException e) {
            command = new InvalidCommand.Builder().build();
        }
        command.execute();

        if (!(command instanceof InvalidCommand)) {
            Command.setLastSuggestion(Optional.empty());
        }
    }

    @Override
    public TreeSet<String> getKeywords() {
        TreeSet<String> keywords = Arrays.stream(InputParser.getInstance()
            .getAllCommandRegexes()
            .replaceAll("\\W+", " ").split("\\s+"))
            .filter(part -> part.length() > 1)
            .collect(Collectors.toCollection(TreeSet::new));

        AliasDb.getInstance()
            .getAll().stream()
            .map(AliasAttributes::getAlias)
            .forEach(keywords::add);

        return keywords;
    }

    @Override
    public ArrayList<TaskAttributes> getIncompleteTasks() {
        return taskDb.getAll().stream()
            .filter(task -> !task.isCompleted())
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getCompletedTasks() {
        return taskDb.getAll().stream()
            .filter(TaskAttributes::isCompleted)
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getAllTasks() {
        return taskDb.getAll().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getUpcomingTasks() {
        return taskDb.getUpcoming().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    @Override
    public ArrayList<TaskAttributes> getOverdueTasks() {
        return taskDb.getOverdue().stream()
            .collect(Collectors.toCollection(ArrayList::new));
    }

    private void initStorage() {
        // Set a list of permitted commands that can be aliased
        AliasAttributes.setCommandRegex(parser.getAllCommandRegexes());
        try {
            mainStorage.initialize();
        } catch (FilesReplacedException e) {
            eventBus.post(new FilesReplacedEvent(e.getReplacedFilePairs()));
        } catch (InvalidFilePathException e) {
            eventBus.post(new InitializationFailedEvent(InitializationFailedEvent.Error.INVALID_PATH,
                e.getPath()));
        }
    }

    private void initParser() {
        parser.setAliases(aliasDb.getAll());
    }

    //================================================================
    // List of setters for testing.
    //================================================================

    public void setParser(InputParser parser) {
        this.parser = parser;
    }

    public void setMainStorage(MainStorage mainStorage) {
        this.mainStorage = mainStorage;
    }

    public void setTaskDb(TaskDb taskDb) {
        this.taskDb = taskDb;
    }

    public void setAliasDb(AliasDb aliasDb) {
        this.aliasDb = aliasDb;
    }
}
```
###### /src/main/java/jfdi/logic/events/AddTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class AddTaskDoneEvent {

    private TaskAttributes task;

    public AddTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }
}
```
###### /src/main/java/jfdi/logic/events/AddTaskFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AddTaskFailedEvent {

    public enum Error {
        EMPTY_DESCRIPTION, DUPLICATED_TASK
    }

    private Error error;

    public AddTaskFailedEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/AliasDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasDoneEvent {

    private String command;
    private String alias;

    public AliasDoneEvent(String command, String alias) {
        this.command = command;
        this.alias = alias;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### /src/main/java/jfdi/logic/events/AliasFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class AliasFailedEvent {

    public enum Error {
        INVALID_PARAMETERS, DUPLICATED_ALIAS, UNKNOWN
    }

    private String command;
    private String alias;
    private Error error;

    public AliasFailedEvent(String command, String alias, Error error) {
        this.command = command;
        this.alias = alias;
        this.error = error;
    }

    public String getCommand() {
        return command;
    }

    public String getAlias() {
        return alias;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/CommandRedoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandRedoneEvent {

    private Class<? extends Command> commandType;

    public CommandRedoneEvent(Class<? extends Command> commandType) {
        this.commandType = commandType;
    }

    public Class<? extends Command> getCommandType() {
        return commandType;
    }

}
```
###### /src/main/java/jfdi/logic/events/CommandUndoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.interfaces.Command;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEvent {

    private Class<? extends Command> commandType;

    public CommandUndoneEvent(Class<? extends Command> commandType) {
        this.commandType = commandType;
    }

    public Class<? extends Command> getCommandType() {
        return commandType;
    }

}
```
###### /src/main/java/jfdi/logic/events/DeleteTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskDoneEvent {

    private ArrayList<Integer> deletedIds;
    private ArrayList<TaskAttributes> deletedTasks;

    public DeleteTaskDoneEvent(ArrayList<Integer> deletedIds, ArrayList<TaskAttributes> deletedTasks) {
        this.deletedIds = deletedIds;
        this.deletedTasks = deletedTasks;
    }

    public ArrayList<Integer> getDeletedIds() {
        return deletedIds;
    }

    public ArrayList<TaskAttributes> getDeletedTasks() {
        return deletedTasks;
    }
}
```
###### /src/main/java/jfdi/logic/events/DeleteTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> invalidIds;
    private Error error;

    public DeleteTaskFailedEvent(ArrayList<Integer> invalidIds) {
        error = Error.NON_EXISTENT_ID;
        this.invalidIds = invalidIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/ExitCalledEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ExitCalledEvent {
}
```
###### /src/main/java/jfdi/logic/events/FilesReplacedEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.exceptions.FilePathPair;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEvent {

    private String newDirectory = null;
    private ArrayList<FilePathPair> filePathPairs;

    public FilesReplacedEvent(ArrayList<FilePathPair> filePathPairs) {
        this.filePathPairs = filePathPairs;
    }

    public FilesReplacedEvent(String newDirectory, ArrayList<FilePathPair> filePathPairs) {
        this.newDirectory = newDirectory;
        this.filePathPairs = filePathPairs;
    }

    public ArrayList<FilePathPair> getFilePathPairs() {
        return filePathPairs;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### /src/main/java/jfdi/logic/events/HelpRequestedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class HelpRequestedEvent {
}
```
###### /src/main/java/jfdi/logic/events/InitializationFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private Error error;
    private String path;

    public InitializationFailedEvent(Error error, String path) {
        this.error = error;
        this.path = path;
    }

    public Error getError() {
        return error;
    }

    public String getPath() {
        return path;
    }

}
```
###### /src/main/java/jfdi/logic/events/InvalidCommandEvent.java
``` java

package jfdi.logic.events;

import jfdi.parser.Constants.CommandType;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEvent {

    private String inputString;
    private CommandType commandType;
    private String suggestion;

    public InvalidCommandEvent(String inputString, CommandType commandType, String suggestion) {
        this.inputString = inputString;
        this.commandType = commandType;
        this.suggestion = suggestion;
    }

    public String getInputString() {
        return inputString;
    }

    public CommandType getCommandType() {
        return commandType;
    }

    public String getSuggestion() {
        return suggestion;
    }

}
```
###### /src/main/java/jfdi/logic/events/ListDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.logic.commands.ListCommand.ListType;
import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class ListDoneEvent {

    private ListType listType;
    private ArrayList<TaskAttributes> items;

    public ListDoneEvent(ListType listType, ArrayList<TaskAttributes> items) {
        this.listType = listType;
        this.items = items;
    }

    public ArrayList<TaskAttributes> getItems() {
        return items;
    }

    public ListType getListType() {
        return listType;
    }
}
```
###### /src/main/java/jfdi/logic/events/MarkTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEvent {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> markedTasks;

    public MarkTaskDoneEvent(ArrayList<Integer> screenIds, ArrayList<TaskAttributes> markedTasks) {
        this.screenIds = screenIds;
        this.markedTasks = markedTasks;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getMarkedTasks() {
        return markedTasks;
    }

}
```
###### /src/main/java/jfdi/logic/events/MarkTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> invalidIds;
    private Error error;

    public MarkTaskFailedEvent(ArrayList<Integer> screenIds, ArrayList<Integer> invalidIds) {
        this.screenIds = screenIds;
        this.invalidIds = invalidIds;
        this.error = Error.NON_EXISTENT_ID;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/MoveDirectoryDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEvent {

    private String newDirectory;

    public MoveDirectoryDoneEvent(String newDirectory) {
        this.newDirectory = newDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### /src/main/java/jfdi/logic/events/MoveDirectoryFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private String newDirectory;
    private Error error;

    public MoveDirectoryFailedEvent(String newDirectory, Error error) {
        this.newDirectory = newDirectory;
        this.error = error;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/NoSurpriseEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEvent {

    public enum Error {
        NO_TASKS, UNKNOWN
    }

    private Error error;

    public NoSurpriseEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/NoThanksEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class NoThanksEvent {
}
```
###### /src/main/java/jfdi/logic/events/RedoFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class RedoFailedEvent {

    public enum Error {
        NONTHING_TO_REDO, UNKNOWN
    }

    private Error error;

    public RedoFailedEvent(Error error) {

        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/RenameTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEvent {

    private TaskAttributes task;

    public RenameTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }
}
```
###### /src/main/java/jfdi/logic/events/RenameTaskFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID,
        DUPLICATED_TASK,
        NO_CHANGES,
        UNKNOWN
    }

    private int screenId;
    private String description;
    private Error error;

    public RenameTaskFailedEvent(int screenId, String description, Error error) {
        this.screenId = screenId;
        this.description = description;
        this.error = error;
    }

    public int getScreenId() {
        return screenId;
    }

    public String getDescription() {
        return description;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/RescheduleTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEvent {

    private TaskAttributes task;

    public RescheduleTaskDoneEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }

}
```
###### /src/main/java/jfdi/logic/events/RescheduleTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.time.LocalDateTime;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID,
        DUPLICATED_TASK,
        NO_CHANGES,
        UNKNOWN
    }

    private int screenId;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private Error error;

    public RescheduleTaskFailedEvent(int screenId, LocalDateTime startDateTime, LocalDateTime endDateTime,
                                     Error error) {
        this.screenId = screenId;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.error = error;
    }

    public int getScreenId() {
        return screenId;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public Error getError() {
        return error;
    }
}
```
###### /src/main/java/jfdi/logic/events/SearchDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.HashSet;

/**
 * @author Liu Xinan
 */
public class SearchDoneEvent {

    private ArrayList<TaskAttributes> results;
    private HashSet<String> keywords;

    public SearchDoneEvent(ArrayList<TaskAttributes> results, HashSet<String> keywords) {
        this.results = results;
        this.keywords = keywords;
    }

    public ArrayList<TaskAttributes> getResults() {
        return results;
    }

    public HashSet<String> getKeywords() {
        return keywords;
    }

}
```
###### /src/main/java/jfdi/logic/events/ShowDirectoryEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEvent {

    private String pwd;

    public ShowDirectoryEvent(String pwd) {
        this.pwd = pwd;
    }

    public String getPwd() {
        return pwd;
    }

}
```
###### /src/main/java/jfdi/logic/events/SurpriseEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

/**
 * @author Liu Xinan
 */
public class SurpriseEvent {

    private TaskAttributes task;

    public SurpriseEvent(TaskAttributes task) {
        this.task = task;
    }

    public TaskAttributes getTask() {
        return task;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnaliasDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEvent {

    private String alias;

    public UnaliasDoneEvent(String alias) {
        this.alias = alias;
    }

    public String getAlias() {
        return alias;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnaliasFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEvent {

    public enum Error {
        NON_EXISTENT_ALIAS,
        UNKNOWN
    }

    private String alias;
    private Error error;

    public UnaliasFailedEvent(String alias, Error error) {
        this.alias = alias;
        this.error = error;
    }

    public String getAlias() {
        return alias;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/UndoFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UndoFailedEvent {

    public enum Error {
        NONTHING_TO_UNDO, UNKNOWN
    }

    private Error error;

    public UndoFailedEvent(Error error) {
        this.error = error;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnmarkTaskDoneEvent.java
``` java

package jfdi.logic.events;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEvent {

    private ArrayList<Integer> screenIds;
    private ArrayList<TaskAttributes> unmarkedTasks;

    public UnmarkTaskDoneEvent(ArrayList<Integer> screenIds, ArrayList<TaskAttributes> unmarkedTasks) {
        this.screenIds = screenIds;
        this.unmarkedTasks = unmarkedTasks;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<TaskAttributes> getUnmarkedTasks() {
        return unmarkedTasks;
    }

}
```
###### /src/main/java/jfdi/logic/events/UnmarkTaskFailedEvent.java
``` java

package jfdi.logic.events;

import java.util.ArrayList;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEvent {

    public enum Error {
        NON_EXISTENT_ID
    }

    private ArrayList<Integer> screenIds;
    private ArrayList<Integer> invalidIds;
    private Error error;

    public UnmarkTaskFailedEvent(ArrayList<Integer> screenIds, ArrayList<Integer> invalidIds) {
        this.screenIds = screenIds;
        this.invalidIds = invalidIds;
        this.error = Error.NON_EXISTENT_ID;
    }

    public ArrayList<Integer> getScreenIds() {
        return screenIds;
    }

    public ArrayList<Integer> getInvalidIds() {
        return invalidIds;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/events/UseDirectoryDoneEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEvent {

    private String newDirectory;

    public UseDirectoryDoneEvent(String newDirectory) {
        this.newDirectory = newDirectory;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

}
```
###### /src/main/java/jfdi/logic/events/UseDirectoryFailedEvent.java
``` java

package jfdi.logic.events;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEvent {

    public enum Error {
        INVALID_PATH, UNKNOWN
    }

    private String newDirectory;
    private Error error;

    public UseDirectoryFailedEvent(String newDirectory, Error error) {
        this.newDirectory = newDirectory;
        this.error = error;
    }

    public String getNewDirectory() {
        return newDirectory;
    }

    public Error getError() {
        return error;
    }

}
```
###### /src/main/java/jfdi/logic/interfaces/Command.java
``` java

package jfdi.logic.interfaces;

import com.google.common.eventbus.EventBus;
import jfdi.common.utilities.JfdiLogger;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;

import java.util.Optional;
import java.util.Stack;
import java.util.logging.Logger;

/**
 * @author Liu Xinan
 */
public abstract class Command {

    protected static final Logger logger = JfdiLogger.getLogger();
    protected static final EventBus eventBus = UI.getEventBus();

    protected static final Stack<Command> undoStack = new Stack<>();
    protected static final Stack<Command> redoStack = new Stack<>();

    protected static UI ui = UI.getInstance();
    protected static InputParser parser = InputParser.getInstance();
    protected static MainStorage mainStorage = MainStorage.getInstance();
    protected static TaskDb taskDb = TaskDb.getInstance();
    protected static AliasDb aliasDb = AliasDb.getInstance();

    private static boolean redoing = false;
    private static Optional<String> lastSuggestion = Optional.empty();

    /**
     * Executes the command.
     */
    public abstract void execute();

    /**
     * Undoes the command.
     */
    public abstract void undo();

    public static void setRedoing(boolean redo) {
        redoing = redo;
    }

    public static void setLastSuggestion(Optional<String> suggestion) {
        lastSuggestion = suggestion;
    }

    public static Optional<String> getLastSuggestion() {
        return lastSuggestion;
    }

    public void pushToUndoStack() {
        if (!redoing) {
            while (!redoStack.empty()) {
                undoStack.push(redoStack.pop());
            }
        }

        undoStack.push(this);
    }

    public void pushToRedoStack() {
        redoStack.push(this);
    }

    //================================================================
    // List of setters and getters for testing.
    //================================================================


    public static void setUi(UI ui) {
        Command.ui = ui;
    }

    public static void setParser(InputParser parser) {
        Command.parser = parser;
    }

    public static void setMainStorage(MainStorage mainStorage) {
        Command.mainStorage = mainStorage;
    }

    public static void setTaskDb(TaskDb taskDb) {
        Command.taskDb = taskDb;
    }

    public static void setAliasDb(AliasDb aliasDb) {
        Command.aliasDb = aliasDb;
    }

    public static Stack<Command> getUndoStack() {
        return undoStack;
    }

    public static Stack<Command> getRedoStack() {
        return redoStack;
    }

    public static UI getUi() {
        return ui;
    }

    public static InputParser getParser() {
        return parser;
    }

    public static MainStorage getMainStorage() {
        return mainStorage;
    }

    public static TaskDb getTaskDb() {
        return taskDb;
    }

    public static AliasDb getAliasDb() {
        return aliasDb;
    }

    public static boolean isRedoing() {
        return redoing;
    }
}
```
###### /src/main/java/jfdi/logic/interfaces/ILogic.java
``` java

package jfdi.logic.interfaces;

import jfdi.storage.apis.TaskAttributes;

import java.util.ArrayList;
import java.util.TreeSet;

/**
 * @author Liu Xinan
 */
public interface ILogic {

    /**
     * Handles user's input.
     * Called by UI whenever the user inputs a text command.
     *
     * @param input Input from user
     */
    void handleInput(String input);

    /**
     * Gets the list of command keywords.
     * Called by UI for populating auto-completion suggestion list.
     *
     * @return a {@code TreeSet} of {@code String}
     */
    TreeSet<String> getKeywords();

    /**
     * Gets the list of incomplete tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getIncompleteTasks();

    /**
     * Gets the list of completed tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getCompletedTasks();

    /**
     * Gets the list of all tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getAllTasks();

    /**
     * Gets the list of upcoming tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getUpcomingTasks();

    /**
     * Gets the list of overdue tasks.
     *
     * @return a {@code ArrayList} of {@code TaskAttributes}
     */
    ArrayList<TaskAttributes> getOverdueTasks();
}
```
###### /src/main/java/jfdi/ui/AutoCompleteTextField.java
``` java

package jfdi.ui;

import javafx.geometry.Side;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.CustomMenuItem;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

import java.util.LinkedList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * @author Liu Xinan
 */
public class AutoCompleteTextField extends TextField {

    private SortedSet<String> keywords;
    private LinkedList<String> results;

    private ContextMenu popup;

    public AutoCompleteTextField() {
        super();
        keywords = new TreeSet<>(String::compareToIgnoreCase);
        results = new LinkedList<>();
        popup = new ContextMenu();

        textProperty().addListener((observable, oldValue, newValue) -> {
            if (getText().isEmpty()) {
                popup.hide();
                return;
            }
            results.clear();
            results.addAll(keywords.subSet(getText(), getText() + Character.MAX_VALUE));
            if (results.isEmpty()) {
                popup.hide();
            } else {
                populatePopup(results);
            }
        });

        focusedProperty().addListener((observable, oldValue, newValue) -> popup.hide());

        popup.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
            @SuppressWarnings("deprecation")
            boolean isAnyItemSelected = popup.getItems().stream().map(item -> item.impl_styleableGetNode())
                    .anyMatch(node -> node.isFocused());
            if (event.getCode() == KeyCode.ENTER && !isAnyItemSelected) {
                UI.getInstance().triggerEnter();
                results.clear();
            }
        });
    }

    public void setKeywords(SortedSet<String> keywords) {
        this.keywords.clear();
        this.keywords.addAll(keywords);
    }

    public void hidePopup() {
        popup.hide();
    }

    public void selectFirst() {
        if (!results.isEmpty()) {
            select(results.get(0));
            popup.hide();
        }
    }

    private void select(String suggestion) {
        setText(suggestion + " ");
        this.positionCaret(this.getText().length());
    }

    private void populatePopup(LinkedList<String> results) {
        List<CustomMenuItem> menuItems = results.stream()
            .map(Label::new)
            .map(label -> {
                CustomMenuItem menuItem = new CustomMenuItem(label, true);
                menuItem.setOnAction(action -> {
                    select(label.getText());
                    popup.hide();
                });
                return menuItem;
            })
            .collect(Collectors.toCollection(LinkedList::new));

        popup.getItems().setAll(menuItems);

        if (!popup.isShowing()) {
            popup.show(this, Side.BOTTOM, 0, 0);
        }
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/AddTaskCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.TaskAttributes;
import jfdi.storage.apis.TaskDb;
import jfdi.storage.exceptions.InvalidIdException;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.time.LocalDateTime;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AddTaskCommandTest extends CommonCommandTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void testBuilder() throws Exception {
        LocalDateTime startDateTime = LocalDateTime.of(2016, 4, 1, 0, 0);
        LocalDateTime endDateTime = LocalDateTime.of(2016, 4, 1, 23, 59);

        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("test")
            .setStartDateTime(startDateTime)
            .setEndDateTime(endDateTime)
            .build();

        assertEquals("test", command.getDescription());
        assertEquals(startDateTime, command.getStartDateTime().get());
        assertEquals(endDateTime, command.getEndDateTime().get());
    }

    @Test
    public void testExecute_successful() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("sleep")
            .build();

        command.execute();

        int id = command.getId();
        assertNotEquals(-1, id);

        TaskAttributes task = TaskDb.getInstance().getById(id);
        assertEquals("sleep", task.getDescription());

        TaskDb.getInstance().destroy(id);
    }

    @Test
    public void testExecute_emptyDescription() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder().build();

        command.execute();

        assertEquals(-1, command.getId());
    }

    @Test
    public void testExecute_duplicatedTask() throws Exception {
        AddTaskCommand command1 = new AddTaskCommand.Builder()
            .setDescription("duplicate")
            .build();

        command1.execute();

        int id1 = command1.getId();
        assertNotEquals(-1, id1);

        AddTaskCommand command2 = new AddTaskCommand.Builder()
            .setDescription("duplicate")
            .build();

        command2.execute();

        assertEquals(-1, command2.getId());

        TaskDb.getInstance().destroy(id1);
    }

    @Test
    public void testUndo() throws Exception {
        AddTaskCommand command = new AddTaskCommand.Builder()
            .setDescription("undo")
            .build();

        command.execute();

        int id = command.getId();

        Command.setTaskDb(TaskDb.getInstance());
        command.undo();
        Command.setTaskDb(taskDb);

        thrown.expect(InvalidIdException.class);
        TaskDb.getInstance().getById(id);
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/AliasCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.commands.AliasCommand;
import jfdi.logic.interfaces.Command;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.*;
import static org.mockito.Matchers.anyCollectionOf;
import static org.mockito.Mockito.verify;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AliasCommandTest extends CommonCommandTest {

    @Test
    public void testBuilder() throws Exception {
        AliasCommand command1 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        assertEquals("list", command1.getCommand());
        assertEquals("ls", command1.getAlias());
        assertTrue(command1.isValid());

        AliasCommand command2 = new AliasCommand.Builder()
            .setCommand("ls")
            .setAlias("list")
            .setIsValid(false)
            .build();

        assertEquals("ls", command2.getCommand());
        assertEquals("list", command2.getAlias());
        assertFalse(command2.isValid());
    }

    @Test
    public void testExecute_successful() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command.execute();

        String commandString = AliasDb.getInstance().getCommandFromAlias("ls");
        assertEquals("list", commandString);

        AliasDb.getInstance().destroy("ls");
    }

    @Test
    public void testExecute_duplicateAlias() throws Exception {
        AliasCommand command1 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command1.execute();

        int currentUndoStackSize = Command.getUndoStack().size();

        AliasCommand command2 = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command2.execute();

        assertEquals(currentUndoStackSize, Command.getUndoStack().size());

        String commandString = AliasDb.getInstance().getCommandFromAlias("ls");
        assertEquals("list", commandString);

        AliasDb.getInstance().destroy("ls");
    }

    @Test
    public void testExecute_invalidAlias() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("add")
            .setIsValid(true)
            .build();

        int currentUndoStackSize = Command.getUndoStack().size();

        command.execute();

        assertEquals(currentUndoStackSize, Command.getUndoStack().size());
    }

    @Test
    public void testUndo() throws Exception {
        AliasCommand command = new AliasCommand.Builder()
            .setCommand("list")
            .setAlias("ls")
            .setIsValid(true)
            .build();

        command.undo();
        verify(aliasDb).destroy("ls");
        verify(parser).setAliases(anyCollectionOf(AliasAttributes.class));
    }

}
```
###### /src/test/java/jfdi/test/logic/commands/CommonCommandTest.java
``` java

package jfdi.test.logic.commands;

import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasAttributes;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.mockito.Mock;

/**
 * @author Liu Xinan
 */
public abstract class CommonCommandTest {

    @Mock
    protected UI ui;

    @Mock
    protected MainStorage mainStorage;

    @Mock
    protected TaskDb taskDb;

    @Mock
    protected AliasDb aliasDb;

    @Mock
    protected InputParser parser;

    @Before
    public void setUp() throws Exception {
        Command.setUi(ui);
        Command.setMainStorage(mainStorage);
        Command.setTaskDb(taskDb);
        Command.setAliasDb(aliasDb);
        Command.setParser(parser);

        AliasAttributes.setCommandRegex(InputParser.getInstance().getAllCommandRegexes());
        InputParser.getInstance().setAliases(AliasDb.getInstance().getAll());
        MainStorage.getInstance().initialize();
        MainStorage.getInstance().use("./.test_data");
    }

    @After
    public void tearDown() throws Exception {
        Command.setUi(UI.getInstance());
        Command.setMainStorage(MainStorage.getInstance());
        Command.setTaskDb(TaskDb.getInstance());
        Command.setAliasDb(AliasDb.getInstance());
        Command.setParser(InputParser.getInstance());
    }

}
```
###### /src/test/java/jfdi/test/logic/ControlCenterTest.java
``` java

package jfdi.test.logic;

import jfdi.logic.ControlCenter;
import jfdi.logic.commands.ExitCommand;
import jfdi.logic.commands.InvalidCommand;
import jfdi.logic.commands.ListCommand;
import jfdi.parser.InputParser;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Spy;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertSame;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class ControlCenterTest {

    @Spy
    private InputParser parser;

    @Mock
    private ListCommand ls;

    @Mock
    private ExitCommand exit;

    @Mock
    private InvalidCommand lol;

    private ControlCenter cc = ControlCenter.getInstance();

    @Test
    public void testGetInstance() throws Exception {
        assertSame(ControlCenter.getInstance(), ControlCenter.getInstance());
    }

    @Test
    public void testHandleInput() throws Exception {
        cc.setParser(parser);

        when(parser.parse("list")).thenReturn(ls);
        when(parser.parse("lol")).thenReturn(lol);
        when(parser.parse("exit")).thenReturn(exit);

        cc.handleInput("list");
        cc.handleInput("lol");
        cc.handleInput("exit");

        verify(ls).execute();
        verify(lol).execute();
        verify(exit).execute();

        Mockito.reset(parser);
    }

}
```
###### /src/test/java/jfdi/test/logic/events/AddTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AddTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import static org.junit.Assert.assertSame;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class AddTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        AddTaskDoneEvent event = new AddTaskDoneEvent(task);
        assertSame(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/AddTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AddTaskFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */

public class AddTaskFailedEventTest {

    @Test
    public void getError() throws Exception {
        AddTaskFailedEvent event = new AddTaskFailedEvent(AddTaskFailedEvent.Error.EMPTY_DESCRIPTION);
        assertEquals(AddTaskFailedEvent.Error.EMPTY_DESCRIPTION, event.getError());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/AliasDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AliasDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AliasDoneEventTest {

    private static final String COMMAND = "delete";
    private static final String ALIAS = "del";

    @Test
    public void getCommand() throws Exception {
        AliasDoneEvent event = new AliasDoneEvent(COMMAND, ALIAS);
        assertEquals(COMMAND, event.getCommand());
    }

    @Test
    public void getAlias() throws Exception {
        AliasDoneEvent event = new AliasDoneEvent(COMMAND, ALIAS);
        assertEquals(ALIAS, event.getAlias());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/AliasFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.AliasFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class AliasFailedEventTest {

    private AliasFailedEvent event = new AliasFailedEvent("list", "ls", AliasFailedEvent.Error.DUPLICATED_ALIAS);

    @Test
    public void getCommand() throws Exception {
        assertEquals("list", event.getCommand());
    }

    @Test
    public void getAlias() throws Exception {
        assertEquals("ls", event.getAlias());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(AliasFailedEvent.Error.DUPLICATED_ALIAS, event.getError());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/CommandRedoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.AddTaskCommand;
import jfdi.logic.events.CommandRedoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class CommandRedoneEventTest {

    @Test
    public void getCommandType() throws Exception {
        CommandRedoneEvent event = new CommandRedoneEvent(AddTaskCommand.class);
        assertEquals(AddTaskCommand.class, event.getCommandType());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/CommandUndoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.DeleteTaskCommand;
import jfdi.logic.events.CommandUndoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class CommandUndoneEventTest {

    @Test
    public void getCommandType() throws Exception {
        CommandUndoneEvent event = new CommandUndoneEvent(DeleteTaskCommand.class);
        assertEquals(DeleteTaskCommand.class, event.getCommandType());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/DeleteTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.DeleteTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class DeleteTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> deletedIds;

    @Mock
    private ArrayList<TaskAttributes> deletedTasks;

    @Test
    public void getDeletedIds() throws Exception {
        DeleteTaskDoneEvent event = new DeleteTaskDoneEvent(deletedIds, deletedTasks);
        assertEquals(deletedIds, event.getDeletedIds());
    }

    @Test
    public void getDeletedTasks() throws Exception {
        DeleteTaskDoneEvent event = new DeleteTaskDoneEvent(deletedIds, deletedTasks);
        assertEquals(deletedTasks, event.getDeletedTasks());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/DeleteTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.DeleteTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class DeleteTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> invalidIds;

    @Test
    public void getInvalidIds() throws Exception {
        DeleteTaskFailedEvent event = new DeleteTaskFailedEvent(invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        DeleteTaskFailedEvent event1 = new DeleteTaskFailedEvent(invalidIds);
        assertEquals(DeleteTaskFailedEvent.Error.NON_EXISTENT_ID, event1.getError());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/FilesReplacedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.FilesReplacedEvent;
import jfdi.storage.exceptions.FilePathPair;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

/**
 * @author Liu Xinan
 */
public class FilesReplacedEventTest {

    @Mock
    private ArrayList<FilePathPair> filePathPairs;

    private String newDirectory = ".";

    @Test
    public void getFilePathPairs() throws Exception {
        FilesReplacedEvent event1 = new FilesReplacedEvent(filePathPairs);
        assertEquals(filePathPairs, event1.getFilePathPairs());

        FilesReplacedEvent event2 = new FilesReplacedEvent(newDirectory, filePathPairs);
        assertEquals(filePathPairs, event2.getFilePathPairs());
    }

    @Test
    public void getNewDirectory() throws Exception {
        FilesReplacedEvent event1 = new FilesReplacedEvent(filePathPairs);
        assertNull(event1.getNewDirectory());

        FilesReplacedEvent event2 = new FilesReplacedEvent(newDirectory, filePathPairs);
        assertEquals(newDirectory, event2.getNewDirectory());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/InitializationFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.InitializationFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class InitializationFailedEventTest {

    private InitializationFailedEvent.Error error = InitializationFailedEvent.Error.INVALID_PATH;
    private String path = "!@#!@#!@#";

    @Test
    public void getError() throws Exception {
        InitializationFailedEvent event = new InitializationFailedEvent(error, path);
        assertEquals(error, event.getError());
    }

    @Test
    public void getPath() throws Exception {
        InitializationFailedEvent event = new InitializationFailedEvent(error, path);
        assertEquals(path, event.getPath());
    }
}
```
###### /src/test/java/jfdi/test/logic/events/InvalidCommandEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.InvalidCommandEvent;
import jfdi.parser.Constants;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class InvalidCommandEventTest {

    @Test
    public void getInputString() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("WTF", null, null);
        assertEquals("WTF", event.getInputString());
    }

    @Test
    public void getCommandType() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("undo redo", Constants.CommandType.UNDO, "add undo redo");
        assertEquals(Constants.CommandType.UNDO, event.getCommandType());
    }

    @Test
    public void getSuggestion() throws Exception {
        InvalidCommandEvent event = new InvalidCommandEvent("list com", Constants.CommandType.LIST, "list completed");
        assertEquals("list completed", event.getSuggestion());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/ListDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.commands.ListCommand;
import jfdi.logic.events.ListDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class ListDoneEventTest {

    @Mock
    private ListCommand.ListType listType;

    @Mock
    private ArrayList<TaskAttributes> items;

    @Test
    public void getItems() throws Exception {
        ListDoneEvent event = new ListDoneEvent(listType, items);
        assertEquals(items, event.getItems());
    }

    @Test
    public void getListType() throws Exception {
        ListDoneEvent event = new ListDoneEvent(listType, items);
        assertEquals(listType, event.getListType());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MarkTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MarkTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MarkTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<TaskAttributes> markedTasks;

    @Test
    public void getScreenIds() throws Exception {
        MarkTaskDoneEvent event = new MarkTaskDoneEvent(screenIds, markedTasks);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getMarkedTasks() throws Exception {
        MarkTaskDoneEvent event = new MarkTaskDoneEvent(screenIds, markedTasks);
        assertEquals(markedTasks, event.getMarkedTasks());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MarkTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MarkTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MarkTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<Integer> invalidIds;

    private MarkTaskFailedEvent.Error error = MarkTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenIds() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getInvalidIds() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        MarkTaskFailedEvent event = new MarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(error, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MoveDirectoryDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MoveDirectoryDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryDoneEventTest {

    private String newDirectory = ".";

    @Test
    public void getNewDirectory() throws Exception {
        MoveDirectoryDoneEvent event = new MoveDirectoryDoneEvent(newDirectory);
        assertEquals(newDirectory, event.getNewDirectory());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/MoveDirectoryFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.MoveDirectoryFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class MoveDirectoryFailedEventTest {

    private String newDirectory = "!@#!@#$@#$";
    private MoveDirectoryFailedEvent.Error error = MoveDirectoryFailedEvent.Error.INVALID_PATH;

    @Test
    public void getNewDirectory() throws Exception {
        MoveDirectoryFailedEvent event = new MoveDirectoryFailedEvent(newDirectory, error);
        assertEquals(newDirectory, event.getNewDirectory());
    }

    @Test
    public void getError() throws Exception {
        MoveDirectoryFailedEvent event = new MoveDirectoryFailedEvent(newDirectory, error);
        assertEquals(error, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/NoSurpriseEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.NoSurpriseEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class NoSurpriseEventTest {

    @Test
    public void getError() throws Exception {
        NoSurpriseEvent event = new NoSurpriseEvent(NoSurpriseEvent.Error.NO_TASKS);
        assertEquals(NoSurpriseEvent.Error.NO_TASKS, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RedoFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RedoFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RedoFailedEventTest {

    @Test
    public void getError() throws Exception {
        RedoFailedEvent event = new RedoFailedEvent(RedoFailedEvent.Error.NONTHING_TO_REDO);
        assertEquals(RedoFailedEvent.Error.NONTHING_TO_REDO, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RenameTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RenameTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RenameTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        RenameTaskDoneEvent event = new RenameTaskDoneEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RenameTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RenameTaskFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RenameTaskFailedEventTest {

    private int screenId = 666;
    private String description = "Task 666";
    private RenameTaskFailedEvent event = new RenameTaskFailedEvent(screenId, description,
        RenameTaskFailedEvent.Error.DUPLICATED_TASK);

    @Test
    public void getScreenId() throws Exception {
        assertEquals(screenId, event.getScreenId());
    }

    @Test
    public void getDescription() throws Exception {
        assertEquals(description, event.getDescription());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(RenameTaskFailedEvent.Error.DUPLICATED_TASK, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RescheduleTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RescheduleTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskDoneEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        RescheduleTaskDoneEvent event = new RescheduleTaskDoneEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/RescheduleTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.RescheduleTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.time.LocalDateTime;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class RescheduleTaskFailedEventTest {

    @Mock
    private LocalDateTime startDateTime;

    @Mock
    private LocalDateTime endDateTime;

    private int screenId = 666;
    private RescheduleTaskFailedEvent.Error error = RescheduleTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenId() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(screenId, event.getScreenId());
    }

    @Test
    public void getStartDateTime() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(startDateTime, event.getStartDateTime());
    }

    @Test
    public void getEndDateTime() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(endDateTime, event.getEndDateTime());
    }

    @Test
    public void getError() throws Exception {
        RescheduleTaskFailedEvent event = new RescheduleTaskFailedEvent(screenId, startDateTime, endDateTime, error);
        assertEquals(error, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/SearchDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.SearchDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;
import java.util.HashSet;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class SearchDoneEventTest {

    @Mock
    private HashSet<String> keywords;

    @Mock
    private ArrayList<TaskAttributes> results;

    @Test
    public void getResults() throws Exception {
        SearchDoneEvent event = new SearchDoneEvent(results, keywords);
        assertEquals(results, event.getResults());
    }

    @Test
    public void getKeywords() throws Exception {
        SearchDoneEvent event = new SearchDoneEvent(results, keywords);
        assertEquals(keywords, event.getKeywords());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/ShowDirectoryEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.ShowDirectoryEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class ShowDirectoryEventTest {

    private String pwd = "/home/ubuntu/jfdi";

    @Test
    public void getPwd() throws Exception {
        ShowDirectoryEvent event = new ShowDirectoryEvent(pwd);
        assertEquals(pwd, event.getPwd());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/SurpriseEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.SurpriseEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class SurpriseEventTest {

    @Mock
    private TaskAttributes task;

    @Test
    public void getTask() throws Exception {
        SurpriseEvent event = new SurpriseEvent(task);
        assertEquals(task, event.getTask());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnaliasDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnaliasDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnaliasDoneEventTest {

    private String alias = "alias";

    @Test
    public void getAlias() throws Exception {
        UnaliasDoneEvent event = new UnaliasDoneEvent(alias);
        assertEquals(alias, event.getAlias());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnaliasFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnaliasFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnaliasFailedEventTest {

    private String alias = "alias";
    private UnaliasFailedEvent.Error error = UnaliasFailedEvent.Error.NON_EXISTENT_ALIAS;
    private UnaliasFailedEvent event = new UnaliasFailedEvent(alias, error);

    @Test
    public void getAlias() throws Exception {
        assertEquals(alias, event.getAlias());
    }

    @Test
    public void getError() throws Exception {
        assertEquals(error, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UndoFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UndoFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UndoFailedEventTest {

    @Test
    public void getError() throws Exception {
        UndoFailedEvent event = new UndoFailedEvent(UndoFailedEvent.Error.NONTHING_TO_UNDO);
        assertEquals(UndoFailedEvent.Error.NONTHING_TO_UNDO, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnmarkTaskDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnmarkTaskDoneEvent;
import jfdi.storage.apis.TaskAttributes;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskDoneEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<TaskAttributes> unmarkedTasks;

    @Test
    public void getScreenIds() throws Exception {
        UnmarkTaskDoneEvent event = new UnmarkTaskDoneEvent(screenIds, unmarkedTasks);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getUnmarkedTasks() throws Exception {
        UnmarkTaskDoneEvent event = new UnmarkTaskDoneEvent(screenIds, unmarkedTasks);
        assertEquals(unmarkedTasks, event.getUnmarkedTasks());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UnmarkTaskFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UnmarkTaskFailedEvent;
import org.junit.Test;
import org.mockito.Mock;

import java.util.ArrayList;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UnmarkTaskFailedEventTest {

    @Mock
    private ArrayList<Integer> screenIds;

    @Mock
    private ArrayList<Integer> invalidIds;

    private UnmarkTaskFailedEvent.Error error = UnmarkTaskFailedEvent.Error.NON_EXISTENT_ID;

    @Test
    public void getScreenIds() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(screenIds, event.getScreenIds());
    }

    @Test
    public void getInvalidIds() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(invalidIds, event.getInvalidIds());
    }

    @Test
    public void getError() throws Exception {
        UnmarkTaskFailedEvent event = new UnmarkTaskFailedEvent(screenIds, invalidIds);
        assertEquals(error, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UseDirectoryDoneEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UseDirectoryDoneEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UseDirectoryDoneEventTest {

    private String newDirectory = ".";

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryDoneEvent event = new UseDirectoryDoneEvent(newDirectory);
        assertEquals(newDirectory, event.getNewDirectory());
    }

}
```
###### /src/test/java/jfdi/test/logic/events/UseDirectoryFailedEventTest.java
``` java

package jfdi.test.logic.events;

import jfdi.logic.events.UseDirectoryFailedEvent;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Liu Xinan
 */
public class UseDirectoryFailedEventTest {

    private String newDirectory = "!@#$!@#$";
    private UseDirectoryFailedEvent.Error error = UseDirectoryFailedEvent.Error.INVALID_PATH;

    @Test
    public void getNewDirectory() throws Exception {
        UseDirectoryFailedEvent event = new UseDirectoryFailedEvent(newDirectory, error);
        assertEquals(newDirectory, event.getNewDirectory());
    }

    @Test
    public void getError() throws Exception {
        UseDirectoryFailedEvent event = new UseDirectoryFailedEvent(newDirectory, error);
        assertEquals(error, event.getError());
    }

}
```
###### /src/test/java/jfdi/test/logic/interfaces/CommandTest.java
``` java

package jfdi.test.logic.interfaces;

import jfdi.logic.interfaces.Command;
import jfdi.parser.InputParser;
import jfdi.storage.apis.AliasDb;
import jfdi.storage.apis.MainStorage;
import jfdi.storage.apis.TaskDb;
import jfdi.ui.UI;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.Optional;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertSame;

/**
 * @author Liu Xinan
 */
@RunWith(MockitoJUnitRunner.class)
public class CommandTest {

    private Command command;

    @Mock
    private UI ui;

    @Mock
    private MainStorage mainStorage;

    @Mock
    private TaskDb taskDb;

    @Mock
    private AliasDb aliasDb;

    @Mock
    private InputParser parser;

    @Before
    public void setUp() throws Exception {
        command = Mockito.mock(Command.class, Mockito.CALLS_REAL_METHODS);
        Command.setUi(ui);
        Command.setMainStorage(mainStorage);
        Command.setTaskDb(taskDb);
        Command.setAliasDb(aliasDb);
        Command.setParser(parser);
    }

    @After
    public void tearDown() throws Exception {
        Command.setUi(UI.getInstance());
        Command.setMainStorage(MainStorage.getInstance());
        Command.setTaskDb(TaskDb.getInstance());
        Command.setAliasDb(AliasDb.getInstance());
        Command.setParser(InputParser.getInstance());
        Command.setLastSuggestion(Optional.empty());
        Command.setRedoing(false);
    }

    @Test
    public void testRedoing() throws Exception {
        Command.setRedoing(true);
        assertEquals(true, Command.isRedoing());
        Command.setRedoing(false);
        assertEquals(false, Command.isRedoing());
    }

    @Test
    public void testLastSuggestion() throws Exception {
        Command.setLastSuggestion(Optional.of("list"));
        assertEquals(Optional.of("list"), Command.getLastSuggestion());
        Command.setLastSuggestion(Optional.of("undo"));
        assertEquals(Optional.of("undo"), Command.getLastSuggestion());
    }

    @Test
    public void pushToUndoStack() throws Exception {
        int currentSize = Command.getUndoStack().size();

        command.pushToUndoStack();
        assertEquals(currentSize + 1, Command.getUndoStack().size());

        command.pushToUndoStack();
        assertEquals(currentSize + 2, Command.getUndoStack().size());

        command.pushToRedoStack();
        command.pushToUndoStack();
        assertEquals(currentSize + 4, Command.getUndoStack().size());
    }

    @Test
    public void pushToRedoStack() throws Exception {
        int currentSize = Command.getRedoStack().size();

        command.pushToRedoStack();
        assertEquals(currentSize + 1, Command.getRedoStack().size());

        command.pushToRedoStack();
        assertEquals(currentSize + 2, Command.getRedoStack().size());

        command.pushToRedoStack();
        assertEquals(currentSize + 3, Command.getRedoStack().size());
    }

    @Test
    public void getParser() throws Exception {
        assertSame(parser, Command.getParser());
    }

    @Test
    public void getMainStorage() throws Exception {
        assertSame(mainStorage, Command.getMainStorage());
    }

    @Test
    public void getTaskDb() throws Exception {
        assertSame(taskDb, Command.getTaskDb());
    }

    @Test
    public void getAliasDb() throws Exception {
        assertSame(aliasDb, Command.getAliasDb());
    }

}
```
